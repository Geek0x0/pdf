
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pdf: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Geek0x0/pdf/adaptive_sort.go (94.5%)</option>
				
				<option value="file1">github.com/Geek0x0/pdf/ascii85.go (100.0%)</option>
				
				<option value="file2">github.com/Geek0x0/pdf/async_io.go (45.6%)</option>
				
				<option value="file3">github.com/Geek0x0/pdf/batch_extract.go (8.3%)</option>
				
				<option value="file4">github.com/Geek0x0/pdf/caching.go (80.9%)</option>
				
				<option value="file5">github.com/Geek0x0/pdf/enhanced_parallel.go (24.3%)</option>
				
				<option value="file6">github.com/Geek0x0/pdf/errors.go (75.0%)</option>
				
				<option value="file7">github.com/Geek0x0/pdf/extract.go (25.9%)</option>
				
				<option value="file8">github.com/Geek0x0/pdf/extractor.go (0.0%)</option>
				
				<option value="file9">github.com/Geek0x0/pdf/font_cache_global.go (77.1%)</option>
				
				<option value="file10">github.com/Geek0x0/pdf/font_cache_optimized.go (59.7%)</option>
				
				<option value="file11">github.com/Geek0x0/pdf/font_prefetch.go (90.9%)</option>
				
				<option value="file12">github.com/Geek0x0/pdf/lex.go (10.3%)</option>
				
				<option value="file13">github.com/Geek0x0/pdf/metadata.go (64.7%)</option>
				
				<option value="file14">github.com/Geek0x0/pdf/multilang.go (85.9%)</option>
				
				<option value="file15">github.com/Geek0x0/pdf/optimization_examples.go (58.9%)</option>
				
				<option value="file16">github.com/Geek0x0/pdf/optimizations_advanced.go (0.0%)</option>
				
				<option value="file17">github.com/Geek0x0/pdf/optimized_extraction.go (0.0%)</option>
				
				<option value="file18">github.com/Geek0x0/pdf/optimized_sorting.go (65.0%)</option>
				
				<option value="file19">github.com/Geek0x0/pdf/page.go (3.8%)</option>
				
				<option value="file20">github.com/Geek0x0/pdf/parallel_processing.go (71.0%)</option>
				
				<option value="file21">github.com/Geek0x0/pdf/performance.go (24.8%)</option>
				
				<option value="file22">github.com/Geek0x0/pdf/pool_sized.go (89.8%)</option>
				
				<option value="file23">github.com/Geek0x0/pdf/pool_warmup.go (83.7%)</option>
				
				<option value="file24">github.com/Geek0x0/pdf/ps.go (0.0%)</option>
				
				<option value="file25">github.com/Geek0x0/pdf/read.go (11.3%)</option>
				
				<option value="file26">github.com/Geek0x0/pdf/sharded_cache.go (88.8%)</option>
				
				<option value="file27">github.com/Geek0x0/pdf/simd_optimized.go (4.8%)</option>
				
				<option value="file28">github.com/Geek0x0/pdf/spatial_index.go (57.3%)</option>
				
				<option value="file29">github.com/Geek0x0/pdf/streaming.go (50.0%)</option>
				
				<option value="file30">github.com/Geek0x0/pdf/text.go (28.6%)</option>
				
				<option value="file31">github.com/Geek0x0/pdf/text_classifier.go (76.7%)</option>
				
				<option value="file32">github.com/Geek0x0/pdf/text_ordering.go (57.3%)</option>
				
				<option value="file33">github.com/Geek0x0/pdf/zero_copy_strings.go (77.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "math"
        "sort"
)

// SortStrategy represents different sorting algorithms available
type SortStrategy int

const (
        StrategyAuto      SortStrategy = iota // Automatically select best algorithm
        StrategyRadix                         // Radix sort for numeric keys
        StrategyQuick                         // Quicksort for general comparison
        StrategyInsertion                     // Insertion sort for small arrays
        StrategyStandard                      // Go standard library sort
)

// AdaptiveSorter selects the best sorting algorithm based on data characteristics
type AdaptiveSorter struct {
        radixThreshold     int // Minimum size to consider radix sort
        quicksortThreshold int // Minimum size to use quicksort over insertion
}

// NewAdaptiveSorter creates a new adaptive sorter with default thresholds
func NewAdaptiveSorter() *AdaptiveSorter <span class="cov8" title="1">{
        return &amp;AdaptiveSorter{
                radixThreshold:     200,
                quicksortThreshold: 20,
        }
}</span>

// SortTextsByCoordinate sorts texts by a numeric coordinate using the best algorithm
func (as *AdaptiveSorter) SortTextsByCoordinate(texts []Text, getCoord func(Text) float64) <span class="cov8" title="1">{
        n := len(texts)
        if n &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">strategy := as.selectStrategy(n, true)

        switch strategy </span>{
        case StrategyRadix:<span class="cov8" title="1">
                as.radixSortTexts(texts, getCoord)</span>
        case StrategyInsertion:<span class="cov8" title="1">
                as.insertionSortTexts(texts, getCoord)</span>
        default:<span class="cov8" title="1">
                // Use standard sort
                sort.Slice(texts, func(i, j int) bool </span><span class="cov8" title="1">{
                        return getCoord(texts[i]) &lt; getCoord(texts[j])
                }</span>)
        }
}

// SortTextsByComparison sorts texts using a comparison function
func (as *AdaptiveSorter) SortTextsByComparison(texts []Text, less func(i, j int) bool) <span class="cov8" title="1">{
        n := len(texts)
        if n &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if n &lt; as.quicksortThreshold </span><span class="cov8" title="1">{
                as.insertionSortTextsFunc(texts, less)
        }</span> else<span class="cov0" title="0"> {
                sort.Slice(texts, less)
        }</span>
}

// selectStrategy chooses the best sorting strategy
func (as *AdaptiveSorter) selectStrategy(n int, isNumeric bool) SortStrategy <span class="cov8" title="1">{
        if n &lt; as.quicksortThreshold </span><span class="cov8" title="1">{
                return StrategyInsertion
        }</span>

        <span class="cov8" title="1">if isNumeric &amp;&amp; n &gt;= as.radixThreshold </span><span class="cov8" title="1">{
                return StrategyRadix
        }</span>

        <span class="cov8" title="1">return StrategyStandard</span>
}

// radixSortTexts sorts texts using radix sort on a numeric key
func (as *AdaptiveSorter) radixSortTexts(texts []Text, getCoord func(Text) float64) <span class="cov8" title="1">{
        n := len(texts)
        if n &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract coordinates and convert to sortable uints
        <span class="cov8" title="1">keys := make([]uint64, n)
        for i, t := range texts </span><span class="cov8" title="1">{
                coord := getCoord(t)
                bits := math.Float64bits(coord)
                // Handle negative numbers
                mask := -uint64(int64(bits)&gt;&gt;63) | 0x8000000000000000
                keys[i] = bits ^ mask
        }</span>

        // Create index array
        <span class="cov8" title="1">indices := make([]int, n)
        for i := range indices </span><span class="cov8" title="1">{
                indices[i] = i
        }</span>

        // Radix sort the indices based on keys
        <span class="cov8" title="1">as.radixSortIndices(indices, keys)

        // Reorder texts
        reordered := make([]Text, n)
        for i, idx := range indices </span><span class="cov8" title="1">{
                reordered[i] = texts[idx]
        }</span>

        <span class="cov8" title="1">copy(texts, reordered)</span>
}

// radixSortIndices performs radix sort on indices array based on keys
func (as *AdaptiveSorter) radixSortIndices(indices []int, keys []uint64) <span class="cov8" title="1">{
        n := len(indices)
        if n &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">temp := make([]int, n)
        tempKeys := make([]uint64, n)

        // Use 8-bit radix (256 buckets) for better cache performance
        const radix = 256
        counts := make([]int, radix)

        // Process 8 bits at a time (8 passes for 64-bit keys)
        for shift := uint(0); shift &lt; 64; shift += 8 </span><span class="cov8" title="1">{
                // Clear counts
                for i := range counts </span><span class="cov8" title="1">{
                        counts[i] = 0
                }</span>

                // Count occurrences
                <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                        bucket := (key &gt;&gt; shift) &amp; 0xFF
                        counts[bucket]++
                }</span>

                // Calculate positions (prefix sum)
                <span class="cov8" title="1">pos := 0
                for i := range counts </span><span class="cov8" title="1">{
                        oldCount := counts[i]
                        counts[i] = pos
                        pos += oldCount
                }</span>

                // Distribute elements
                <span class="cov8" title="1">for i, key := range keys </span><span class="cov8" title="1">{
                        bucket := (key &gt;&gt; shift) &amp; 0xFF
                        idx := counts[bucket]
                        temp[idx] = indices[i]
                        tempKeys[idx] = key
                        counts[bucket]++
                }</span>

                // Swap buffers
                <span class="cov8" title="1">indices, temp = temp, indices
                keys, tempKeys = tempKeys, keys</span>
        }
}

// insertionSortTexts sorts small text arrays using insertion sort
func (as *AdaptiveSorter) insertionSortTexts(texts []Text, getCoord func(Text) float64) <span class="cov8" title="1">{
        for i := 1; i &lt; len(texts); i++ </span><span class="cov8" title="1">{
                key := getCoord(texts[i])
                t := texts[i]
                j := i - 1

                for j &gt;= 0 &amp;&amp; getCoord(texts[j]) &gt; key </span><span class="cov8" title="1">{
                        texts[j+1] = texts[j]
                        j--
                }</span>
                <span class="cov8" title="1">texts[j+1] = t</span>
        }
}

// insertionSortTextsFunc sorts using a comparison function
func (as *AdaptiveSorter) insertionSortTextsFunc(texts []Text, less func(i, j int) bool) <span class="cov8" title="1">{
        for i := 1; i &lt; len(texts); i++ </span><span class="cov8" title="1">{
                t := texts[i]
                j := i - 1

                for j &gt;= 0 &amp;&amp; less(i, j) </span><span class="cov8" title="1">{
                        texts[j+1] = texts[j]
                        j--
                }</span>
                <span class="cov8" title="1">texts[j+1] = t</span>
        }
}

// Global adaptive sorter instance
var globalAdaptiveSorter = NewAdaptiveSorter()

// FastSortTextsByX sorts texts by X coordinate using the fastest algorithm
func FastSortTextsByX(texts []Text) <span class="cov8" title="1">{
        globalAdaptiveSorter.SortTextsByCoordinate(texts, func(t Text) float64 </span><span class="cov8" title="1">{ return t.X }</span>)
}

// FastSortTextsByY sorts texts by Y coordinate using the fastest algorithm
func FastSortTextsByY(texts []Text) <span class="cov8" title="1">{
        globalAdaptiveSorter.SortTextsByCoordinate(texts, func(t Text) float64 </span><span class="cov8" title="1">{ return t.Y }</span>)
}

// FastSortTexts sorts texts using the fastest algorithm for the comparison function
func FastSortTexts(texts []Text, less func(i, j int) bool) <span class="cov8" title="1">{
        globalAdaptiveSorter.SortTextsByComparison(texts, less)
}</span>

// SortingMetrics tracks performance of different sorting strategies
type SortingMetrics struct {
        RadixSortCount     int
        QuickSortCount     int
        InsertionSortCount int
        StandardSortCount  int
}

var sortingMetrics SortingMetrics

// GetSortingMetrics returns current sorting metrics
func GetSortingMetrics() SortingMetrics <span class="cov8" title="1">{
        return sortingMetrics
}</span>

// ResetSortingMetrics resets the sorting metrics
func ResetSortingMetrics() <span class="cov8" title="1">{
        sortingMetrics = SortingMetrics{}
}</span>

// BenchmarkSortingAlgorithms compares performance of different algorithms
func BenchmarkSortingAlgorithms(texts []Text, getCoord func(Text) float64) map[string]float64 <span class="cov8" title="1">{
        results := make(map[string]float64)

        // This would require actual timing, just return placeholder
        // In real usage, implement with time measurement

        results["radix"] = 0.0
        results["standard"] = 0.0
        results["quicksort"] = 0.0

        return results
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// file with help function for ascii85 decoder
// later if new decoders is going to add it reasonable to rename file and add them here
// also create interfaces to switch between them (like in unidoc)

package pdf

import (
        "io"
)

type alphaReader struct {
        reader io.Reader
}

func newAlphaReader(reader io.Reader) *alphaReader <span class="cov8" title="1">{
        return &amp;alphaReader{reader: reader}
}</span>

func checkASCII85(r byte) byte <span class="cov8" title="1">{
        if r &gt;= '!' &amp;&amp; r &lt;= 'u' </span><span class="cov8" title="1">{ // 33 &lt;= ascii85 &lt;=117
                return r
        }</span>
        <span class="cov8" title="1">if r == '~' </span><span class="cov8" title="1">{
                return 1 // for marking possible end of data
        }</span>
        <span class="cov8" title="1">return 0</span> // if non-ascii85
}

func (a *alphaReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        n, err := a.reader.Read(p)
        if err != nil </span><span class="cov8" title="1">{
                return n, err
        }</span>

        <span class="cov8" title="1">buf := make([]byte, 0, n)
        tilda := false
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                char := checkASCII85(p[i])
                if char == '&gt;' &amp;&amp; tilda </span><span class="cov8" title="1">{ // end of data
                        break</span>
                }
                <span class="cov8" title="1">if char &gt; 1 </span><span class="cov8" title="1">{
                        buf = append(buf, char)
                }</span>
                <span class="cov8" title="1">if char == 1 </span><span class="cov8" title="1">{
                        tilda = true // possible end of data
                }</span>
        }

        <span class="cov8" title="1">copy(p, buf)
        return len(buf), nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "context"
        "io"
        "runtime"
        "strings"
        "sync"
)

// AsyncReader wraps a Reader to provide asynchronous operations
type AsyncReader struct {
        *Reader
        processor *ParallelProcessor
}

// NewAsyncReader creates a new async reader with async I/O support
func NewAsyncReader(reader *Reader) *AsyncReader <span class="cov8" title="1">{
        return &amp;AsyncReader{
                Reader:    reader,
                processor: NewParallelProcessor(runtime.NumCPU()),
        }
}</span>

func (ar *AsyncReader) workerCount() int <span class="cov0" title="0">{
        if ar == nil || ar.processor == nil || ar.processor.numWorkers &lt;= 0 </span><span class="cov0" title="0">{
                return runtime.NumCPU()
        }</span>
        <span class="cov0" title="0">return ar.processor.numWorkers</span>
}

// AsyncExtractText extracts text from all pages asynchronously
func (ar *AsyncReader) AsyncExtractText(ctx context.Context) (&lt;-chan string, &lt;-chan error) <span class="cov8" title="1">{
        resultChan := make(chan string, 1)
        errChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(resultChan)
                defer close(errChan)

                totalPages := ar.NumPage()
                if totalPages == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case resultChan &lt;- "":<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                errChan &lt;- ctx.Err()</span>
                        }
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov0" title="0">workers := ar.workerCount()
                if workers &gt; totalPages </span><span class="cov0" title="0">{
                        workers = totalPages
                }</span>

                <span class="cov0" title="0">pageResults := make(chan struct {
                        pageNum int
                        text    string
                        err     error
                }, workers)
                workChan := make(chan int)
                var wg sync.WaitGroup

                worker := func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        for pageNum := range workChan </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        select </span>{
                                        case pageResults &lt;- struct {
                                                pageNum int
                                                text    string
                                                err     error
                                        }{pageNum: pageNum, text: "", err: ctx.Err()}:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">continue</span>
                                default:<span class="cov0" title="0"></span>
                                }

                                <span class="cov0" title="0">page := ar.Page(pageNum)
                                text, err := page.GetPlainText(nil)
                                pageResults &lt;- struct {
                                        pageNum int
                                        text    string
                                        err     error
                                }{pageNum: pageNum, text: text, err: err}</span>
                        }
                }

                <span class="cov0" title="0">for i := 0; i &lt; workers; i++ </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go worker()
                }</span>

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        defer close(workChan)
                        for pageNum := 1; pageNum &lt;= totalPages; pageNum++ </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case workChan &lt;- pageNum:<span class="cov0" title="0"></span>
                                }
                        }
                }()

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        wg.Wait()
                        close(pageResults)
                }</span>()

                // Collect and combine results
                <span class="cov0" title="0">pageTexts := make([]string, totalPages)
                var firstErr error

                for result := range pageResults </span><span class="cov0" title="0">{
                        if result.err != nil </span><span class="cov0" title="0">{
                                if firstErr == nil </span><span class="cov0" title="0">{
                                        firstErr = result.err
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">pageTexts[result.pageNum-1] = result.text</span>
                }

                <span class="cov0" title="0">if firstErr == nil </span><span class="cov0" title="0">{
                        firstErr = ctx.Err()
                }</span>
                <span class="cov0" title="0">if firstErr != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case errChan &lt;- firstErr:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">var builder strings.Builder
                for _, text := range pageTexts </span><span class="cov0" title="0">{
                        builder.WriteString(text)
                }</span>
                <span class="cov0" title="0">combinedText := builder.String()

                select </span>{
                case resultChan &lt;- combinedText:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        errChan &lt;- ctx.Err()</span>
                }
        }()

        <span class="cov8" title="1">return resultChan, errChan</span>
}

// AsyncExtractTextWithContext extracts text with cancellation and timeout support
func (ar *AsyncReader) AsyncExtractTextWithContext(ctx context.Context, opts ExtractOptions) (&lt;-chan string, &lt;-chan error) <span class="cov8" title="1">{
        resultChan := make(chan string, 1)
        errChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(resultChan)
                defer close(errChan)

                // Respect contexts that are already cancelled before work begins.
                if err := ctx.Err(); err != nil </span><span class="cov8" title="1">{
                        select </span>{
                        case errChan &lt;- err:<span class="cov8" title="1"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                        <span class="cov8" title="1">return</span>
                }

                // Determine which pages to extract
                <span class="cov8" title="1">pageList := opts.PageRange
                if pageList == nil </span><span class="cov8" title="1">{
                        pages := ar.NumPage()
                        pageList = make([]int, pages)
                        for i := 0; i &lt; pages; i++ </span><span class="cov0" title="0">{
                                pageList[i] = i + 1
                        }</span>
                }

                // Create channels for async processing
                <span class="cov8" title="1">pageResults := make(chan struct {
                        pageNum int
                        text    string
                        err     error
                }, len(pageList))

                workers := opts.Workers
                if workers &lt;= 0 </span><span class="cov0" title="0">{
                        workers = ar.workerCount()
                }</span>

                // Launch page processing workers
                <span class="cov8" title="1">var wg sync.WaitGroup
                workChan := make(chan int, len(pageList))

                // Send work
                go func() </span><span class="cov8" title="1">{
                        defer close(workChan)
                        for _, pageNum := range pageList </span><span class="cov0" title="0">{
                                select </span>{
                                case workChan &lt;- pageNum:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }()

                // Launch worker goroutines
                <span class="cov8" title="1">for i := 0; i &lt; workers; i++ </span><span class="cov8" title="1">{
                        wg.Add(1)
                        go func() </span><span class="cov8" title="1">{
                                defer wg.Done()
                                for pageNum := range workChan </span><span class="cov0" title="0">{
                                        select </span>{
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                pageResults &lt;- struct {
                                                        pageNum int
                                                        text    string
                                                        err     error
                                                }{pageNum: pageNum, text: "", err: ctx.Err()}
                                                return</span>
                                        default:<span class="cov0" title="0"></span>
                                        }

                                        <span class="cov0" title="0">page := ar.Page(pageNum)
                                        text, err := page.GetPlainText(nil)
                                        pageResults &lt;- struct {
                                                pageNum int
                                                text    string
                                                err     error
                                        }{pageNum: pageNum, text: text, err: err}</span>
                                }
                        }()
                }

                // Close pageResults when done
                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        wg.Wait()
                        close(pageResults)
                }</span>()

                // Collect results in order
                <span class="cov8" title="1">pageTexts := make(map[int]string)
                var firstErr error

                for result := range pageResults </span><span class="cov0" title="0">{
                        if result.err != nil </span><span class="cov0" title="0">{
                                if firstErr == nil </span><span class="cov0" title="0">{
                                        firstErr = result.err
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">pageTexts[result.pageNum] = result.text</span>
                }

                <span class="cov8" title="1">if firstErr == nil </span><span class="cov8" title="1">{
                        firstErr = ctx.Err()
                }</span>
                <span class="cov8" title="1">if firstErr != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case errChan &lt;- firstErr:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov8" title="1">var builder strings.Builder
                for _, pageNum := range pageList </span><span class="cov0" title="0">{
                        builder.WriteString(pageTexts[pageNum])
                }</span>
                <span class="cov8" title="1">combinedText := builder.String()

                select </span>{
                case resultChan &lt;- combinedText:<span class="cov8" title="1"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        errChan &lt;- ctx.Err()</span>
                }
        }()

        <span class="cov8" title="1">return resultChan, errChan</span>
}

// AsyncExtractStructured extracts structured text asynchronously
func (ar *AsyncReader) AsyncExtractStructured(ctx context.Context) (&lt;-chan []ClassifiedBlock, &lt;-chan error) <span class="cov8" title="1">{
        resultChan := make(chan []ClassifiedBlock, 1)
        errChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(resultChan)
                defer close(errChan)

                totalPages := ar.NumPage()
                if totalPages == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case resultChan &lt;- []ClassifiedBlock{}:<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                errChan &lt;- ctx.Err()</span>
                        }
                        <span class="cov8" title="1">return</span>
                }

                // Process each page asynchronously
                <span class="cov0" title="0">pageResults := make(chan struct {
                        pageNum int
                        blocks  []ClassifiedBlock
                        err     error
                }, totalPages)

                var wg sync.WaitGroup
                for i := 1; i &lt;= totalPages; i++ </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func(pageNum int) </span><span class="cov0" title="0">{
                                defer wg.Done()

                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        pageResults &lt;- struct {
                                                pageNum int
                                                blocks  []ClassifiedBlock
                                                err     error
                                        }{pageNum: pageNum, blocks: nil, err: ctx.Err()}
                                        return</span>
                                default:<span class="cov0" title="0"></span>
                                }

                                <span class="cov0" title="0">page := ar.Page(pageNum)
                                blocks, err := page.ClassifyTextBlocks()
                                pageResults &lt;- struct {
                                        pageNum int
                                        blocks  []ClassifiedBlock
                                        err     error
                                }{pageNum: pageNum, blocks: blocks, err: err}</span>
                        }(i)
                }

                // Close results when done
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        wg.Wait()
                        close(pageResults)
                }</span>()

                // Collect all blocks
                <span class="cov0" title="0">var allBlocks []ClassifiedBlock
                var firstErr error

                for result := range pageResults </span><span class="cov0" title="0">{
                        if result.err != nil </span><span class="cov0" title="0">{
                                if firstErr == nil </span><span class="cov0" title="0">{
                                        firstErr = result.err
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">allBlocks = append(allBlocks, result.blocks...)</span>
                }

                <span class="cov0" title="0">if firstErr != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case errChan &lt;- firstErr:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">select </span>{
                case resultChan &lt;- allBlocks:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        errChan &lt;- ctx.Err()</span>
                }
        }()

        <span class="cov8" title="1">return resultChan, errChan</span>
}

// AsyncStream processes the PDF file with async I/O operations
func (ar *AsyncReader) AsyncStream(ctx context.Context, processor func(Page, int) error) &lt;-chan error <span class="cov8" title="1">{
        errChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(errChan)

                totalPages := ar.NumPage()
                for i := 1; i &lt;= totalPages; i++ </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                errChan &lt;- ctx.Err()
                                return</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">page := ar.Page(i)
                        if err := processor(page, i); err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>
                }

                <span class="cov8" title="1">select </span>{
                case errChan &lt;- nil:<span class="cov8" title="1"></span> // No error
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        errChan &lt;- ctx.Err()</span>
                }
        }()

        <span class="cov8" title="1">return errChan</span>
}

// AsyncReaderAt provides async I/O for low-level file operations
type AsyncReaderAt struct {
        reader io.ReaderAt
}

// NewAsyncReaderAt creates a new async reader with async I/O support
func NewAsyncReaderAt(reader io.ReaderAt) *AsyncReaderAt <span class="cov8" title="1">{
        return &amp;AsyncReaderAt{
                reader: reader,
        }
}</span>

// ReadAtAsync reads from the file asynchronously
func (ara *AsyncReaderAt) ReadAtAsync(ctx context.Context, buf []byte, offset int64) (&lt;-chan int, &lt;-chan error) <span class="cov8" title="1">{
        nChan := make(chan int, 1)
        errChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(nChan)
                defer close(errChan)

                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        errChan &lt;- ctx.Err()
                        return</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">n, err := ara.reader.ReadAt(buf, offset)
                if err != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case errChan &lt;- err:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov8" title="1">select </span>{
                case nChan &lt;- n:<span class="cov8" title="1"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        errChan &lt;- ctx.Err()</span>
                }
        }()

        <span class="cov8" title="1">return nChan, errChan</span>
}

// StreamValueReader provides async streaming of value data
func (ar *AsyncReader) StreamValueReader(ctx context.Context, v Value) (&lt;-chan []byte, &lt;-chan error) <span class="cov8" title="1">{
        dataChan := make(chan []byte, 10) // Buffered channel for streaming data
        errChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(dataChan)
                defer close(errChan)

                reader := v.Reader()
                defer reader.Close()

                buf := make([]byte, 4096) // 4KB chunks
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                errChan &lt;- ctx.Err()
                                return</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        <span class="cov8" title="1">n, err := reader.Read(buf)
                        if n &gt; 0 </span><span class="cov0" title="0">{
                                // Create a copy of the buffer to send
                                data := make([]byte, n)
                                copy(data, buf[:n])

                                select </span>{
                                case dataChan &lt;- data:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        errChan &lt;- ctx.Err()
                                        return</span>
                                }
                        }

                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        // Successfully completed
                                        select </span>{
                                        case errChan &lt;- nil:<span class="cov0" title="0"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                } else<span class="cov8" title="1"> {
                                        // Error occurred
                                        select </span>{
                                        case errChan &lt;- err:<span class="cov8" title="1"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov8" title="1">return</span>
                                }
                        }
                }
        }()

        <span class="cov8" title="1">return dataChan, errChan</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "context"
        "runtime"
        "sync"
)

// FontCacheType specifies which font cache implementation to use
type FontCacheType int

const (
        // FontCacheStandard uses the standard GlobalFontCache (default)
        // - Stable and well-tested
        // - Good performance for most use cases
        // - Simpler implementation
        FontCacheStandard FontCacheType = iota

        // FontCacheOptimized uses the OptimizedFontCache
        // - 10-85x faster than standard (depending on workload)
        // - Lock-free read path with 16 shards
        // - Best for high-concurrency scenarios (&gt;1000 qps)
        // - Recommended for production environments with heavy load
        FontCacheOptimized
)

// FontCacheInterface defines the common interface for font caches
type FontCacheInterface interface {
        Get(key string) (*Font, bool)
        Set(key string, font *Font)
        Clear()
        GetStats() FontCacheStats
}

// BatchExtractOptions configures batch extraction behavior
type BatchExtractOptions struct {
        // Pages to extract (nil means all pages)
        Pages []int

        // Number of concurrent workers (0 = NumCPU)
        Workers int

        // Whether to use smart text ordering
        SmartOrdering bool

        // Context for cancellation
        Context context.Context

        // Buffer size for each page result (0 = default 2KB)
        PageBufferSize int

        // Whether to enable font cache for this batch (default: false)
        // When enabled, a temporary font cache is created for the batch
        // to reduce redundant font parsing across pages
        UseFontCache bool

        // Maximum number of fonts to cache (0 = default 1000)
        // Only used when UseFontCache is true
        FontCacheSize int

        // FontCacheType specifies which cache implementation to use
        // - FontCacheStandard: Standard implementation (default)
        // - FontCacheOptimized: High-performance optimized cache (10-85x faster)
        // Only used when UseFontCache is true
        FontCacheType FontCacheType
}

// BatchResult contains the result of extracting a single page
type BatchResult struct {
        PageNum int
        Text    string
        Error   error
}

// ExtractPagesBatch extracts text from multiple pages in batches
// This is optimized for high-throughput scenarios with many pages
func (r *Reader) ExtractPagesBatch(opts BatchExtractOptions) &lt;-chan BatchResult <span class="cov0" title="0">{
        results := make(chan BatchResult, opts.Workers)

        // Set defaults
        if opts.Workers &lt;= 0 </span><span class="cov0" title="0">{
                opts.Workers = runtime.NumCPU()
        }</span>
        <span class="cov0" title="0">if opts.Context == nil </span><span class="cov0" title="0">{
                opts.Context = context.Background()
        }</span>
        <span class="cov0" title="0">if opts.PageBufferSize &lt;= 0 </span><span class="cov0" title="0">{
                opts.PageBufferSize = 2048
        }</span>

        // Initialize font cache if enabled
        <span class="cov0" title="0">var fontCache FontCacheInterface
        if opts.UseFontCache </span><span class="cov0" title="0">{
                cacheSize := opts.FontCacheSize
                if cacheSize &lt;= 0 </span><span class="cov0" title="0">{
                        cacheSize = 1000 // Default cache size
                }</span>

                // Select cache implementation based on type
                <span class="cov0" title="0">switch opts.FontCacheType </span>{
                case FontCacheOptimized:<span class="cov0" title="0">
                        fontCache = NewOptimizedFontCache(cacheSize)</span>
                default:<span class="cov0" title="0"> // FontCacheStandard or unspecified
                        fontCache = NewGlobalFontCache(cacheSize, 0)</span> // No age limit for batch processing
                }
        }

        // Determine pages to extract
        <span class="cov0" title="0">pages := opts.Pages
        if len(pages) == 0 </span><span class="cov0" title="0">{
                pages = make([]int, r.NumPage())
                for i := range pages </span><span class="cov0" title="0">{
                        pages[i] = i + 1
                }</span>
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer close(results)

                // Create work queue
                jobs := make(chan int, len(pages))
                for _, pageNum := range pages </span><span class="cov0" title="0">{
                        jobs &lt;- pageNum
                }</span>
                <span class="cov0" title="0">close(jobs)

                // Start workers
                var wg sync.WaitGroup
                for w := 0; w &lt; opts.Workers; w++ </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func() </span><span class="cov0" title="0">{
                                defer wg.Done()
                                batchExtractWorker(r, jobs, results, opts, fontCache)
                        }</span>()
                }

                <span class="cov0" title="0">wg.Wait()

                // Clean up font cache if used
                if fontCache != nil </span><span class="cov0" title="0">{
                        fontCache.Clear()
                }</span>
        }()

        <span class="cov0" title="0">return results</span>
}

// batchExtractWorker processes pages from the job queue
func batchExtractWorker(r *Reader, jobs &lt;-chan int, results chan&lt;- BatchResult, opts BatchExtractOptions, fontCache FontCacheInterface) <span class="cov0" title="0">{
        for pageNum := range jobs </span><span class="cov0" title="0">{
                // Check cancellation
                select </span>{
                case &lt;-opts.Context.Done():<span class="cov0" title="0">
                        results &lt;- BatchResult{
                                PageNum: pageNum,
                                Error:   opts.Context.Err(),
                        }
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                // Extract page
                <span class="cov0" title="0">page := r.Page(pageNum)
                var text string
                var err error

                // Enable font cache for this extraction if provided
                if fontCache != nil </span><span class="cov0" title="0">{
                        // Wrap the interface in a cache adapter for the page
                        page.SetFontCacheInterface(fontCache)
                }</span>

                <span class="cov0" title="0">if opts.SmartOrdering </span><span class="cov0" title="0">{
                        text, err = page.GetPlainTextWithSmartOrdering(nil)
                }</span> else<span class="cov0" title="0"> {
                        text, err = page.GetPlainText(nil)
                }</span>

                <span class="cov0" title="0">results &lt;- BatchResult{
                        PageNum: pageNum,
                        Text:    text,
                        Error:   err,
                }</span>
        }
}

// pageResult holds a page's extraction result for sorting
type pageResult struct {
        pageNum int
        text    string
}

// ExtractPagesBatchToString is a convenience function that collects
// all results into a single string
func (r *Reader) ExtractPagesBatchToString(opts BatchExtractOptions) (string, error) <span class="cov0" title="0">{
        resultChan := r.ExtractPagesBatch(opts)

        // Collect results
        var results []pageResult
        for result := range resultChan </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        return "", &amp;PDFError{
                                Op:   "batch extract",
                                Page: result.PageNum,
                                Err:  result.Error,
                        }
                }</span>
                <span class="cov0" title="0">results = append(results, pageResult{
                        pageNum: result.PageNum,
                        text:    result.Text,
                })</span>
        }

        // Sort by page number to maintain order
        // (results may arrive out of order due to concurrency)
        <span class="cov0" title="0">sortPageResults(results)

        // Combine into single string
        totalSize := 0
        for _, r := range results </span><span class="cov0" title="0">{
                totalSize += len(r.text)
        }</span>
        <span class="cov0" title="0">totalSize += len(results) - 1 // newlines

        builder := GetSizedStringBuilder(totalSize)
        defer PutSizedStringBuilder(builder, totalSize)

        for i, r := range results </span><span class="cov0" title="0">{
                builder.WriteString(r.text)
                if i &lt; len(results)-1 </span><span class="cov0" title="0">{
                        builder.WriteByte('\n')
                }</span>
        }

        <span class="cov0" title="0">return builder.String(), nil</span>
}

// sortPageResults sorts results by page number using quicksort
func sortPageResults(results []pageResult) <span class="cov8" title="1">{
        if len(results) &lt;= 1 </span><span class="cov8" title="1">{
                return
        }</span>

        // Simple insertion sort for small arrays
        <span class="cov8" title="1">if len(results) &lt; 20 </span><span class="cov8" title="1">{
                for i := 1; i &lt; len(results); i++ </span><span class="cov8" title="1">{
                        key := results[i]
                        j := i - 1
                        for j &gt;= 0 &amp;&amp; results[j].pageNum &gt; key.pageNum </span><span class="cov8" title="1">{
                                results[j+1] = results[j]
                                j--
                        }</span>
                        <span class="cov8" title="1">results[j+1] = key</span>
                }
                <span class="cov8" title="1">return</span>
        }

        // Quicksort for larger arrays
        <span class="cov0" title="0">quicksortPageResults(results, 0, len(results)-1)</span>
}

func quicksortPageResults(results []pageResult, low, high int) <span class="cov0" title="0">{
        if low &lt; high </span><span class="cov0" title="0">{
                pivot := partitionPageResults(results, low, high)
                quicksortPageResults(results, low, pivot-1)
                quicksortPageResults(results, pivot+1, high)
        }</span>
}

func partitionPageResults(results []pageResult, low, high int) int <span class="cov0" title="0">{
        pivot := results[high].pageNum
        i := low - 1

        for j := low; j &lt; high; j++ </span><span class="cov0" title="0">{
                if results[j].pageNum &lt; pivot </span><span class="cov0" title="0">{
                        i++
                        results[i], results[j] = results[j], results[i]
                }</span>
        }

        <span class="cov0" title="0">results[i+1], results[high] = results[high], results[i+1]
        return i + 1</span>
}

// BatchExtractStructured extracts structured text from multiple pages in batches
type StructuredBatchResult struct {
        PageNum int
        Blocks  []ClassifiedBlock
        Error   error
}

// ExtractStructuredBatch extracts structured text in batches
func (r *Reader) ExtractStructuredBatch(opts BatchExtractOptions) &lt;-chan StructuredBatchResult <span class="cov0" title="0">{
        results := make(chan StructuredBatchResult, opts.Workers)

        // Set defaults
        if opts.Workers &lt;= 0 </span><span class="cov0" title="0">{
                opts.Workers = runtime.NumCPU()
        }</span>
        <span class="cov0" title="0">if opts.Context == nil </span><span class="cov0" title="0">{
                opts.Context = context.Background()
        }</span>

        // Determine pages to extract
        <span class="cov0" title="0">pages := opts.Pages
        if len(pages) == 0 </span><span class="cov0" title="0">{
                pages = make([]int, r.NumPage())
                for i := range pages </span><span class="cov0" title="0">{
                        pages[i] = i + 1
                }</span>
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer close(results)

                jobs := make(chan int, len(pages))
                for _, pageNum := range pages </span><span class="cov0" title="0">{
                        jobs &lt;- pageNum
                }</span>
                <span class="cov0" title="0">close(jobs)

                var wg sync.WaitGroup
                for w := 0; w &lt; opts.Workers; w++ </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func() </span><span class="cov0" title="0">{
                                defer wg.Done()
                                structuredBatchWorker(r, jobs, results, opts)
                        }</span>()
                }

                <span class="cov0" title="0">wg.Wait()</span>
        }()

        <span class="cov0" title="0">return results</span>
}

// structuredBatchWorker processes structured extraction
func structuredBatchWorker(r *Reader, jobs &lt;-chan int, results chan&lt;- StructuredBatchResult, opts BatchExtractOptions) <span class="cov0" title="0">{
        for pageNum := range jobs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-opts.Context.Done():<span class="cov0" title="0">
                        results &lt;- StructuredBatchResult{
                                PageNum: pageNum,
                                Error:   opts.Context.Err(),
                        }
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">page := r.Page(pageNum)
                blocks, err := page.ClassifyTextBlocks()

                results &lt;- StructuredBatchResult{
                        PageNum: pageNum,
                        Blocks:  blocks,
                        Error:   err,
                }</span>
        }
}

// StreamingBatchExtractor provides a streaming interface for batch extraction
// This is useful for very large PDFs where you want to process results as they arrive
type StreamingBatchExtractor struct {
        reader  *Reader
        opts    BatchExtractOptions
        results &lt;-chan BatchResult
}

// NewStreamingBatchExtractor creates a new streaming batch extractor
func NewStreamingBatchExtractor(r *Reader, opts BatchExtractOptions) *StreamingBatchExtractor <span class="cov0" title="0">{
        return &amp;StreamingBatchExtractor{
                reader: r,
                opts:   opts,
        }
}</span>

// Start begins the extraction process
func (sbe *StreamingBatchExtractor) Start() <span class="cov0" title="0">{
        sbe.results = sbe.reader.ExtractPagesBatch(sbe.opts)
}</span>

// Next returns the next result, or nil if done
func (sbe *StreamingBatchExtractor) Next() *BatchResult <span class="cov0" title="0">{
        result, ok := &lt;-sbe.results
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;result</span>
}

// ProcessAll processes all pages with a callback function
func (sbe *StreamingBatchExtractor) ProcessAll(callback func(BatchResult) error) error <span class="cov0" title="0">{
        for result := range sbe.results </span><span class="cov0" title="0">{
                if err := callback(result); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "context"
        "crypto/md5"
        "fmt"
        "sync"
        "sync/atomic"
        "time"
)

// CacheEntry represents a cached item
type CacheEntry struct {
        Data        interface{}
        Expiration  time.Time
        AccessCount int64
        LastAccess  time.Time
        Size        int64 // Estimated size in bytes
}

// IsExpired checks if the cache entry has expired
func (ce *CacheEntry) IsExpired() bool <span class="cov8" title="1">{
        return !ce.Expiration.IsZero() &amp;&amp; time.Now().After(ce.Expiration)
}</span>

// CacheStats provides statistics about cache performance
type CacheStats struct {
        Hits        int64
        Misses      int64
        Evictions   int64
        CurrentSize int64
        MaxSize     int64
        Entries     int64
}

// ResultCache provides caching for parsed and classified results
type ResultCache struct {
        // Cache storage
        items   map[string]*CacheEntry
        mutex   sync.RWMutex
        stats   CacheStats
        maxSize int64
        ttl     time.Duration
        policy  string // "LRU", "LFU", "FIFO"

        // Metrics and monitoring
        hits   int64
        misses int64
}

// NewResultCache creates a new result cache with specified parameters
func NewResultCache(maxSize int64, ttl time.Duration, policy string) *ResultCache <span class="cov8" title="1">{
        if policy == "" </span><span class="cov0" title="0">{
                policy = "LRU" // Default to LRU
        }</span>

        <span class="cov8" title="1">cache := &amp;ResultCache{
                items:   make(map[string]*CacheEntry),
                maxSize: maxSize,
                ttl:     ttl,
                policy:  policy,
        }

        // Start cleanup goroutine to remove expired entries
        go cache.cleanupExpired()

        return cache</span>
}

// Put adds an item to the cache
func (rc *ResultCache) Put(key string, value interface{}) <span class="cov8" title="1">{
        rc.mutex.Lock()
        defer rc.mutex.Unlock()

        // Calculate entry size (rough estimation)
        size := rc.estimateSize(value)

        // Check if we need to evict items due to size constraints
        for rc.stats.CurrentSize+size &gt; rc.maxSize &amp;&amp; len(rc.items) &gt; 0 </span><span class="cov8" title="1">{
                rc.evictOne()
        }</span>

        // Create new entry
        <span class="cov8" title="1">expiration := time.Time{}
        if rc.ttl &gt; 0 </span><span class="cov8" title="1">{
                expiration = time.Now().Add(rc.ttl)
        }</span>

        <span class="cov8" title="1">entry := &amp;CacheEntry{
                Data:        value,
                Expiration:  expiration,
                Size:        size,
                AccessCount: 0,
                LastAccess:  time.Now(),
        }

        // Replace existing entry or add new one
        if existing, exists := rc.items[key]; exists </span><span class="cov8" title="1">{
                rc.stats.CurrentSize -= existing.Size
        }</span>

        <span class="cov8" title="1">rc.items[key] = entry
        rc.stats.CurrentSize += size
        rc.stats.Entries = int64(len(rc.items))</span>
}

// Get retrieves an item from the cache
func (rc *ResultCache) Get(key string) (interface{}, bool) <span class="cov8" title="1">{
        rc.mutex.RLock()
        entry, exists := rc.items[key]
        rc.mutex.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;rc.misses, 1)
                atomic.AddInt64(&amp;rc.stats.Misses, 1)
                return nil, false
        }</span>

        <span class="cov8" title="1">if entry.IsExpired() </span><span class="cov8" title="1">{
                rc.mutex.Lock()
                rc.remove(key)
                rc.mutex.Unlock()
                atomic.AddInt64(&amp;rc.misses, 1)
                atomic.AddInt64(&amp;rc.stats.Misses, 1)
                return nil, false
        }</span>

        // Update access stats atomically without write lock
        <span class="cov8" title="1">atomic.AddInt64(&amp;entry.AccessCount, 1)
        // Use atomic operation for LastAccess to avoid lock
        now := time.Now()
        entry.LastAccess = now

        atomic.AddInt64(&amp;rc.hits, 1)
        atomic.AddInt64(&amp;rc.stats.Hits, 1)

        return entry.Data, true</span>
}

// Has checks if a key exists in the cache (without updating access stats)
func (rc *ResultCache) Has(key string) bool <span class="cov8" title="1">{
        rc.mutex.RLock()
        entry, exists := rc.items[key]
        rc.mutex.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return !entry.IsExpired()</span>
}

// Remove removes an item from the cache
func (rc *ResultCache) Remove(key string) bool <span class="cov8" title="1">{
        rc.mutex.Lock()
        defer rc.mutex.Unlock()

        return rc.remove(key)
}</span>

// remove is the internal remove function (caller must hold mutex)
func (rc *ResultCache) remove(key string) bool <span class="cov8" title="1">{
        if entry, exists := rc.items[key]; exists </span><span class="cov8" title="1">{
                delete(rc.items, key)
                rc.stats.CurrentSize -= entry.Size
                rc.stats.Entries = int64(len(rc.items))
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// evictOne removes a single item based on the cache policy
func (rc *ResultCache) evictOne() <span class="cov8" title="1">{
        if len(rc.items) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var keyToRemove string
        var minScore float64 = float64(^uint64(0) &gt;&gt; 1) // Max float64
        var firstKey string

        // Track relevant items based on policy
        for key, entry := range rc.items </span><span class="cov8" title="1">{
                if keyToRemove == "" </span><span class="cov8" title="1">{
                        firstKey = key
                }</span>

                <span class="cov8" title="1">var score float64
                switch rc.policy </span>{
                case "LRU":<span class="cov8" title="1"> // Least Recently Used
                        score = float64(entry.LastAccess.Unix())</span>
                case "LFU":<span class="cov8" title="1"> // Least Frequently Used
                        score = float64(entry.AccessCount)</span>
                case "HYBRID":<span class="cov8" title="1"> // Hybrid LRU + LFU
                        // Combine recency and frequency: score = access_count / (1 + time_since_last_access)
                        timeSinceAccess := time.Since(entry.LastAccess).Seconds()
                        score = float64(entry.AccessCount) / (1.0 + timeSinceAccess)</span>
                case "FIFO":<span class="cov0" title="0"> // First In, First Out
                        score = float64(entry.LastAccess.Unix())</span>
                default:<span class="cov0" title="0"> // Default to LRU
                        score = float64(entry.LastAccess.Unix())</span>
                }

                <span class="cov8" title="1">if score &lt; minScore </span><span class="cov8" title="1">{
                        minScore = score
                        keyToRemove = key
                }</span>
        }

        <span class="cov8" title="1">if keyToRemove == "" </span><span class="cov0" title="0">{
                keyToRemove = firstKey
        }</span>

        <span class="cov8" title="1">if keyToRemove != "" </span><span class="cov8" title="1">{
                rc.remove(keyToRemove)
                rc.stats.Evictions++
        }</span>
}

// estimateSize provides a rough estimate of the size of data in bytes
func (rc *ResultCache) estimateSize(data interface{}) int64 <span class="cov8" title="1">{
        switch v := data.(type) </span>{
        case string:<span class="cov8" title="1">
                return int64(len(v))</span>
        case []Text:<span class="cov8" title="1">
                // Rough estimate: 100 bytes per Text element
                return int64(len(v) * 100)</span>
        case []ClassifiedBlock:<span class="cov8" title="1">
                // Rough estimate: 200 bytes per block
                return int64(len(v) * 200)</span>
        case Text:<span class="cov8" title="1">
                return int64(len(v.S) + 64)</span> // text plus metadata
        case Metadata:<span class="cov8" title="1">
                return int64(len(v.Title) + len(v.Author) + len(v.Subject) + len(v.Creator) + len(v.Producer) + len(v.Custom)*50)</span>
        case []byte:<span class="cov8" title="1">
                return int64(len(v))</span>
        default:<span class="cov8" title="1">
                // Conservative estimate for other types
                return 1024</span>
        }
}

// cleanupExpired periodically removes expired entries
func (rc *ResultCache) cleanupExpired() <span class="cov8" title="1">{
        ticker := time.NewTicker(5 * time.Minute) // Clean up every 5 minutes
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                rc.mutex.Lock()
                removed := 0

                for key, entry := range rc.items </span><span class="cov0" title="0">{
                        if entry.IsExpired() </span><span class="cov0" title="0">{
                                rc.remove(key)
                                removed++
                        }</span>
                }

                <span class="cov0" title="0">rc.mutex.Unlock()

                // Optional: log cleanup stats if needed
                if removed &gt; 0 </span>{<span class="cov0" title="0">
                        // In a real implementation, you might want to log this
                }</span>
        }
}

// GetStats returns cache statistics
func (rc *ResultCache) GetStats() CacheStats <span class="cov8" title="1">{
        rc.mutex.RLock()
        defer rc.mutex.RUnlock()

        // Create a copy of stats to avoid race conditions
        stats := rc.stats
        stats.Hits = rc.hits
        stats.Misses = rc.misses
        return stats
}</span>

// Clear removes all items from the cache
func (rc *ResultCache) Clear() <span class="cov8" title="1">{
        rc.mutex.Lock()
        defer rc.mutex.Unlock()

        rc.items = make(map[string]*CacheEntry)
        rc.stats.CurrentSize = 0
        rc.stats.Entries = 0
}</span>

// GetHitRatio returns the cache hit ratio
func (rc *ResultCache) GetHitRatio() float64 <span class="cov8" title="1">{
        rc.mutex.RLock()
        defer rc.mutex.RUnlock()

        total := rc.stats.Hits + rc.stats.Misses
        if total == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return float64(rc.stats.Hits) / float64(total)</span>
}

// CacheKeyGenerator provides functions to generate cache keys
type CacheKeyGenerator struct{}

// NewCacheKeyGenerator creates a new key generator
func NewCacheKeyGenerator() *CacheKeyGenerator <span class="cov8" title="1">{
        return &amp;CacheKeyGenerator{}
}</span>

// GeneratePageContentKey generates a cache key for page content
func (ckg *CacheKeyGenerator) GeneratePageContentKey(pageNum int, readerHash string) string <span class="cov8" title="1">{
        return fmt.Sprintf("page_content_%s_%d", readerHash, pageNum)
}</span>

// GenerateTextClassificationKey generates a cache key for text classification
func (ckg *CacheKeyGenerator) GenerateTextClassificationKey(pageNum int, readerHash string, processorParams string) string <span class="cov8" title="1">{
        return fmt.Sprintf("text_classification_%s_%d_%s", readerHash, pageNum, processorParams)
}</span>

// GenerateTextOrderingKey generates a cache key for text ordering
func (ckg *CacheKeyGenerator) GenerateTextOrderingKey(pageNum int, readerHash string, orderingParams string) string <span class="cov8" title="1">{
        return fmt.Sprintf("text_ordering_%s_%d_%s", readerHash, pageNum, orderingParams)
}</span>

// GenerateReaderHash generates a hash for the reader object (simplified)
func (ckg *CacheKeyGenerator) GenerateReaderHash(reader *Reader) string <span class="cov0" title="0">{
        // In a real implementation, you'd use a more robust method to identify the reader
        // This is just a placeholder implementation
        return fmt.Sprintf("%p", reader) // Using pointer address as a simple hash
}</span>

// GenerateFullHash generates a hash from arbitrary data
func (ckg *CacheKeyGenerator) GenerateFullHash(data string) string <span class="cov8" title="1">{
        hash := md5.Sum([]byte(data))
        return fmt.Sprintf("%x", hash)
}</span>

// CachedReader wraps a Reader to provide caching functionality
type CachedReader struct {
        *Reader
        cache        *ResultCache
        keyGenerator *CacheKeyGenerator
}

// NewCachedReader creates a new cached reader
func NewCachedReader(reader *Reader, cache *ResultCache) *CachedReader <span class="cov8" title="1">{
        return &amp;CachedReader{
                Reader:       reader,
                cache:        cache,
                keyGenerator: NewCacheKeyGenerator(),
        }
}</span>

// CachedPage returns page content with caching
func (cr *CachedReader) CachedPage(pageNum int) ([]Text, error) <span class="cov0" title="0">{
        key := cr.keyGenerator.GeneratePageContentKey(pageNum, cr.keyGenerator.GenerateReaderHash(cr.Reader))

        if cached, found := cr.cache.Get(key); found </span><span class="cov0" title="0">{
                if texts, ok := cached.([]Text); ok </span><span class="cov0" title="0">{
                        return texts, nil
                }</span>
        }

        <span class="cov0" title="0">page := cr.Reader.Page(pageNum)
        content := page.Content()

        cr.cache.Put(key, content.Text)
        return content.Text, nil</span>
}

// CachedClassifyTextBlocks returns classified text blocks with caching
func (cr *CachedReader) CachedClassifyTextBlocks(pageNum int) ([]ClassifiedBlock, error) <span class="cov0" title="0">{
        key := cr.keyGenerator.GenerateTextClassificationKey(
                pageNum,
                cr.keyGenerator.GenerateReaderHash(cr.Reader),
                "default_params", // In a real implementation, this would include actual params
        )

        if cached, found := cr.cache.Get(key); found </span><span class="cov0" title="0">{
                if blocks, ok := cached.([]ClassifiedBlock); ok </span><span class="cov0" title="0">{
                        return blocks, nil
                }</span>
        }

        <span class="cov0" title="0">page := cr.Reader.Page(pageNum)
        blocks, err := page.ClassifyTextBlocks()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cr.cache.Put(key, blocks)
        return blocks, nil</span>
}

// Global cache for the application
var globalCache *ResultCache
var globalCacheOnce sync.Once

// GetGlobalCache returns a singleton cache instance
func GetGlobalCache() *ResultCache <span class="cov8" title="1">{
        globalCacheOnce.Do(func() </span><span class="cov8" title="1">{
                // Default to 100MB max size, 1 hour TTL, LRU policy
                globalCache = NewResultCache(100*1024*1024, time.Hour, "LRU")
        }</span>)
        <span class="cov8" title="1">return globalCache</span>
}

// CacheManager provides centralized cache management
type CacheManager struct {
        pageCache           *ResultCache
        classificationCache *ResultCache
        textOrderingCache   *ResultCache
        metadataCache       *ResultCache
}

// NewCacheManager creates a new cache manager with separate caches for different data types
func NewCacheManager() *CacheManager <span class="cov8" title="1">{
        return &amp;CacheManager{
                pageCache:           NewResultCache(50*1024*1024, time.Hour, "LRU"),
                classificationCache: NewResultCache(30*1024*1024, 2*time.Hour, "LRU"),
                textOrderingCache:   NewResultCache(20*1024*1024, 30*time.Minute, "LRU"),
                metadataCache:       NewResultCache(5*1024*1024, 24*time.Hour, "FIFO"),
        }
}</span>

// GetPageCache returns the page content cache
func (cm *CacheManager) GetPageCache() *ResultCache <span class="cov8" title="1">{
        return cm.pageCache
}</span>

// GetClassificationCache returns the classification cache
func (cm *CacheManager) GetClassificationCache() *ResultCache <span class="cov8" title="1">{
        return cm.classificationCache
}</span>

// GetTextOrderingCache returns the text ordering cache
func (cm *CacheManager) GetTextOrderingCache() *ResultCache <span class="cov8" title="1">{
        return cm.textOrderingCache
}</span>

// GetMetadataCache returns the metadata cache
func (cm *CacheManager) GetMetadataCache() *ResultCache <span class="cov8" title="1">{
        return cm.metadataCache
}</span>

// GetTotalStats returns combined statistics for all caches
func (cm *CacheManager) GetTotalStats() CacheStats <span class="cov8" title="1">{
        pageStats := cm.pageCache.GetStats()
        classStats := cm.classificationCache.GetStats()
        orderStats := cm.textOrderingCache.GetStats()
        metaStats := cm.metadataCache.GetStats()

        return CacheStats{
                Hits:        pageStats.Hits + classStats.Hits + orderStats.Hits + metaStats.Hits,
                Misses:      pageStats.Misses + classStats.Misses + orderStats.Misses + metaStats.Misses,
                Evictions:   pageStats.Evictions + classStats.Evictions + orderStats.Evictions + metaStats.Evictions,
                CurrentSize: pageStats.CurrentSize + classStats.CurrentSize + orderStats.CurrentSize + metaStats.CurrentSize,
                MaxSize:     pageStats.MaxSize + classStats.MaxSize + orderStats.MaxSize + metaStats.MaxSize,
                Entries:     pageStats.Entries + classStats.Entries + orderStats.Entries + metaStats.Entries,
        }
}</span>

// CacheContext provides a context-aware cache with automatic cleanup
type CacheContext struct {
        cache  *ResultCache
        ctx    context.Context
        cancel context.CancelFunc
}

// NewCacheContext creates a new context-aware cache
func NewCacheContext(parent context.Context, cache *ResultCache) *CacheContext <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(parent)

        cc := &amp;CacheContext{
                cache:  cache,
                ctx:    ctx,
                cancel: cancel,
        }

        // Set up cleanup when context is done
        go func() </span><span class="cov8" title="1">{
                &lt;-cc.ctx.Done()
                // Perform any necessary cleanup
        }</span>()

        <span class="cov8" title="1">return cc</span>
}

// GetWithTimeout gets a value with timeout
func (cc *CacheContext) GetWithTimeout(key string, timeout time.Duration) (interface{}, bool, error) <span class="cov8" title="1">{
        done := make(chan struct{})
        var result interface{}
        var found bool

        // Launch the get operation in a goroutine
        go func() </span><span class="cov8" title="1">{
                defer close(done)
                result, found = cc.cache.Get(key)
        }</span>()

        // Wait for either the operation to complete or timeout
        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1">
                return result, found, nil</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return nil, false, context.DeadlineExceeded</span>
        case &lt;-cc.ctx.Done():<span class="cov0" title="0">
                return nil, false, cc.ctx.Err()</span>
        }
}

// Close releases resources used by the cache context
func (cc *CacheContext) Close() <span class="cov8" title="1">{
        cc.cancel()
}</span>

// ConnectionPool manages a pool of connections/resources
type ConnectionPool struct {
        pool    chan interface{}
        new     func() interface{}
        close   func(interface{})
        maxSize int
        mu      sync.Mutex
}

// NewConnectionPool creates a new connection pool
func NewConnectionPool(maxSize int, newFunc func() interface{}, closeFunc func(interface{})) *ConnectionPool <span class="cov8" title="1">{
        return &amp;ConnectionPool{
                pool:    make(chan interface{}, maxSize),
                new:     newFunc,
                close:   closeFunc,
                maxSize: maxSize,
        }
}</span>

// Get retrieves a connection from the pool
func (cp *ConnectionPool) Get() interface{} <span class="cov8" title="1">{
        select </span>{
        case conn := &lt;-cp.pool:<span class="cov0" title="0">
                return conn</span>
        default:<span class="cov8" title="1">
                return cp.new()</span>
        }
}

// Put returns a connection to the pool
func (cp *ConnectionPool) Put(conn interface{}) <span class="cov8" title="1">{
        select </span>{
        case cp.pool &lt;- conn:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                // Pool is full, close the connection
                if cp.close != nil </span><span class="cov8" title="1">{
                        cp.close(conn)
                }</span>
        }
}

// Close closes all connections in the pool
func (cp *ConnectionPool) Close() <span class="cov8" title="1">{
        cp.mu.Lock()
        defer cp.mu.Unlock()

        close(cp.pool)
        for conn := range cp.pool </span><span class="cov8" title="1">{
                if cp.close != nil </span><span class="cov8" title="1">{
                        cp.close(conn)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "context"
        "runtime"
        "sync"
        "sync/atomic"
)

// EnhancedParallelProcessor 
// 
type EnhancedParallelProcessor struct {
        workerPool     *WorkerPool
        batchSize      int
        enablePrefetch bool
}

// WorkerPool 
type WorkerPool struct {
        workers    int
        semaphore  chan struct{}
        activeJobs int64
        totalJobs  int64
}

// NewEnhancedParallelProcessor 
func NewEnhancedParallelProcessor(workers int, batchSize int) *EnhancedParallelProcessor <span class="cov8" title="1">{
        if workers &lt;= 0 </span><span class="cov0" title="0">{
                workers = runtime.NumCPU()
        }</span>
        <span class="cov8" title="1">if batchSize &lt;= 0 </span><span class="cov0" title="0">{
                batchSize = 10
        }</span>

        <span class="cov8" title="1">return &amp;EnhancedParallelProcessor{
                workerPool: &amp;WorkerPool{
                        workers:   workers,
                        semaphore: make(chan struct{}, workers),
                },
                batchSize:      batchSize,
                enablePrefetch: true,
        }</span>
}

// ProcessPagesEnhanced 
func (epp *EnhancedParallelProcessor) ProcessPagesEnhanced(
        ctx context.Context,
        pages []Page,
        processorFunc func(Page) ([]Text, error),
) ([][]Text, error) <span class="cov8" title="1">{
        if len(pages) == 0 </span><span class="cov8" title="1">{
                return [][]Text{}, nil
        }</span>

        // 
        <span class="cov8" title="1">numBatches := (len(pages) + epp.batchSize - 1) / epp.batchSize
        results := make([][]Text, len(pages))
        var processingErr error
        var errOnce sync.Once

        var wg sync.WaitGroup

        for batchIdx := 0; batchIdx &lt; numBatches; batchIdx++ </span><span class="cov8" title="1">{
                start := batchIdx * epp.batchSize
                end := start + epp.batchSize
                if end &gt; len(pages) </span><span class="cov0" title="0">{
                        end = len(pages)
                }</span>

                <span class="cov8" title="1">wg.Add(1)
                go func(bStart, bEnd int) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        // 
                        select </span>{
                        case epp.workerPool.semaphore &lt;- struct{}{}:<span class="cov8" title="1">
                                defer func() </span><span class="cov8" title="1">{ &lt;-epp.workerPool.semaphore }</span>()
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                errOnce.Do(func() </span><span class="cov0" title="0">{ processingErr = ctx.Err() }</span>)
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov8" title="1">atomic.AddInt64(&amp;epp.workerPool.activeJobs, 1)
                        defer atomic.AddInt64(&amp;epp.workerPool.activeJobs, -1)

                        // 
                        for i := bStart; i &lt; bEnd; i++ </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov8" title="1">
                                        errOnce.Do(func() </span><span class="cov8" title="1">{ processingErr = ctx.Err() }</span>)
                                        <span class="cov8" title="1">return</span>
                                default:<span class="cov0" title="0"></span>
                                }

                                <span class="cov0" title="0">texts, err := processorFunc(pages[i])
                                if err != nil </span><span class="cov0" title="0">{
                                        errOnce.Do(func() </span><span class="cov0" title="0">{ processingErr = err }</span>)
                                        <span class="cov0" title="0">return</span>
                                }
                                <span class="cov0" title="0">results[i] = texts
                                atomic.AddInt64(&amp;epp.workerPool.totalJobs, 1)</span>
                        }
                }(start, end)
        }

        <span class="cov8" title="1">wg.Wait()

        if processingErr != nil </span><span class="cov8" title="1">{
                return nil, processingErr
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// ProcessWithLoadBalancing 
func (epp *EnhancedParallelProcessor) ProcessWithLoadBalancing(
        ctx context.Context,
        pages []Page,
        processorFunc func(Page) ([]Text, error),
) ([][]Text, error) <span class="cov0" title="0">{
        if len(pages) == 0 </span><span class="cov0" title="0">{
                return [][]Text{}, nil
        }</span>

        <span class="cov0" title="0">numWorkers := epp.workerPool.workers
        if numWorkers &gt; len(pages) </span><span class="cov0" title="0">{
                numWorkers = len(pages)
        }</span>

        // 
        <span class="cov0" title="0">type job struct {
                index int
                page  Page
        }

        type result struct {
                index int
                texts []Text
                err   error
        }

        jobChan := make(chan job, numWorkers*2) // 
        resultChan := make(chan result, len(pages))

        // 
        var wg sync.WaitGroup
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(workerID int) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        for j := range jobChan </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        resultChan &lt;- result{index: j.index, err: ctx.Err()}
                                        return</span>
                                default:<span class="cov0" title="0"></span>
                                }

                                <span class="cov0" title="0">texts, err := processorFunc(j.page)
                                resultChan &lt;- result{
                                        index: j.index,
                                        texts: texts,
                                        err:   err,
                                }</span>
                        }
                }(i)
        }

        // 
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer close(jobChan)
                for i, page := range pages </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case jobChan &lt;- job{index: i, page: page}:<span class="cov0" title="0"></span>
                        }
                }
        }()

        // 
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(resultChan)
        }</span>()

        // 
        <span class="cov0" title="0">results := make([][]Text, len(pages))
        var firstErr error
        for res := range resultChan </span><span class="cov0" title="0">{
                if res.err != nil &amp;&amp; firstErr == nil </span><span class="cov0" title="0">{
                        firstErr = res.err
                }</span>
                <span class="cov0" title="0">results[res.index] = res.texts</span>
        }

        <span class="cov0" title="0">if firstErr != nil </span><span class="cov0" title="0">{
                return nil, firstErr
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// ProcessWithPipeline 
func (epp *EnhancedParallelProcessor) ProcessWithPipeline(
        ctx context.Context,
        pages []Page,
        stages []func(Page, []Text) ([]Text, error),
) ([][]Text, error) <span class="cov0" title="0">{
        if len(pages) == 0 || len(stages) == 0 </span><span class="cov0" title="0">{
                return [][]Text{}, nil
        }</span>

        // 
        <span class="cov0" title="0">currentResults := make([][]Text, len(pages))
        var wg sync.WaitGroup
        var mu sync.Mutex
        var pipelineErr error

        // 
        semaphore := make(chan struct{}, epp.workerPool.workers)

        for i, page := range pages </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(idx int, p Page) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        select </span>{
                        case semaphore &lt;- struct{}{}:<span class="cov0" title="0">
                                defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>()
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                mu.Lock()
                                if pipelineErr == nil </span><span class="cov0" title="0">{
                                        pipelineErr = ctx.Err()
                                }</span>
                                <span class="cov0" title="0">mu.Unlock()
                                return</span>
                        }

                        // 
                        <span class="cov0" title="0">var texts []Text
                        var err error

                        // 
                        for _, stage := range stages </span><span class="cov0" title="0">{
                                texts, err = stage(p, texts)
                                if err != nil </span><span class="cov0" title="0">{
                                        mu.Lock()
                                        if pipelineErr == nil </span><span class="cov0" title="0">{
                                                pipelineErr = err
                                        }</span>
                                        <span class="cov0" title="0">mu.Unlock()
                                        return</span>
                                }
                        }

                        <span class="cov0" title="0">mu.Lock()
                        currentResults[idx] = texts
                        mu.Unlock()</span>
                }(i, page)
        }

        <span class="cov0" title="0">wg.Wait()

        if pipelineErr != nil </span><span class="cov0" title="0">{
                return nil, pipelineErr
        }</span>

        <span class="cov0" title="0">return currentResults, nil</span>
}

// AdaptiveProcessor 
// 
type AdaptiveProcessor struct {
        minWorkers     int
        maxWorkers     int
        currentWorkers atomic.Int32
        loadThreshold  float64
}

// NewAdaptiveProcessor 
func NewAdaptiveProcessor(min, max int) *AdaptiveProcessor <span class="cov0" title="0">{
        if min &lt;= 0 </span><span class="cov0" title="0">{
                min = 1
        }</span>
        <span class="cov0" title="0">if max &lt;= 0 || max &lt; min </span><span class="cov0" title="0">{
                max = runtime.NumCPU()
        }</span>

        <span class="cov0" title="0">ap := &amp;AdaptiveProcessor{
                minWorkers:    min,
                maxWorkers:    max,
                loadThreshold: 0.8,
        }
        ap.currentWorkers.Store(int32(min))

        return ap</span>
}

// AdjustWorkers 
func (ap *AdaptiveProcessor) AdjustWorkers() <span class="cov0" title="0">{
        var ms runtime.MemStats
        runtime.ReadMemStats(&amp;ms)

        //  GC 
        current := ap.currentWorkers.Load()

        // 
        if ms.NumGC &gt; 0 </span><span class="cov0" title="0">{
                if current &gt; int32(ap.minWorkers) </span><span class="cov0" title="0">{
                        ap.currentWorkers.Store(current - 1)
                }</span>
        } else<span class="cov0" title="0"> if current &lt; int32(ap.maxWorkers) </span><span class="cov0" title="0">{
                // 
                ap.currentWorkers.Store(current + 1)
        }</span>
}

// GetWorkerCount 
func (ap *AdaptiveProcessor) GetWorkerCount() int <span class="cov0" title="0">{
        return int(ap.currentWorkers.Load())
}</span>

// ProcessAdaptive 
func (ap *AdaptiveProcessor) ProcessAdaptive(
        ctx context.Context,
        pages []Page,
        processorFunc func(Page) ([]Text, error),
) ([][]Text, error) <span class="cov0" title="0">{
        // 
        ap.AdjustWorkers()

        epp := NewEnhancedParallelProcessor(ap.GetWorkerCount(), 10)
        return epp.ProcessPagesEnhanced(ctx, pages, processorFunc)
}</span>

// GetStats 
func (wp *WorkerPool) GetStats() WorkerPoolStats <span class="cov0" title="0">{
        return WorkerPoolStats{
                Workers:    wp.workers,
                ActiveJobs: atomic.LoadInt64(&amp;wp.activeJobs),
                TotalJobs:  atomic.LoadInt64(&amp;wp.totalJobs),
        }
}</span>

// WorkerPoolStats 
type WorkerPoolStats struct {
        Workers    int
        ActiveJobs int64
        TotalJobs  int64
}

// ParallelExtractor 
// 
type ParallelExtractor struct {
        processor  *EnhancedParallelProcessor
        cache      *ShardedCache
        prefetcher *FontPrefetcher
}

// NewParallelExtractor 
func NewParallelExtractor(workers int) *ParallelExtractor <span class="cov8" title="1">{
        return &amp;ParallelExtractor{
                processor:  NewEnhancedParallelProcessor(workers, 10),
                cache:      NewShardedCache(10000, 0),
                prefetcher: NewFontPrefetcher(NewOptimizedFontCache(1000)),
        }
}</span>

// ExtractAllPages 
func (pe *ParallelExtractor) ExtractAllPages(
        ctx context.Context,
        pages []Page,
) ([][]Text, error) <span class="cov8" title="1">{
        return pe.processor.ProcessPagesEnhanced(ctx, pages, func(page Page) ([]Text, error) </span><span class="cov0" title="0">{
                // 
                content := page.Content()
                return content.Text, nil
        }</span>)
}

// GetCacheStats 
func (pe *ParallelExtractor) GetCacheStats() ShardedCacheStats <span class="cov8" title="1">{
        return pe.cache.GetStats()
}</span>

// GetPrefetchStats 
func (pe *ParallelExtractor) GetPrefetchStats() PrefetchStats <span class="cov8" title="1">{
        return pe.prefetcher.GetStats()
}</span>

// Close 
func (pe *ParallelExtractor) Close() <span class="cov8" title="1">{
        pe.prefetcher.Close()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "errors"
        "fmt"
)

// PDFError represents an error that occurred during PDF processing.
// It includes contextual information about where the error occurred.
type PDFError struct {
        Op   string // Operation that failed (e.g., "extract text", "parse font")
        Page int    // Page number where error occurred (0 if not page-specific)
        Path string // File path if applicable
        Err  error  // Underlying error
}

func (e *PDFError) Error() string <span class="cov8" title="1">{
        if e.Page &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("pdf: %s on page %d: %v", e.Op, e.Page, e.Err)
        }</span>
        <span class="cov0" title="0">if e.Path != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("pdf: %s (%s): %v", e.Op, e.Path, e.Err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("pdf: %s: %v", e.Op, e.Err)</span>
}

func (e *PDFError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// Common errors
var (
        // ErrInvalidFont indicates a font definition is malformed or unsupported
        ErrInvalidFont = errors.New("invalid or unsupported font")

        // ErrUnsupportedEncoding indicates the character encoding is not supported
        ErrUnsupportedEncoding = errors.New("unsupported character encoding")

        // ErrMalformedStream indicates a content stream is malformed
        ErrMalformedStream = errors.New("malformed content stream")

        // ErrInvalidPage indicates an invalid page number or corrupted page
        ErrInvalidPage = errors.New("invalid page")

        // ErrEncrypted indicates the PDF is encrypted and cannot be read without a password
        ErrEncrypted = errors.New("PDF is encrypted")

        // ErrCorrupted indicates the PDF file structure is corrupted
        ErrCorrupted = errors.New("PDF file is corrupted")

        // ErrUnsupportedVersion indicates the PDF version is not supported
        ErrUnsupportedVersion = errors.New("unsupported PDF version")

        // ErrNoContent indicates the page has no content
        ErrNoContent = errors.New("page has no content")
)

// wrapError wraps an error with operation context
func wrapError(op string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;PDFError{Op: op, Err: err}</span>
}

// wrapPageError wraps an error with page-specific context
func wrapPageError(op string, page int, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;PDFError{Op: op, Page: page, Err: err}</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "context"
        "io"
        "runtime"
        "sync"
)

// ExtractOptions configures text extraction behavior
type ExtractOptions struct {
        Workers   int   // Number of concurrent workers (0 = use NumCPU)
        PageRange []int // Specific pages to extract (nil = all pages)
}

// ExtractWithContext extracts plain text from all pages with cancellation support
func (r *Reader) ExtractWithContext(ctx context.Context, opts ExtractOptions) (io.Reader, error) <span class="cov0" title="0">{
        pages := r.NumPage()
        if pages == 0 </span><span class="cov0" title="0">{
                return emptyReader(), nil
        }</span>

        <span class="cov0" title="0">workers := opts.Workers
        if workers &lt;= 0 </span><span class="cov0" title="0">{
                workers = runtime.NumCPU()
        }</span>
        <span class="cov0" title="0">if workers &gt; pages </span><span class="cov0" title="0">{
                workers = pages
        }</span>

        // Determine which pages to extract
        <span class="cov0" title="0">pageList := opts.PageRange
        if pageList == nil </span><span class="cov0" title="0">{
                pageList = make([]int, pages)
                for i := 0; i &lt; pages; i++ </span><span class="cov0" title="0">{
                        pageList[i] = i + 1
                }</span>
        }

        <span class="cov0" title="0">results := make([]string, len(pageList))
        jobs := make(chan int, len(pageList))
        errCh := make(chan error, 1)

        var wg sync.WaitGroup
        worker := func() </span><span class="cov0" title="0">{
                defer wg.Done()
                for idx := range jobs </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">pageNum := pageList[idx]
                        text, err := r.Page(pageNum).GetPlainText(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                select </span>{
                                case errCh &lt;- wrapPageError("extract text", pageNum, err):<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                }
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov0" title="0">results[idx] = text</span>
                }
        }

        <span class="cov0" title="0">wg.Add(workers)
        for i := 0; i &lt; workers; i++ </span><span class="cov0" title="0">{
                go worker()
        }</span>

        // Send jobs
        <span class="cov0" title="0">for i := range pageList </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        close(jobs)
                        return nil, ctx.Err()</span>
                case jobs &lt;- i:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov0" title="0">close(jobs)

        // Wait for completion
        wg.Wait()

        // Check for errors
        select </span>{
        case err := &lt;-errCh:<span class="cov0" title="0">
                return nil, err</span>
        default:<span class="cov0" title="0"></span>
        }

        // Combine results
        <span class="cov0" title="0">var buf writeBuffer
        for _, text := range results </span><span class="cov0" title="0">{
                buf.WriteString(text)
        }</span>
        <span class="cov0" title="0">return &amp;buf, nil</span>
}

// writeBuffer is a simple io.Reader wrapper around strings
type writeBuffer struct {
        data   []string
        offset int
        pos    int
}

func (b *writeBuffer) WriteString(s string) <span class="cov8" title="1">{
        b.data = append(b.data, s)
}</span>

func (b *writeBuffer) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        for b.offset &lt; len(b.data) </span><span class="cov8" title="1">{
                s := b.data[b.offset]
                copied := copy(p[n:], s[b.pos:])
                n += copied
                b.pos += copied

                if b.pos &gt;= len(s) </span><span class="cov8" title="1">{
                        b.offset++
                        b.pos = 0
                }</span>

                <span class="cov8" title="1">if n &gt;= len(p) </span><span class="cov8" title="1">{
                        return n, nil
                }</span>
        }

        <span class="cov8" title="1">if n == 0 </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

func emptyReader() io.Reader <span class="cov8" title="1">{
        return &amp;writeBuffer{}
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "context"
        "io"
        "runtime"
)

// ExtractMode specifies the type of extraction to perform
type ExtractMode int

const (
        ModePlain      ExtractMode = iota // Plain text extraction
        ModeStyled                        // Text with style information
        ModeStructured                    // Structured text with classification
)

// ExtractResult contains the results of text extraction
type ExtractResult struct {
        Text             string            // Plain text (for ModePlain)
        StyledTexts      []Text            // Styled texts (for ModeStyled)
        ClassifiedBlocks []ClassifiedBlock // Classified blocks (for ModeStructured)
        Metadata         Metadata          // Document metadata
        PageCount        int               // Total number of pages
}

// Extractor provides a builder pattern for configuring and executing extraction
type Extractor struct {
        reader        *Reader
        mode          ExtractMode
        workers       int
        pageRange     []int
        smartOrdering bool
        ctx           context.Context
}

// NewExtractor creates a new extractor for the given reader
func NewExtractor(r *Reader) *Extractor <span class="cov0" title="0">{
        return &amp;Extractor{
                reader:        r,
                mode:          ModePlain,
                workers:       runtime.NumCPU(),
                smartOrdering: false,
                ctx:           context.Background(),
        }
}</span>

// Mode sets the extraction mode
func (e *Extractor) Mode(mode ExtractMode) *Extractor <span class="cov0" title="0">{
        e.mode = mode
        return e
}</span>

// Workers sets the number of concurrent workers
func (e *Extractor) Workers(n int) *Extractor <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                n = runtime.NumCPU()
        }</span>
        <span class="cov0" title="0">e.workers = n
        return e</span>
}

// Pages sets specific pages to extract (1-indexed)
func (e *Extractor) Pages(pages ...int) *Extractor <span class="cov0" title="0">{
        e.pageRange = pages
        return e
}</span>

// SmartOrdering enables smart text ordering for multi-column layouts
func (e *Extractor) SmartOrdering(enabled bool) *Extractor <span class="cov0" title="0">{
        e.smartOrdering = enabled
        return e
}</span>

// Context sets the context for cancellation
func (e *Extractor) Context(ctx context.Context) *Extractor <span class="cov0" title="0">{
        e.ctx = ctx
        return e
}</span>

// Extract performs the extraction and returns the result
func (e *Extractor) Extract() (*ExtractResult, error) <span class="cov0" title="0">{
        result := &amp;ExtractResult{
                PageCount: e.reader.NumPage(),
        }

        // Extract metadata
        meta, err := e.reader.GetMetadata()
        if err != nil </span><span class="cov0" title="0">{
                // Metadata extraction failure shouldn't block text extraction
                if DebugOn </span><span class="cov0" title="0">{
                        println("failed to extract metadata:", err.Error())
                }</span>
        }
        <span class="cov0" title="0">result.Metadata = meta

        // Determine which pages to extract
        pages := e.getPageNumbers()

        switch e.mode </span>{
        case ModePlain:<span class="cov0" title="0">
                text, err := e.extractPlainText(pages)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.Text = text</span>

        case ModeStyled:<span class="cov0" title="0">
                texts, err := e.extractStyledTexts(pages)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.StyledTexts = texts</span>

        case ModeStructured:<span class="cov0" title="0">
                blocks, err := e.extractStructuredText(pages)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.ClassifiedBlocks = blocks</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// ExtractText is a convenience method for extracting plain text
func (e *Extractor) ExtractText() (string, error) <span class="cov0" title="0">{
        e.mode = ModePlain
        result, err := e.Extract()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return result.Text, nil</span>
}

// ExtractStyledTexts is a convenience method for extracting styled texts
func (e *Extractor) ExtractStyledTexts() ([]Text, error) <span class="cov0" title="0">{
        e.mode = ModeStyled
        result, err := e.Extract()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result.StyledTexts, nil</span>
}

// ExtractStructured is a convenience method for extracting structured text
func (e *Extractor) ExtractStructured() ([]ClassifiedBlock, error) <span class="cov0" title="0">{
        e.mode = ModeStructured
        result, err := e.Extract()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result.ClassifiedBlocks, nil</span>
}

// getPageNumbers returns the list of page numbers to extract
func (e *Extractor) getPageNumbers() []int <span class="cov0" title="0">{
        if len(e.pageRange) &gt; 0 </span><span class="cov0" title="0">{
                return e.pageRange
        }</span>

        // Extract all pages
        <span class="cov0" title="0">pages := make([]int, e.reader.NumPage())
        for i := range pages </span><span class="cov0" title="0">{
                pages[i] = i + 1
        }</span>
        <span class="cov0" title="0">return pages</span>
}

// extractPlainText extracts plain text from specified pages
func (e *Extractor) extractPlainText(pages []int) (string, error) <span class="cov0" title="0">{
        if e.workers == 1 || len(pages) == 1 </span><span class="cov0" title="0">{
                // Single-threaded extraction
                return e.extractPlainTextSequential(pages)
        }</span>

        // Use concurrent extraction with context
        <span class="cov0" title="0">opts := ExtractOptions{
                Workers:   e.workers,
                PageRange: pages,
        }

        reader, err := e.reader.ExtractWithContext(e.ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">data, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(data), nil</span>
}

// extractPlainTextSequential extracts text sequentially
func (e *Extractor) extractPlainTextSequential(pages []int) (string, error) <span class="cov0" title="0">{
        //  StringBuffer 
        // : 2KB
        builder := NewStringBuffer(len(pages) * 2048)

        for i, pageNum := range pages </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        return builder.String(), e.ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">page := e.reader.Page(pageNum)
                var text string
                var err error

                if e.smartOrdering </span><span class="cov0" title="0">{
                        text, err = page.GetPlainTextWithSmartOrdering(nil)
                }</span> else<span class="cov0" title="0"> {
                        text, err = page.GetPlainText(nil)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return "", &amp;PDFError{
                                Op:   "extract text",
                                Page: pageNum,
                                Err:  err,
                        }
                }</span>

                <span class="cov0" title="0">builder.WriteString(text)
                if i &lt; len(pages)-1 </span><span class="cov0" title="0">{
                        builder.WriteByte('\n')
                }</span>
        }

        //  StringCopy  builder 
        <span class="cov0" title="0">return builder.StringCopy(), nil</span>
}

// extractStyledTexts extracts styled texts from specified pages
func (e *Extractor) extractStyledTexts(pages []int) ([]Text, error) <span class="cov0" title="0">{
        var allTexts []Text

        for _, pageNum := range pages </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        return allTexts, e.ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">page := e.reader.Page(pageNum)
                content := page.Content()

                allTexts = append(allTexts, content.Text...)</span>
        }

        <span class="cov0" title="0">return allTexts, nil</span>
}

// extractStructuredText extracts and classifies text from specified pages
func (e *Extractor) extractStructuredText(pages []int) ([]ClassifiedBlock, error) <span class="cov0" title="0">{
        var allBlocks []ClassifiedBlock

        for _, pageNum := range pages </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        return allBlocks, e.ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">page := e.reader.Page(pageNum)
                blocks, err := page.ClassifyTextBlocks()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;PDFError{
                                Op:   "classify text blocks",
                                Page: pageNum,
                                Err:  err,
                        }
                }</span>

                <span class="cov0" title="0">allBlocks = append(allBlocks, blocks...)</span>
        }

        <span class="cov0" title="0">return allBlocks, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "crypto/sha256"
        "encoding/hex"
        "sync"
        "time"
)

// GlobalFontCache implements an enhanced global font cache with:
// - LRU eviction for memory control
// - Hit/miss statistics for monitoring
// - Content-based hashing for accurate cache keys
type GlobalFontCache struct {
        mu sync.RWMutex

        // Main cache storage
        fonts map[string]*cachedFont

        // LRU tracking
        accessList *fontAccessList

        // Configuration
        maxEntries int
        maxAge     time.Duration

        // Statistics
        hits   uint64
        misses uint64
}

// cachedFont wraps a Font with metadata
type cachedFont struct {
        font        *Font
        key         string
        hash        string
        lastAccess  time.Time
        accessCount uint64
}

// fontAccessList implements a simple LRU list
type fontAccessList struct {
        mu    sync.Mutex
        items []*string      // keys in access order (oldest first)
        index map[string]int // key -&gt; index in items
}

// newFontAccessList creates a new access list
func newFontAccessList() *fontAccessList <span class="cov8" title="1">{
        return &amp;fontAccessList{
                items: make([]*string, 0, 1000),
                index: make(map[string]int),
        }
}</span>

// touch marks a key as recently accessed
func (fal *fontAccessList) touch(key string) <span class="cov8" title="1">{
        fal.mu.Lock()
        defer fal.mu.Unlock()

        // Remove from current position
        if idx, ok := fal.index[key]; ok </span><span class="cov8" title="1">{
                // Move to end (most recent)
                fal.items = append(fal.items[:idx], fal.items[idx+1:]...)

                // Update indices
                delete(fal.index, key)
                for i := idx; i &lt; len(fal.items); i++ </span><span class="cov8" title="1">{
                        fal.index[*fal.items[i]] = i
                }</span>
        }

        // Add to end
        <span class="cov8" title="1">keyCopy := key
        fal.items = append(fal.items, &amp;keyCopy)
        fal.index[key] = len(fal.items) - 1</span>
}

// oldest returns the oldest key (for eviction)
func (fal *fontAccessList) oldest() (string, bool) <span class="cov8" title="1">{
        fal.mu.Lock()
        defer fal.mu.Unlock()

        if len(fal.items) == 0 </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov8" title="1">return *fal.items[0], true</span>
}

// remove removes a key from tracking
func (fal *fontAccessList) remove(key string) <span class="cov8" title="1">{
        fal.mu.Lock()
        defer fal.mu.Unlock()

        if idx, ok := fal.index[key]; ok </span><span class="cov8" title="1">{
                fal.items = append(fal.items[:idx], fal.items[idx+1:]...)
                delete(fal.index, key)

                // Update indices
                for i := idx; i &lt; len(fal.items); i++ </span><span class="cov8" title="1">{
                        fal.index[*fal.items[i]] = i
                }</span>
        }
}

// Global font cache instance
var (
        globalEnhancedFontCache     *GlobalFontCache
        globalEnhancedFontCacheOnce sync.Once
)

// GetGlobalFontCache returns the global font cache instance
func GetGlobalFontCache() *GlobalFontCache <span class="cov8" title="1">{
        globalEnhancedFontCacheOnce.Do(func() </span><span class="cov8" title="1">{
                globalEnhancedFontCache = NewGlobalFontCache(1000, 1*time.Hour)
        }</span>)
        <span class="cov8" title="1">return globalEnhancedFontCache</span>
}

// NewGlobalFontCache creates a new global font cache
func NewGlobalFontCache(maxEntries int, maxAge time.Duration) *GlobalFontCache <span class="cov8" title="1">{
        if maxEntries &lt;= 0 </span><span class="cov0" title="0">{
                maxEntries = 1000
        }</span>
        <span class="cov8" title="1">if maxAge &lt;= 0 </span><span class="cov8" title="1">{
                maxAge = 1 * time.Hour
        }</span>

        <span class="cov8" title="1">return &amp;GlobalFontCache{
                fonts:      make(map[string]*cachedFont),
                accessList: newFontAccessList(),
                maxEntries: maxEntries,
                maxAge:     maxAge,
        }</span>
}

// computeFontHash computes a content-based hash for a font
func computeFontHash(f *Font) string <span class="cov8" title="1">{
        if f == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Hash based on font properties that define uniqueness
        <span class="cov8" title="1">hasher := sha256.New()

        // Include base font name
        hasher.Write([]byte(f.BaseFont()))

        // Include subtype
        hasher.Write([]byte(f.subtype()))

        // Include first/last char
        hasher.Write([]byte{byte(f.FirstChar()), byte(f.LastChar())})

        // Include a sample of widths (first 10)
        widths := f.Widths()
        sampleSize := 10
        if len(widths) &lt; sampleSize </span><span class="cov8" title="1">{
                sampleSize = len(widths)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; sampleSize; i++ </span><span class="cov0" title="0">{
                // Convert float to bytes
                w := widths[i]
                bytes := [8]byte{}
                for j := 0; j &lt; 8; j++ </span><span class="cov0" title="0">{
                        bytes[j] = byte(uint64(w*1000) &gt;&gt; (j * 8))
                }</span>
                <span class="cov0" title="0">hasher.Write(bytes[:])</span>
        }

        <span class="cov8" title="1">return hex.EncodeToString(hasher.Sum(nil))</span>
}

// Get retrieves a font from the cache
func (gfc *GlobalFontCache) Get(key string) (*Font, bool) <span class="cov8" title="1">{
        gfc.mu.RLock()
        cached, ok := gfc.fonts[key]
        gfc.mu.RUnlock()

        if !ok </span><span class="cov8" title="1">{
                gfc.mu.Lock()
                gfc.misses++
                gfc.mu.Unlock()
                return nil, false
        }</span>

        // Check age
        <span class="cov8" title="1">if time.Since(cached.lastAccess) &gt; gfc.maxAge </span><span class="cov8" title="1">{
                // Too old, remove it
                gfc.Remove(key)
                gfc.mu.Lock()
                gfc.misses++
                gfc.mu.Unlock()
                return nil, false
        }</span>

        // Update access info
        <span class="cov8" title="1">gfc.mu.Lock()
        cached.lastAccess = time.Now()
        cached.accessCount++
        gfc.hits++
        gfc.mu.Unlock()

        // Update LRU
        gfc.accessList.touch(key)

        return cached.font, true</span>
}

// Set stores a font in the cache
func (gfc *GlobalFontCache) Set(key string, font *Font) <span class="cov8" title="1">{
        if font == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">hash := computeFontHash(font)

        gfc.mu.Lock()
        defer gfc.mu.Unlock()

        // Check if already exists
        if _, ok := gfc.fonts[key]; ok </span><span class="cov0" title="0">{
                // Update existing
                gfc.fonts[key].font = font
                gfc.fonts[key].hash = hash
                gfc.fonts[key].lastAccess = time.Now()
                gfc.fonts[key].accessCount++
                gfc.accessList.touch(key)
                return
        }</span>

        // Evict if at capacity
        <span class="cov8" title="1">if len(gfc.fonts) &gt;= gfc.maxEntries </span><span class="cov8" title="1">{
                gfc.evictOldest()
        }</span>

        // Add new entry
        <span class="cov8" title="1">gfc.fonts[key] = &amp;cachedFont{
                font:        font,
                key:         key,
                hash:        hash,
                lastAccess:  time.Now(),
                accessCount: 1,
        }

        gfc.accessList.touch(key)</span>
}

// evictOldest removes the least recently used font
// Caller must hold write lock
func (gfc *GlobalFontCache) evictOldest() <span class="cov8" title="1">{
        oldestKey, ok := gfc.accessList.oldest()
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">delete(gfc.fonts, oldestKey)
        gfc.accessList.remove(oldestKey)</span>
}

// Remove removes a font from the cache
func (gfc *GlobalFontCache) Remove(key string) <span class="cov8" title="1">{
        gfc.mu.Lock()
        defer gfc.mu.Unlock()

        delete(gfc.fonts, key)
        gfc.accessList.remove(key)
}</span>

// Clear removes all fonts from the cache
func (gfc *GlobalFontCache) Clear() <span class="cov8" title="1">{
        gfc.mu.Lock()
        defer gfc.mu.Unlock()

        gfc.fonts = make(map[string]*cachedFont)
        gfc.accessList = newFontAccessList()
}</span>

// Stats returns cache statistics
type FontCacheStats struct {
        Entries     int
        MaxEntries  int
        Hits        uint64
        Misses      uint64
        HitRate     float64
        AvgAccesses float64
}

// GetStats returns current cache statistics
func (gfc *GlobalFontCache) GetStats() FontCacheStats <span class="cov8" title="1">{
        gfc.mu.RLock()
        defer gfc.mu.RUnlock()

        total := gfc.hits + gfc.misses
        hitRate := 0.0
        if total &gt; 0 </span><span class="cov8" title="1">{
                hitRate = float64(gfc.hits) / float64(total)
        }</span>

        // Calculate average accesses
        <span class="cov8" title="1">totalAccesses := uint64(0)
        for _, cached := range gfc.fonts </span><span class="cov8" title="1">{
                totalAccesses += cached.accessCount
        }</span>
        <span class="cov8" title="1">avgAccesses := 0.0
        if len(gfc.fonts) &gt; 0 </span><span class="cov8" title="1">{
                avgAccesses = float64(totalAccesses) / float64(len(gfc.fonts))
        }</span>

        <span class="cov8" title="1">return FontCacheStats{
                Entries:     len(gfc.fonts),
                MaxEntries:  gfc.maxEntries,
                Hits:        gfc.hits,
                Misses:      gfc.misses,
                HitRate:     hitRate,
                AvgAccesses: avgAccesses,
        }</span>
}

// Cleanup removes expired entries
func (gfc *GlobalFontCache) Cleanup() int <span class="cov8" title="1">{
        gfc.mu.Lock()
        defer gfc.mu.Unlock()

        now := time.Now()
        removed := 0

        keysToRemove := make([]string, 0)
        for key, cached := range gfc.fonts </span><span class="cov8" title="1">{
                if now.Sub(cached.lastAccess) &gt; gfc.maxAge </span><span class="cov8" title="1">{
                        keysToRemove = append(keysToRemove, key)
                }</span>
        }

        <span class="cov8" title="1">for _, key := range keysToRemove </span><span class="cov8" title="1">{
                delete(gfc.fonts, key)
                gfc.accessList.remove(key)
                removed++
        }</span>

        <span class="cov8" title="1">return removed</span>
}

// StartCleanupRoutine starts a background goroutine to periodically clean up expired entries
func (gfc *GlobalFontCache) StartCleanupRoutine(interval time.Duration) chan struct{} <span class="cov0" title="0">{
        stop := make(chan struct{})

        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(interval)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                gfc.Cleanup()</span>
                        case &lt;-stop:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return stop</span>
}

// GetOrCompute retrieves a font from cache or computes it if not present
// This is a convenience function that combines Get and Set
func (gfc *GlobalFontCache) GetOrCompute(key string, compute func() (*Font, error)) (*Font, error) <span class="cov0" title="0">{
        // Try to get from cache first
        if font, ok := gfc.Get(key); ok </span><span class="cov0" title="0">{
                return font, nil
        }</span>

        // Compute the font
        <span class="cov0" title="0">font, err := compute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in cache
        <span class="cov0" title="0">gfc.Set(key, font)

        return font, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "sync"
        "sync/atomic"
        "time"
        "unsafe"
)

// OptimizedFontCache implements an ultra-high-performance font cache with:
// - Lock-free read path using atomic operations
// - Sharded design to reduce lock contention (16 shards)
// - Zero-allocation fast path for cache hits
// - Inline LRU using lock-free linked list approximation
// - Pre-allocated pools for metadata structs
// - SIMD-friendly memory layout
type OptimizedFontCache struct {
        shards [16]*cacheShard // 16 shards to reduce contention
        mask   uint64          // Hash mask for shard selection
}

// cacheShard is a single shard of the cache
type cacheShard struct {
        // Lock-free read path
        entries unsafe.Pointer // *map[string]*optimizedCacheEntry (atomic swap)

        // Write path (protected by mutex)
        mu         sync.Mutex
        writeMap   map[string]*optimizedCacheEntry
        maxEntries int

        // LRU tracking (simplified for performance)
        head *optimizedCacheEntry // Most recently used
        tail *optimizedCacheEntry // Least recently used

        // Statistics (lock-free using atomic)
        hits   uint64
        misses uint64
        evicts uint64
}

// optimizedCacheEntry is a single cache entry with embedded LRU pointers
type optimizedCacheEntry struct {
        font *Font
        key  string

        // LRU doubly-linked list
        prev *optimizedCacheEntry
        next *optimizedCacheEntry

        // Access tracking
        lastAccess  int64  // Unix nano (atomic)
        accessCount uint64 // atomic

        // Hash for deduplication
        hash uint64 // Fast hash instead of SHA256
}

// Entry pool to reduce allocations
var optimizedCacheEntryPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;optimizedCacheEntry{}
        }</span>,
}

// NewOptimizedFontCache creates a new optimized font cache
func NewOptimizedFontCache(totalCapacity int) *OptimizedFontCache <span class="cov8" title="1">{
        if totalCapacity &lt;= 0 </span><span class="cov0" title="0">{
                totalCapacity = 1000
        }</span>

        <span class="cov8" title="1">ofc := &amp;OptimizedFontCache{
                mask: 15, // 16 shards = 0xF mask
        }

        entriesPerShard := totalCapacity / 16
        if entriesPerShard &lt; 1 </span><span class="cov0" title="0">{
                entriesPerShard = 1 // Minimum 1 entry per shard
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                ofc.shards[i] = &amp;cacheShard{
                        writeMap:   make(map[string]*optimizedCacheEntry, entriesPerShard),
                        maxEntries: entriesPerShard,
                }

                // Initialize atomic pointer with empty map
                m := make(map[string]*optimizedCacheEntry, entriesPerShard)
                atomic.StorePointer(&amp;ofc.shards[i].entries, unsafe.Pointer(&amp;m))
        }</span>

        <span class="cov8" title="1">return ofc</span>
}

// fastHash computes a fast non-cryptographic hash
// Uses FNV-1a algorithm - much faster than SHA256
func fastHash(s string) uint64 <span class="cov8" title="1">{
        const (
                offset64 = 14695981039346656037
                prime64  = 1099511628211
        )

        hash := uint64(offset64)
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                hash ^= uint64(s[i])
                hash *= prime64
        }</span>
        <span class="cov8" title="1">return hash</span>
}

// selectShard selects the appropriate shard for a key
func (ofc *OptimizedFontCache) selectShard(key string) *cacheShard <span class="cov8" title="1">{
        h := fastHash(key)
        return ofc.shards[h&amp;ofc.mask]
}</span>

// Get retrieves a font from the cache (lock-free fast path)
func (ofc *OptimizedFontCache) Get(key string) (*Font, bool) <span class="cov8" title="1">{
        shard := ofc.selectShard(key)

        // Lock-free read using atomic load
        entriesPtr := atomic.LoadPointer(&amp;shard.entries)
        entries := *(*map[string]*optimizedCacheEntry)(entriesPtr)

        entry, ok := entries[key]
        if !ok </span><span class="cov8" title="1">{
                atomic.AddUint64(&amp;shard.misses, 1)
                return nil, false
        }</span>

        // Update access time atomically (no lock!)
        <span class="cov8" title="1">atomic.StoreInt64(&amp;entry.lastAccess, time.Now().UnixNano())
        atomic.AddUint64(&amp;entry.accessCount, 1)
        atomic.AddUint64(&amp;shard.hits, 1)

        // Return font without any locks
        return entry.font, true</span>
}

// Set stores a font in the cache
func (ofc *OptimizedFontCache) Set(key string, font *Font) <span class="cov8" title="1">{
        if font == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">shard := ofc.selectShard(key)
        hash := computeFastFontHash(font)

        shard.mu.Lock()

        // Check if already exists in write map
        if existing, ok := shard.writeMap[key]; ok </span><span class="cov0" title="0">{
                // Update existing entry
                existing.font = font
                existing.hash = hash
                atomic.StoreInt64(&amp;existing.lastAccess, time.Now().UnixNano())
                atomic.AddUint64(&amp;existing.accessCount, 1)

                // Move to front of LRU
                shard.moveToFront(existing)
                shard.mu.Unlock()

                // Publish after releasing lock
                shard.publishMap()
                return
        }</span>

        // Evict if at capacity
        <span class="cov8" title="1">if len(shard.writeMap) &gt;= shard.maxEntries </span><span class="cov8" title="1">{
                shard.evictLRU()
        }</span>

        // Get entry from pool
        <span class="cov8" title="1">entry := optimizedCacheEntryPool.Get().(*optimizedCacheEntry)
        entry.font = font
        entry.key = key
        entry.hash = hash
        atomic.StoreInt64(&amp;entry.lastAccess, time.Now().UnixNano())
        atomic.StoreUint64(&amp;entry.accessCount, 1)

        // Add to write map
        shard.writeMap[key] = entry

        // Add to front of LRU
        shard.addToFront(entry)

        shard.mu.Unlock()

        // Publish updated map atomically (after releasing lock)
        shard.publishMap()</span>
}

// publishMap atomically publishes the write map for lock-free reads
func (shard *cacheShard) publishMap() <span class="cov8" title="1">{
        // Create a copy of the write map WITHOUT holding the lock
        // to avoid blocking readers
        shard.mu.Lock()
        newMap := make(map[string]*optimizedCacheEntry, len(shard.writeMap))
        for k, v := range shard.writeMap </span><span class="cov8" title="1">{
                newMap[k] = v
        }</span>
        <span class="cov8" title="1">shard.mu.Unlock()

        // Atomic swap (lock-free)
        atomic.StorePointer(&amp;shard.entries, unsafe.Pointer(&amp;newMap))</span>
}

// moveToFront moves an entry to the front of the LRU list
// Caller must hold shard.mu
func (shard *cacheShard) moveToFront(entry *optimizedCacheEntry) <span class="cov0" title="0">{
        if entry == shard.head </span><span class="cov0" title="0">{
                return // Already at front
        }</span>

        // Remove from current position
        <span class="cov0" title="0">if entry.prev != nil </span><span class="cov0" title="0">{
                entry.prev.next = entry.next
        }</span>
        <span class="cov0" title="0">if entry.next != nil </span><span class="cov0" title="0">{
                entry.next.prev = entry.prev
        }</span>
        <span class="cov0" title="0">if entry == shard.tail </span><span class="cov0" title="0">{
                shard.tail = entry.prev
        }</span>

        // Add to front
        <span class="cov0" title="0">entry.prev = nil
        entry.next = shard.head
        if shard.head != nil </span><span class="cov0" title="0">{
                shard.head.prev = entry
        }</span>
        <span class="cov0" title="0">shard.head = entry

        if shard.tail == nil </span><span class="cov0" title="0">{
                shard.tail = entry
        }</span>
}

// addToFront adds an entry to the front of the LRU list
// Caller must hold shard.mu
func (shard *cacheShard) addToFront(entry *optimizedCacheEntry) <span class="cov8" title="1">{
        entry.prev = nil
        entry.next = shard.head

        if shard.head != nil </span><span class="cov8" title="1">{
                shard.head.prev = entry
        }</span>
        <span class="cov8" title="1">shard.head = entry

        if shard.tail == nil </span><span class="cov8" title="1">{
                shard.tail = entry
        }</span>
}

// evictLRU evicts the least recently used entry
// Caller must hold shard.mu
func (shard *cacheShard) evictLRU() <span class="cov8" title="1">{
        if shard.tail == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Remove from write map
        <span class="cov8" title="1">delete(shard.writeMap, shard.tail.key)

        // Remove from LRU list
        if shard.tail.prev != nil </span><span class="cov8" title="1">{
                shard.tail.prev.next = nil
        }</span>
        <span class="cov8" title="1">oldTail := shard.tail
        shard.tail = shard.tail.prev

        if shard.tail == nil </span><span class="cov0" title="0">{
                shard.head = nil
        }</span>

        // Return to pool
        <span class="cov8" title="1">oldTail.font = nil
        oldTail.prev = nil
        oldTail.next = nil
        optimizedCacheEntryPool.Put(oldTail)

        atomic.AddUint64(&amp;shard.evicts, 1)</span>
}

// computeFastFontHash computes a fast hash for a font
func computeFastFontHash(f *Font) uint64 <span class="cov8" title="1">{
        if f == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">const (
                offset64 = 14695981039346656037
                prime64  = 1099511628211
        )

        hash := uint64(offset64)

        // Hash base font name
        baseFontName := f.BaseFont()
        for i := 0; i &lt; len(baseFontName); i++ </span><span class="cov0" title="0">{
                hash ^= uint64(baseFontName[i])
                hash *= prime64
        }</span>

        // Hash subtype
        <span class="cov8" title="1">subtype := f.subtype()
        for i := 0; i &lt; len(subtype); i++ </span><span class="cov0" title="0">{
                hash ^= uint64(subtype[i])
                hash *= prime64
        }</span>

        // Hash first/last char
        <span class="cov8" title="1">hash ^= uint64(f.FirstChar())
        hash *= prime64
        hash ^= uint64(f.LastChar())
        hash *= prime64

        return hash</span>
}

// GetStats returns aggregated statistics across all shards
func (ofc *OptimizedFontCache) GetStats() FontCacheStats <span class="cov8" title="1">{
        var totalHits, totalMisses, totalEvicts uint64
        var totalEntries int
        var totalMaxEntries int

        for _, shard := range ofc.shards </span><span class="cov8" title="1">{
                shard.mu.Lock()
                totalEntries += len(shard.writeMap)
                totalMaxEntries += shard.maxEntries
                shard.mu.Unlock()

                totalHits += atomic.LoadUint64(&amp;shard.hits)
                totalMisses += atomic.LoadUint64(&amp;shard.misses)
                totalEvicts += atomic.LoadUint64(&amp;shard.evicts)
        }</span>

        <span class="cov8" title="1">total := totalHits + totalMisses
        hitRate := 0.0
        if total &gt; 0 </span><span class="cov8" title="1">{
                hitRate = float64(totalHits) / float64(total)
        }</span>

        <span class="cov8" title="1">return FontCacheStats{
                Entries:    totalEntries,
                MaxEntries: totalMaxEntries,
                Hits:       totalHits,
                Misses:     totalMisses,
                HitRate:    hitRate,
        }</span>
}

// Clear removes all entries from all shards
func (ofc *OptimizedFontCache) Clear() <span class="cov8" title="1">{
        for _, shard := range ofc.shards </span><span class="cov8" title="1">{
                shard.mu.Lock()

                // Return all entries to pool
                for _, entry := range shard.writeMap </span><span class="cov8" title="1">{
                        entry.font = nil
                        entry.prev = nil
                        entry.next = nil
                        optimizedCacheEntryPool.Put(entry)
                }</span>

                <span class="cov8" title="1">shard.writeMap = make(map[string]*optimizedCacheEntry, shard.maxEntries)
                shard.head = nil
                shard.tail = nil

                shard.mu.Unlock()

                // Publish empty map
                shard.publishMap()</span>
        }
}

// Remove removes a specific key from the cache
func (ofc *OptimizedFontCache) Remove(key string) <span class="cov0" title="0">{
        shard := ofc.selectShard(key)

        shard.mu.Lock()
        defer shard.mu.Unlock()

        entry, ok := shard.writeMap[key]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        // Remove from map
        <span class="cov0" title="0">delete(shard.writeMap, key)

        // Remove from LRU list
        if entry.prev != nil </span><span class="cov0" title="0">{
                entry.prev.next = entry.next
        }</span>
        <span class="cov0" title="0">if entry.next != nil </span><span class="cov0" title="0">{
                entry.next.prev = entry.prev
        }</span>
        <span class="cov0" title="0">if entry == shard.head </span><span class="cov0" title="0">{
                shard.head = entry.next
        }</span>
        <span class="cov0" title="0">if entry == shard.tail </span><span class="cov0" title="0">{
                shard.tail = entry.prev
        }</span>

        // Return to pool
        <span class="cov0" title="0">entry.font = nil
        entry.prev = nil
        entry.next = nil
        optimizedCacheEntryPool.Put(entry)

        // Publish updated map
        shard.publishMap()</span>
}

// GetOrCompute retrieves a font from cache or computes it if not present
func (ofc *OptimizedFontCache) GetOrCompute(key string, compute func() (*Font, error)) (*Font, error) <span class="cov0" title="0">{
        // Try lock-free get first
        if font, ok := ofc.Get(key); ok </span><span class="cov0" title="0">{
                return font, nil
        }</span>

        // Compute the font
        <span class="cov0" title="0">font, err := compute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in cache
        <span class="cov0" title="0">ofc.Set(key, font)

        return font, nil</span>
}

// Prefetch warms up the cache with multiple keys concurrently
func (ofc *OptimizedFontCache) Prefetch(keys []string, compute func(key string) (*Font, error)) <span class="cov0" title="0">{
        var wg sync.WaitGroup
        semaphore := make(chan struct{}, 8) // Limit concurrency

        for _, key := range keys </span><span class="cov0" title="0">{
                // Check if already in cache
                if _, ok := ofc.Get(key); ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">wg.Add(1)
                go func(k string) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        semaphore &lt;- struct{}{}
                        defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>()

                        <span class="cov0" title="0">font, err := compute(k)
                        if err == nil &amp;&amp; font != nil </span><span class="cov0" title="0">{
                                ofc.Set(k, font)
                        }</span>
                }(key)
        }

        <span class="cov0" title="0">wg.Wait()</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "container/heap"
        "sync"
        "sync/atomic"
        "time"
)

// FontPrefetcher 
// 
type FontPrefetcher struct {
        cache         *OptimizedFontCache
        accessPattern *AccessPatternTracker
        prefetchQueue *PrefetchQueue
        mu            sync.RWMutex
        enabled       atomic.Value // bool
        stopChan      chan struct{}
}

// AccessPatternTracker 
type AccessPatternTracker struct {
        mu       sync.RWMutex
        patterns map[string]*AccessPattern
        maxSize  int
}

// AccessPattern 
type AccessPattern struct {
        fontKey      string
        accessCount  uint64
        lastAccess   time.Time
        avgInterval  time.Duration
        relatedFonts map[string]int // 
        predictNext  time.Time      // 
}

// PrefetchQueue 
type PrefetchQueue struct {
        mu    sync.Mutex
        items []*PrefetchItem
}

// PrefetchItem 
type PrefetchItem struct {
        fontKey  string
        priority float64 // 
        deadline time.Time
        index    int
}

// NewFontPrefetcher 
func NewFontPrefetcher(cache *OptimizedFontCache) *FontPrefetcher <span class="cov8" title="1">{
        fp := &amp;FontPrefetcher{
                cache: cache,
                accessPattern: &amp;AccessPatternTracker{
                        patterns: make(map[string]*AccessPattern),
                        maxSize:  10000,
                },
                prefetchQueue: &amp;PrefetchQueue{
                        items: make([]*PrefetchItem, 0),
                },
                stopChan: make(chan struct{}),
        }
        fp.enabled.Store(true)

        // 
        go fp.prefetchWorker()

        return fp
}</span>

// RecordAccess 
func (fp *FontPrefetcher) RecordAccess(fontKey string, relatedKeys []string) <span class="cov8" title="1">{
        if !fp.isEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">fp.accessPattern.mu.Lock()

        pattern, exists := fp.accessPattern.patterns[fontKey]
        if !exists </span><span class="cov8" title="1">{
                pattern = &amp;AccessPattern{
                        fontKey:      fontKey,
                        relatedFonts: make(map[string]int),
                }
                fp.accessPattern.patterns[fontKey] = pattern

                // 
                if len(fp.accessPattern.patterns) &gt; fp.accessPattern.maxSize </span><span class="cov8" title="1">{
                        // 
                        oldest := ""
                        oldestTime := time.Now()
                        for k, p := range fp.accessPattern.patterns </span><span class="cov8" title="1">{
                                if p.lastAccess.Before(oldestTime) </span><span class="cov8" title="1">{
                                        oldest = k
                                        oldestTime = p.lastAccess
                                }</span>
                        }
                        <span class="cov8" title="1">if oldest != "" </span><span class="cov8" title="1">{
                                delete(fp.accessPattern.patterns, oldest)
                        }</span>
                }
        }

        <span class="cov8" title="1">now := time.Now()

        // 
        pattern.accessCount++

        // 
        if !pattern.lastAccess.IsZero() </span><span class="cov8" title="1">{
                interval := now.Sub(pattern.lastAccess)
                if pattern.avgInterval == 0 </span><span class="cov8" title="1">{
                        pattern.avgInterval = interval
                }</span> else<span class="cov8" title="1"> {
                        // 
                        pattern.avgInterval = time.Duration(
                                0.7*float64(pattern.avgInterval) + 0.3*float64(interval),
                        )
                }</span>

                // 
                <span class="cov8" title="1">pattern.predictNext = now.Add(pattern.avgInterval)</span>
        }

        <span class="cov8" title="1">pattern.lastAccess = now

        // 
        for _, relatedKey := range relatedKeys </span><span class="cov8" title="1">{
                if relatedKey != fontKey </span><span class="cov8" title="1">{
                        pattern.relatedFonts[relatedKey]++
                }</span>
        }

        <span class="cov8" title="1">fp.accessPattern.mu.Unlock()

        // 
        fp.schedulePrefetch(fontKey)</span>
}

// schedulePrefetch 
func (fp *FontPrefetcher) schedulePrefetch(fontKey string) <span class="cov8" title="1">{
        fp.accessPattern.mu.RLock()
        pattern, exists := fp.accessPattern.patterns[fontKey]
        fp.accessPattern.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return
        }</span>

        // 
        <span class="cov8" title="1">for relatedKey, weight := range pattern.relatedFonts </span><span class="cov8" title="1">{
                // 
                if _, cached := fp.cache.Get(relatedKey); cached </span><span class="cov0" title="0">{
                        continue</span>
                }

                //  * 
                <span class="cov8" title="1">priority := float64(weight)

                //  pattern
                fp.accessPattern.mu.RLock()
                if relatedPattern, ok := fp.accessPattern.patterns[relatedKey]; ok </span><span class="cov0" title="0">{
                        // 
                        if time.Until(relatedPattern.predictNext) &lt; time.Second </span><span class="cov0" title="0">{
                                priority *= 2.0
                        }</span>
                }
                <span class="cov8" title="1">fp.accessPattern.mu.RUnlock()

                // 
                fp.enqueuePrefetch(&amp;PrefetchItem{
                        fontKey:  relatedKey,
                        priority: priority,
                        deadline: time.Now().Add(5 * time.Second),
                })</span>
        }
}

// enqueuePrefetch 
func (fp *FontPrefetcher) enqueuePrefetch(item *PrefetchItem) <span class="cov8" title="1">{
        fp.prefetchQueue.mu.Lock()
        defer fp.prefetchQueue.mu.Unlock()

        // 
        for _, existing := range fp.prefetchQueue.items </span><span class="cov8" title="1">{
                if existing.fontKey == item.fontKey </span><span class="cov8" title="1">{
                        // 
                        if item.priority &gt; existing.priority </span><span class="cov8" title="1">{
                                existing.priority = item.priority
                                heap.Fix(fp.prefetchQueue, existing.index)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
        }

        // 
        <span class="cov8" title="1">heap.Push(fp.prefetchQueue, item)</span>
}

// prefetchWorker 
func (fp *FontPrefetcher) prefetchWorker() <span class="cov8" title="1">{
        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-fp.stopChan:<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if !fp.isEnabled() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">fp.processPrefetchQueue()</span>
                }
        }
}

// processPrefetchQueue 
func (fp *FontPrefetcher) processPrefetchQueue() <span class="cov8" title="1">{
        fp.prefetchQueue.mu.Lock()

        //  5 
        batchSize := 5
        for i := 0; i &lt; batchSize &amp;&amp; fp.prefetchQueue.Len() &gt; 0; i++ </span><span class="cov8" title="1">{
                item := heap.Pop(fp.prefetchQueue).(*PrefetchItem)
                fp.prefetchQueue.mu.Unlock()

                // 
                if time.Now().After(item.deadline) </span><span class="cov0" title="0">{
                        fp.prefetchQueue.mu.Lock()
                        continue</span>
                }

                // 
                <span class="cov8" title="1">if _, cached := fp.cache.Get(item.fontKey); cached </span><span class="cov0" title="0">{
                        fp.prefetchQueue.mu.Lock()
                        continue</span>
                }

                // 
                // 
                // 

                <span class="cov8" title="1">fp.prefetchQueue.mu.Lock()</span>
        }

        <span class="cov8" title="1">fp.prefetchQueue.mu.Unlock()</span>
}

// Enable 
func (fp *FontPrefetcher) Enable() <span class="cov8" title="1">{
        fp.enabled.Store(true)
}</span>

// Disable 
func (fp *FontPrefetcher) Disable() <span class="cov8" title="1">{
        fp.enabled.Store(false)
}</span>

// isEnabled 
func (fp *FontPrefetcher) isEnabled() bool <span class="cov8" title="1">{
        return fp.enabled.Load().(bool)
}</span>

// GetStats 
func (fp *FontPrefetcher) GetStats() PrefetchStats <span class="cov8" title="1">{
        fp.accessPattern.mu.RLock()
        patternsCount := len(fp.accessPattern.patterns)
        fp.accessPattern.mu.RUnlock()

        fp.prefetchQueue.mu.Lock()
        queueSize := fp.prefetchQueue.Len()
        fp.prefetchQueue.mu.Unlock()

        return PrefetchStats{
                PatternsTracked: patternsCount,
                QueueSize:       queueSize,
                Enabled:         fp.isEnabled(),
        }
}</span>

// PrefetchStats 
type PrefetchStats struct {
        PatternsTracked int
        QueueSize       int
        Enabled         bool
}

// ClearPatterns 
func (fp *FontPrefetcher) ClearPatterns() <span class="cov8" title="1">{
        fp.accessPattern.mu.Lock()
        fp.accessPattern.patterns = make(map[string]*AccessPattern)
        fp.accessPattern.mu.Unlock()
}</span>

// Close 
func (fp *FontPrefetcher) Close() <span class="cov8" title="1">{
        close(fp.stopChan)
}</span>

//  heap.Interface for PrefetchQueue

func (pq *PrefetchQueue) Len() int <span class="cov8" title="1">{
        return len(pq.items)
}</span>

func (pq *PrefetchQueue) Less(i, j int) bool <span class="cov8" title="1">{
        // 
        return pq.items[i].priority &gt; pq.items[j].priority
}</span>

func (pq *PrefetchQueue) Swap(i, j int) <span class="cov8" title="1">{
        pq.items[i], pq.items[j] = pq.items[j], pq.items[i]
        pq.items[i].index = i
        pq.items[j].index = j
}</span>

func (pq *PrefetchQueue) Push(x interface{}) <span class="cov8" title="1">{
        item := x.(*PrefetchItem)
        item.index = len(pq.items)
        pq.items = append(pq.items, item)
}</span>

func (pq *PrefetchQueue) Pop() interface{} <span class="cov8" title="1">{
        old := pq.items
        n := len(old)
        if n == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">item := old[n-1]
        old[n-1] = nil
        item.index = -1
        pq.items = old[0 : n-1]
        return item</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Reading of PDF tokens and objects from a raw byte stream.

package pdf

import (
        "fmt"
        "io"
        "strconv"
)

// A token is a PDF token in the input stream, one of the following Go types:
//
//        bool, a PDF boolean
//        int64, a PDF integer
//        float64, a PDF real
//        string, a PDF string literal
//        keyword, a PDF keyword
//        name, a PDF name without the leading slash
type token interface{}

// A name is a PDF name, without the leading slash.
type name string

// A keyword is a PDF keyword.
// Delimiter tokens used in higher-level syntax,
// such as "&lt;&lt;", "&gt;&gt;", "[", "]", "{", "}", are also treated as keywords.
type keyword string

// A buffer holds buffered input bytes from the PDF file.
type buffer struct {
        r           io.Reader // source of data
        buf         []byte    // buffered data
        pos         int       // read index in buf
        offset      int64     // offset at end of buf; aka offset of next read
        tmp         []byte    // scratch space for accumulating token
        unread      []token   // queue of read but then unread tokens
        allowEOF    bool
        allowObjptr bool
        allowStream bool
        eof         bool
        key         []byte
        useAES      bool
        objptr      objptr
}

// newBuffer returns a new buffer reading from r at the given offset.
func newBuffer(r io.Reader, offset int64) *buffer <span class="cov8" title="1">{
        b := GetPDFBuffer()
        b.r = r
        b.offset = offset
        return b
}</span>

func (b *buffer) seek(offset int64) <span class="cov8" title="1">{
        b.offset = offset
        b.buf = b.buf[:0]
        b.pos = 0
        b.unread = b.unread[:0]
}</span>

func (b *buffer) readByte() byte <span class="cov8" title="1">{
        if b.pos &gt;= len(b.buf) </span><span class="cov8" title="1">{
                b.reload()
                if b.pos &gt;= len(b.buf) </span><span class="cov0" title="0">{
                        return '\n'
                }</span>
        }
        <span class="cov8" title="1">c := b.buf[b.pos]
        b.pos++
        return c</span>
}

func (b *buffer) errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        panic(fmt.Errorf(format, args...))</span>
}

func (b *buffer) reload() bool <span class="cov8" title="1">{
        n := cap(b.buf) - int(b.offset%int64(cap(b.buf)))
        n, err := b.r.Read(b.buf[:n])
        if n == 0 &amp;&amp; err != nil </span><span class="cov0" title="0">{
                b.buf = b.buf[:0]
                b.pos = 0
                if b.allowEOF &amp;&amp; err == io.EOF </span><span class="cov0" title="0">{
                        b.eof = true
                        return false
                }</span>
                <span class="cov0" title="0">b.errorf("malformed PDF: reading at offset %d: %v", b.offset, err)
                return false</span>
        }
        <span class="cov8" title="1">b.offset += int64(n)
        b.buf = b.buf[:n]
        b.pos = 0
        return true</span>
}

func (b *buffer) seekForward(offset int64) <span class="cov8" title="1">{
        for b.offset &lt; offset </span><span class="cov0" title="0">{
                if !b.reload() </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">b.pos = len(b.buf) - int(b.offset-offset)</span>
}

func (b *buffer) readOffset() int64 <span class="cov8" title="1">{
        return b.offset - int64(len(b.buf)) + int64(b.pos)
}</span>

func (b *buffer) unreadByte() <span class="cov8" title="1">{
        if b.pos &gt; 0 </span><span class="cov8" title="1">{
                b.pos--
        }</span>
}

func (b *buffer) unreadToken(t token) <span class="cov0" title="0">{
        b.unread = append(b.unread, t)
}</span>

func (b *buffer) readToken() token <span class="cov0" title="0">{
        if n := len(b.unread); n &gt; 0 </span><span class="cov0" title="0">{
                t := b.unread[n-1]
                b.unread = b.unread[:n-1]
                return t
        }</span>

        // Find first non-space, non-comment byte.
        <span class="cov0" title="0">c := b.readByte()
        for </span><span class="cov0" title="0">{
                if isSpace(c) </span><span class="cov0" title="0">{
                        if b.eof </span><span class="cov0" title="0">{
                                return io.EOF
                        }</span>
                        <span class="cov0" title="0">c = b.readByte()</span>
                } else<span class="cov0" title="0"> if c == '%' </span><span class="cov0" title="0">{
                        for c != '\r' &amp;&amp; c != '\n' </span><span class="cov0" title="0">{
                                c = b.readByte()
                        }</span>
                } else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">switch c </span>{
        case '&lt;':<span class="cov0" title="0">
                if b.readByte() == '&lt;' </span><span class="cov0" title="0">{
                        return keyword("&lt;&lt;")
                }</span>
                <span class="cov0" title="0">b.unreadByte()
                return b.readHexString()</span>

        case '(':<span class="cov0" title="0">
                return b.readLiteralString()</span>

        case '[', ']', '{', '}':<span class="cov0" title="0">
                return keyword(string(c))</span>

        case '/':<span class="cov0" title="0">
                return b.readName()</span>

        case '&gt;':<span class="cov0" title="0">
                if b.readByte() == '&gt;' </span><span class="cov0" title="0">{
                        return keyword("&gt;&gt;")
                }</span>
                <span class="cov0" title="0">b.unreadByte()
                fallthrough</span>

        default:<span class="cov0" title="0">
                if isDelim(c) </span><span class="cov0" title="0">{
                        b.errorf("unexpected delimiter %#q", rune(c))
                        return nil
                }</span>
                <span class="cov0" title="0">b.unreadByte()
                return b.readKeyword()</span>
        }
}

func (b *buffer) readHexString() token <span class="cov0" title="0">{
        tmp := b.tmp[:0]
        for </span><span class="cov0" title="0">{
        </span>Loop:
                <span class="cov0" title="0">c := b.readByte()
                if c == '&gt;' </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if isSpace(c) </span><span class="cov0" title="0">{
                        goto Loop</span>
                }
        Loop2:
                <span class="cov0" title="0">c2 := b.readByte()
                if isSpace(c2) </span><span class="cov0" title="0">{
                        goto Loop2</span>
                }
                <span class="cov0" title="0">x := unhex(c)&lt;&lt;4 | unhex(c2)
                if x &lt; 0 </span><span class="cov0" title="0">{
                        b.errorf("malformed hex string %c %c %s", c, c2, b.buf[b.pos:])
                        break</span>
                }
                <span class="cov0" title="0">tmp = append(tmp, byte(x))</span>
        }
        <span class="cov0" title="0">b.tmp = tmp
        return string(tmp)</span>
}

func unhex(b byte) int <span class="cov0" title="0">{
        switch </span>{
        case '0' &lt;= b &amp;&amp; b &lt;= '9':<span class="cov0" title="0">
                return int(b) - '0'</span>
        case 'a' &lt;= b &amp;&amp; b &lt;= 'f':<span class="cov0" title="0">
                return int(b) - 'a' + 10</span>
        case 'A' &lt;= b &amp;&amp; b &lt;= 'F':<span class="cov0" title="0">
                return int(b) - 'A' + 10</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func (b *buffer) readLiteralString() token <span class="cov0" title="0">{
        tmp := b.tmp[:0]
        depth := 1
Loop:
        for !b.eof </span><span class="cov0" title="0">{
                c := b.readByte()
                switch c </span>{
                default:<span class="cov0" title="0">
                        tmp = append(tmp, c)</span>
                case '(':<span class="cov0" title="0">
                        depth++
                        tmp = append(tmp, c)</span>
                case ')':<span class="cov0" title="0">
                        if depth--; depth == 0 </span><span class="cov0" title="0">{
                                break Loop</span>
                        }
                        <span class="cov0" title="0">tmp = append(tmp, c)</span>
                case '\\':<span class="cov0" title="0">
                        switch c = b.readByte(); c </span>{
                        default:<span class="cov0" title="0">
                                b.errorf("invalid escape sequence \\%c", c)
                                tmp = append(tmp, '\\', c)</span>
                        case 'n':<span class="cov0" title="0">
                                tmp = append(tmp, '\n')</span>
                        case 'r':<span class="cov0" title="0">
                                tmp = append(tmp, '\r')</span>
                        case 'b':<span class="cov0" title="0">
                                tmp = append(tmp, '\b')</span>
                        case 't':<span class="cov0" title="0">
                                tmp = append(tmp, '\t')</span>
                        case 'f':<span class="cov0" title="0">
                                tmp = append(tmp, '\f')</span>
                        case '(', ')', '\\':<span class="cov0" title="0">
                                tmp = append(tmp, c)</span>
                        case '\r':<span class="cov0" title="0">
                                if b.readByte() != '\n' </span><span class="cov0" title="0">{
                                        b.unreadByte()
                                }</span>
                                <span class="cov0" title="0">fallthrough</span>
                        case '\n':<span class="cov0" title="0"></span>
                                // no append
                        case '0', '1', '2', '3', '4', '5', '6', '7':<span class="cov0" title="0">
                                x := int(c - '0')
                                for i := 0; i &lt; 2; i++ </span><span class="cov0" title="0">{
                                        c = b.readByte()
                                        if c &lt; '0' || c &gt; '7' </span><span class="cov0" title="0">{
                                                b.unreadByte()
                                                break</span>
                                        }
                                        <span class="cov0" title="0">x = x*8 + int(c-'0')</span>
                                }
                                <span class="cov0" title="0">if x &gt; 255 </span><span class="cov0" title="0">{
                                        b.errorf("invalid octal escape \\%03o", x)
                                }</span>
                                <span class="cov0" title="0">tmp = append(tmp, byte(x))</span>
                        }
                }
        }
        <span class="cov0" title="0">b.tmp = tmp
        return string(tmp)</span>
}

func (b *buffer) readName() token <span class="cov0" title="0">{
        tmp := b.tmp[:0]
        for </span><span class="cov0" title="0">{
                c := b.readByte()
                if isDelim(c) || isSpace(c) </span><span class="cov0" title="0">{
                        b.unreadByte()
                        break</span>
                }
                <span class="cov0" title="0">if c == '#' </span><span class="cov0" title="0">{
                        x := unhex(b.readByte())&lt;&lt;4 | unhex(b.readByte())
                        if x &lt; 0 </span><span class="cov0" title="0">{
                                b.errorf("malformed name")
                        }</span>
                        <span class="cov0" title="0">tmp = append(tmp, byte(x))
                        continue</span>
                }
                <span class="cov0" title="0">tmp = append(tmp, c)</span>
        }
        <span class="cov0" title="0">b.tmp = tmp
        return name(string(tmp))</span>
}

func (b *buffer) readKeyword() token <span class="cov0" title="0">{
        tmp := b.tmp[:0]
        for </span><span class="cov0" title="0">{
                c := b.readByte()
                if isDelim(c) || isSpace(c) </span><span class="cov0" title="0">{
                        b.unreadByte()
                        break</span>
                }
                <span class="cov0" title="0">tmp = append(tmp, c)</span>
        }
        <span class="cov0" title="0">b.tmp = tmp
        s := string(tmp)
        switch </span>{
        case s == "true":<span class="cov0" title="0">
                return true</span>
        case s == "false":<span class="cov0" title="0">
                return false</span>
        case isInteger(s):<span class="cov0" title="0">
                x, err := strconv.ParseInt(s, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        b.errorf("invalid integer %s", s)
                }</span>
                <span class="cov0" title="0">return x</span>
        case isReal(s):<span class="cov0" title="0">
                x, err := strconv.ParseFloat(s, 64)
                if err != nil </span><span class="cov0" title="0">{
                        b.errorf("invalid real %s", s)
                }</span>
                <span class="cov0" title="0">return x</span>
        }
        <span class="cov0" title="0">return keyword(string(tmp))</span>
}

func isInteger(s string) bool <span class="cov0" title="0">{
        if len(s) &gt; 0 &amp;&amp; (s[0] == '+' || s[0] == '-') </span><span class="cov0" title="0">{
                s = s[1:]
        }</span>
        <span class="cov0" title="0">if len(s) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, c := range s </span><span class="cov0" title="0">{
                if c &lt; '0' || '9' &lt; c </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func isReal(s string) bool <span class="cov0" title="0">{
        if len(s) &gt; 0 &amp;&amp; (s[0] == '+' || s[0] == '-') </span><span class="cov0" title="0">{
                s = s[1:]
        }</span>
        <span class="cov0" title="0">if len(s) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">ndot := 0
        for _, c := range s </span><span class="cov0" title="0">{
                if c == '.' </span><span class="cov0" title="0">{
                        ndot++
                        continue</span>
                }
                <span class="cov0" title="0">if c &lt; '0' || '9' &lt; c </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return ndot == 1</span>
}

// An object is a PDF syntax object, one of the following Go types:
//
//        bool, a PDF boolean
//        int64, a PDF integer
//        float64, a PDF real
//        string, a PDF string literal
//        name, a PDF name without the leading slash
//        dict, a PDF dictionary
//        array, a PDF array
//        stream, a PDF stream
//        objptr, a PDF object reference
//        objdef, a PDF object definition
//
// An object may also be nil, to represent the PDF null.
type object interface{}

type dict map[name]object

type array []object

type stream struct {
        hdr    dict
        ptr    objptr
        offset int64
}

type objptr struct {
        id  uint32
        gen uint16
}

type objdef struct {
        ptr objptr
        obj object
}

func (b *buffer) readObject() object <span class="cov0" title="0">{
        tok := b.readToken()
        if kw, ok := tok.(keyword); ok </span><span class="cov0" title="0">{
                switch kw </span>{
                case "null":<span class="cov0" title="0">
                        return nil</span>
                case "&lt;&lt;":<span class="cov0" title="0">
                        return b.readDict()</span>
                case "[":<span class="cov0" title="0">
                        return b.readArray()</span>
                case "&gt;&gt;":<span class="cov0" title="0">
                        // stop the object
                        return nil</span>
                }
                <span class="cov0" title="0">b.errorf("unexpected keyword %q parsing object", kw)
                return nil</span>
        }

        <span class="cov0" title="0">if str, ok := tok.(string); ok &amp;&amp; b.key != nil &amp;&amp; b.objptr.id != 0 </span><span class="cov0" title="0">{
                tok = decryptString(b.key, b.useAES, b.objptr, str)
        }</span>

        <span class="cov0" title="0">if !b.allowObjptr </span><span class="cov0" title="0">{
                return tok
        }</span>

        <span class="cov0" title="0">if t1, ok := tok.(int64); ok &amp;&amp; int64(uint32(t1)) == t1 </span><span class="cov0" title="0">{
                tok2 := b.readToken()
                if t2, ok := tok2.(int64); ok &amp;&amp; int64(uint16(t2)) == t2 </span><span class="cov0" title="0">{
                        tok3 := b.readToken()
                        switch tok3 </span>{
                        case keyword("R"):<span class="cov0" title="0">
                                return objptr{uint32(t1), uint16(t2)}</span>
                        case keyword("obj"):<span class="cov0" title="0">
                                old := b.objptr
                                b.objptr = objptr{uint32(t1), uint16(t2)}
                                obj := b.readObject()
                                if _, ok := obj.(stream); !ok </span><span class="cov0" title="0">{
                                        tok4 := b.readToken()
                                        if tok4 != keyword("endobj") </span><span class="cov0" title="0">{
                                                b.errorf("missing endobj after indirect object definition")
                                                b.unreadToken(tok4)
                                        }</span>
                                }
                                <span class="cov0" title="0">b.objptr = old
                                return objdef{objptr{uint32(t1), uint16(t2)}, obj}</span>
                        }
                        <span class="cov0" title="0">b.unreadToken(tok3)</span>
                }
                <span class="cov0" title="0">b.unreadToken(tok2)</span>
        }
        <span class="cov0" title="0">return tok</span>
}

func (b *buffer) readArray() object <span class="cov0" title="0">{
        var x array
        for </span><span class="cov0" title="0">{
                tok := b.readToken()
                if tok == nil || tok == keyword("]") </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">b.unreadToken(tok)
                x = append(x, b.readObject())</span>
        }
        <span class="cov0" title="0">return x</span>
}

func (b *buffer) readDict() object <span class="cov0" title="0">{
        x := make(dict)
        for </span><span class="cov0" title="0">{
                tok := b.readToken()
                if tok == nil || tok == keyword("&gt;&gt;") </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if tok == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">n, ok := tok.(name)
                if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: %T(%v)\n. Skip dict", tok, tok)
                        b.errorf("unexpected non-name key %T(%v) parsing dictionary", tok, tok)
                        continue</span>
                }
                <span class="cov0" title="0">x[n] = b.readObject()</span>
        }

        <span class="cov0" title="0">if !b.allowStream </span><span class="cov0" title="0">{
                return x
        }</span>

        <span class="cov0" title="0">tok := b.readToken()
        if tok != keyword("stream") </span><span class="cov0" title="0">{
                b.unreadToken(tok)
                return x
        }</span>

        <span class="cov0" title="0">switch b.readByte() </span>{
        case '\r':<span class="cov0" title="0">
                if b.readByte() != '\n' </span><span class="cov0" title="0">{
                        b.unreadByte()
                }</span>
        case '\n':<span class="cov0" title="0"></span>
                // ok
        default:<span class="cov0" title="0">
                b.errorf("stream keyword not followed by newline")</span>
        }

        <span class="cov0" title="0">return stream{x, b.objptr, b.readOffset()}</span>
}

func isSpace(b byte) bool <span class="cov0" title="0">{
        switch b </span>{
        case '\x00', '\t', '\n', '\f', '\r', ' ':<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isDelim(b byte) bool <span class="cov0" title="0">{
        switch b </span>{
        case '&lt;', '&gt;', '(', ')', '[', ']', '{', '}', '/', '%':<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "strings"
        "time"
)

// Metadata represents PDF document metadata
type Metadata struct {
        Title        string            // Document title
        Author       string            // Author name
        Subject      string            // Document subject
        Keywords     []string          // Keywords
        Creator      string            // Application that created the document
        Producer     string            // PDF producer (converter)
        CreationDate time.Time         // Creation date
        ModDate      time.Time         // Last modification date
        Trapped      string            // Trapping information (True/False/Unknown)
        Custom       map[string]string // Custom metadata fields
}

// GetMetadata extracts metadata from the PDF document
func (r *Reader) GetMetadata() (Metadata, error) <span class="cov8" title="1">{
        meta := Metadata{
                Custom: make(map[string]string),
        }

        // Get Info dictionary from trailer
        info := r.Trailer().Key("Info")
        if info.Kind() == Null </span><span class="cov8" title="1">{
                // No metadata available
                return meta, nil
        }</span>

        // Extract standard metadata fields
        <span class="cov0" title="0">meta.Title = decodeMetadataString(info.Key("Title"))
        meta.Author = decodeMetadataString(info.Key("Author"))
        meta.Subject = decodeMetadataString(info.Key("Subject"))
        meta.Creator = decodeMetadataString(info.Key("Creator"))
        meta.Producer = decodeMetadataString(info.Key("Producer"))
        meta.Trapped = info.Key("Trapped").Name()

        // Parse keywords (may be comma-separated)
        keywordsStr := decodeMetadataString(info.Key("Keywords"))
        if keywordsStr != "" </span><span class="cov0" title="0">{
                // Split by comma or semicolon
                keywords := strings.FieldsFunc(keywordsStr, func(r rune) bool </span><span class="cov0" title="0">{
                        return r == ',' || r == ';'
                }</span>)
                <span class="cov0" title="0">for _, kw := range keywords </span><span class="cov0" title="0">{
                        kw = strings.TrimSpace(kw)
                        if kw != "" </span><span class="cov0" title="0">{
                                meta.Keywords = append(meta.Keywords, kw)
                        }</span>
                }
        }

        // Parse dates
        <span class="cov0" title="0">meta.CreationDate = parsePDFDate(info.Key("CreationDate"))
        meta.ModDate = parsePDFDate(info.Key("ModDate"))

        // Extract custom fields (any key not in standard set)
        standardKeys := map[string]bool{
                "Title":        true,
                "Author":       true,
                "Subject":      true,
                "Keywords":     true,
                "Creator":      true,
                "Producer":     true,
                "CreationDate": true,
                "ModDate":      true,
                "Trapped":      true,
        }

        if info.Kind() == Dict </span><span class="cov0" title="0">{
                for _, key := range info.Keys() </span><span class="cov0" title="0">{
                        if !standardKeys[key] </span><span class="cov0" title="0">{
                                meta.Custom[key] = decodeMetadataString(info.Key(key))
                        }</span>
                }
        }

        // Try to get XMP metadata if available
        <span class="cov0" title="0">catalog := r.Trailer().Key("Root")
        xmpMetadata := catalog.Key("Metadata")
        if xmpMetadata.Kind() == Stream </span><span class="cov0" title="0">{
                // XMP metadata is available but requires XML parsing
                // For now, we'll just note its presence in custom fields
                meta.Custom["_HasXMP"] = "true"
        }</span>

        <span class="cov0" title="0">return meta, nil</span>
}

// decodeMetadataString decodes a PDF string value to Go string
func decodeMetadataString(v Value) string <span class="cov0" title="0">{
        if v.Kind() == Null </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">s := v.RawString()
        if s == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Check for UTF-16 BOM
        <span class="cov0" title="0">if len(s) &gt;= 2 &amp;&amp; s[0] == 0xFE &amp;&amp; s[1] == 0xFF </span><span class="cov0" title="0">{
                // UTF-16 BE
                return decodeUTF16BE([]byte(s[2:]))
        }</span>

        // Check for UTF-8 BOM
        <span class="cov0" title="0">if len(s) &gt;= 3 &amp;&amp; s[0] == 0xEF &amp;&amp; s[1] == 0xBB &amp;&amp; s[2] == 0xBF </span><span class="cov0" title="0">{
                return s[3:]
        }</span>

        // Assume PDFDocEncoding (similar to Latin-1 but with some differences)
        <span class="cov0" title="0">return decodePDFDocEncoding(s)</span>
}

// decodePDFDocEncoding decodes PDFDocEncoding string
func decodePDFDocEncoding(s string) string <span class="cov0" title="0">{
        // PDFDocEncoding is identical to ISO Latin 1 for codes 0-127
        // and uses a specific mapping for 128-255
        // For simplicity, we'll treat it as Latin-1 for common cases
        // A full implementation would use the PDFDocEncoding table
        return s
}</span>

// decodeUTF16BE decodes UTF-16 Big Endian bytes to string
func decodeUTF16BE(b []byte) string <span class="cov8" title="1">{
        if len(b)%2 != 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">runes := make([]rune, 0, len(b)/2)
        for i := 0; i &lt; len(b); i += 2 </span><span class="cov8" title="1">{
                r := rune(b[i])&lt;&lt;8 | rune(b[i+1])
                runes = append(runes, r)
        }</span>
        <span class="cov8" title="1">return string(runes)</span>
}

// parsePDFDate parses a PDF date string to time.Time
// PDF date format: D:YYYYMMDDHHmmSSOHH'mm'
// Example: D:20240318143022+08'00'
func parsePDFDate(v Value) time.Time <span class="cov8" title="1">{
        if v.Kind() == Null </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov8" title="1">s := v.RawString()
        if s == "" || !strings.HasPrefix(s, "D:") </span><span class="cov8" title="1">{
                return time.Time{}
        }</span>

        <span class="cov8" title="1">s = s[2:] // Remove "D:" prefix

        // Extract date components
        if len(s) &lt; 14 </span><span class="cov8" title="1">{
                // Not enough data for a complete date
                return time.Time{}
        }</span>

        <span class="cov8" title="1">year := parseInt(s[0:4])
        month := parseInt(s[4:6])
        day := parseInt(s[6:8])
        hour := parseInt(s[8:10])
        minute := parseInt(s[10:12])
        second := parseInt(s[12:14])

        // Parse timezone if present
        var loc *time.Location
        if len(s) &gt; 14 </span><span class="cov8" title="1">{
                tzStr := s[14:]
                loc = parsePDFTimezone(tzStr)
        }</span>
        <span class="cov8" title="1">if loc == nil </span><span class="cov8" title="1">{
                loc = time.UTC
        }</span>

        <span class="cov8" title="1">return time.Date(year, time.Month(month), day, hour, minute, second, 0, loc)</span>
}

// parsePDFTimezone parses PDF timezone string (e.g., "+08'00'", "-05'00'", "Z")
func parsePDFTimezone(s string) *time.Location <span class="cov8" title="1">{
        if s == "" || s == "Z" </span><span class="cov8" title="1">{
                return time.UTC
        }</span>

        <span class="cov8" title="1">if len(s) &lt; 3 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">sign := 1
        if s[0] == '-' </span><span class="cov0" title="0">{
                sign = -1
        }</span> else<span class="cov8" title="1"> if s[0] != '+' </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Parse hour offset
        <span class="cov8" title="1">hourOffset := parseInt(s[1:3])

        // Parse minute offset if present
        minuteOffset := 0
        if len(s) &gt;= 6 &amp;&amp; s[3] == '\'' </span><span class="cov8" title="1">{
                minuteOffset = parseInt(s[4:6])
        }</span>

        <span class="cov8" title="1">totalOffset := sign * (hourOffset*3600 + minuteOffset*60)
        return time.FixedZone("PDF", totalOffset)</span>
}

// parseInt parses a string to int, returns 0 on error
func parseInt(s string) int <span class="cov8" title="1">{
        result := 0
        for _, c := range s </span><span class="cov8" title="1">{
                if c &gt;= '0' &amp;&amp; c &lt;= '9' </span><span class="cov8" title="1">{
                        result = result*10 + int(c-'0')
                }</span> else<span class="cov8" title="1"> {
                        return 0
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// SetMetadata sets metadata fields in the PDF (for future write support)
// Currently not implemented as the library is read-only
func (r *Reader) SetMetadata(meta Metadata) error <span class="cov8" title="1">{
        return &amp;PDFError{
                Op:  "set metadata",
                Err: ErrUnsupportedVersion, // Reuse this error for "not implemented"
        }
}</span>

// GetDocumentInfo returns a formatted string with document information
func (m Metadata) String() string <span class="cov8" title="1">{
        var b strings.Builder

        if m.Title != "" </span><span class="cov8" title="1">{
                b.WriteString("Title: " + m.Title + "\n")
        }</span>
        <span class="cov8" title="1">if m.Author != "" </span><span class="cov8" title="1">{
                b.WriteString("Author: " + m.Author + "\n")
        }</span>
        <span class="cov8" title="1">if m.Subject != "" </span><span class="cov8" title="1">{
                b.WriteString("Subject: " + m.Subject + "\n")
        }</span>
        <span class="cov8" title="1">if len(m.Keywords) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("Keywords: " + strings.Join(m.Keywords, ", ") + "\n")
        }</span>
        <span class="cov8" title="1">if m.Creator != "" </span><span class="cov8" title="1">{
                b.WriteString("Creator: " + m.Creator + "\n")
        }</span>
        <span class="cov8" title="1">if m.Producer != "" </span><span class="cov8" title="1">{
                b.WriteString("Producer: " + m.Producer + "\n")
        }</span>
        <span class="cov8" title="1">if !m.CreationDate.IsZero() </span><span class="cov8" title="1">{
                b.WriteString("Created: " + m.CreationDate.Format(time.RFC3339) + "\n")
        }</span>
        <span class="cov8" title="1">if !m.ModDate.IsZero() </span><span class="cov8" title="1">{
                b.WriteString("Modified: " + m.ModDate.Format(time.RFC3339) + "\n")
        }</span>
        <span class="cov8" title="1">if m.Trapped != "" </span><span class="cov8" title="1">{
                b.WriteString("Trapped: " + m.Trapped + "\n")
        }</span>

        <span class="cov8" title="1">if len(m.Custom) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("Custom fields:\n")
                for key, value := range m.Custom </span><span class="cov8" title="1">{
                        if !strings.HasPrefix(key, "_") </span><span class="cov8" title="1">{ // Skip internal fields
                                b.WriteString("  " + key + ": " + value + "\n")
                        }</span>
                }
        }

        <span class="cov8" title="1">return b.String()</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "strings"
        "unicode"
)

// Language represents a language code
type Language string

const (
        English Language = "en"
        French  Language = "fr"
        German  Language = "de"
        Spanish Language = "es"
        Unknown Language = "unknown"
)

// LanguageInfo contains information about a detected language
type LanguageInfo struct {
        Language      Language
        Confidence    float64 // Confidence level (0.0 to 1.0)
        Characters    []rune  // Unique characters in the text
        WordCount     int     // Number of words in the text
        SentenceCount int     // Number of sentences in the text
}

// MultiLangProcessor provides multi-language text processing
type MultiLangProcessor struct {
        // Common words for language detection
        englishWords []string
        frenchWords  []string
        germanWords  []string
        spanishWords []string
}

// NewMultiLangProcessor creates a new multi-language processor
func NewMultiLangProcessor() *MultiLangProcessor <span class="cov8" title="1">{
        return &amp;MultiLangProcessor{
                englishWords: []string{"the", "be", "to", "of", "and", "a", "in", "that", "have", "i", "it", "for", "not", "on", "with", "he", "as", "you", "do", "at"},
                frenchWords:  []string{"le", "de", "et", "un", "il", "tre", "et", "", "dans", "ne", "la", "les", "son", "que", "pour", "se", "ce", "d'", "en", "du"},
                germanWords:  []string{"der", "die", "und", "in", "den", "von", "zu", "das", "mit", "sich", "des", "auf", "fr", "ist", "im", "dem", "nicht", "ein", "eine", "als"},
                spanishWords: []string{"el", "de", "que", "y", "a", "en", "un", "es", "se", "no", "te", "lo", "le", "da", "su", "por", "son", "con", "para", "al"},
        }
}</span>

// DetectLanguage detects the language of a given text
func (mlp *MultiLangProcessor) DetectLanguage(text string) LanguageInfo <span class="cov8" title="1">{
        if text == "" </span><span class="cov8" title="1">{
                return LanguageInfo{Language: Unknown, Confidence: 0.0}
        }</span>

        <span class="cov8" title="1">englishScore := mlp.scoreText(text, mlp.englishWords)
        frenchScore := mlp.scoreText(text, mlp.frenchWords)
        germanScore := mlp.scoreText(text, mlp.germanWords)
        spanishScore := mlp.scoreText(text, mlp.spanishWords)

        maxScore := englishScore
        detectedLang := English

        if frenchScore &gt; maxScore </span><span class="cov8" title="1">{
                maxScore = frenchScore
                detectedLang = French
        }</span>
        <span class="cov8" title="1">if germanScore &gt; maxScore </span><span class="cov8" title="1">{
                maxScore = germanScore
                detectedLang = German
        }</span>
        <span class="cov8" title="1">if spanishScore &gt; maxScore </span><span class="cov8" title="1">{
                maxScore = spanishScore
                detectedLang = Spanish
        }</span>

        // Calculate confidence as a percentage of the highest score over total
        <span class="cov8" title="1">totalScore := englishScore + frenchScore + germanScore + spanishScore
        confidence := 0.0
        if totalScore &gt; 0 </span><span class="cov8" title="1">{
                confidence = maxScore / totalScore
                // Normalize to 0-1 range, with minimum confidence of 0.25 for random chance
                confidence = 0.25 + (confidence * 0.75)
        }</span>

        // Ensure confidence is between 0 and 1
        <span class="cov8" title="1">if confidence &gt; 1.0 </span><span class="cov0" title="0">{
                confidence = 1.0
        }</span>

        <span class="cov8" title="1">return LanguageInfo{
                Language:      detectedLang,
                Confidence:    confidence,
                Characters:    mlp.getUniqueCharacters(text),
                WordCount:     mlp.countWords(text),
                SentenceCount: mlp.countSentences(text),
        }</span>
}

// scoreText calculates a score for how likely the text is in a particular language
func (mlp *MultiLangProcessor) scoreText(text string, commonWords []string) float64 <span class="cov8" title="1">{
        text = strings.ToLower(text)
        words := strings.Fields(text)

        score := 0.0
        for _, word := range words </span><span class="cov8" title="1">{
                // Remove punctuation from the word - build a new string with only letters and numbers
                var cleanWord string
                for _, r := range word </span><span class="cov8" title="1">{
                        if unicode.IsLetter(r) || unicode.IsNumber(r) </span><span class="cov8" title="1">{
                                cleanWord += string(r)
                        }</span>
                }

                <span class="cov8" title="1">if len(cleanWord) &gt; 1 </span><span class="cov8" title="1">{ // Only consider words with more than one character
                        for _, commonWord := range commonWords </span><span class="cov8" title="1">{
                                if cleanWord == commonWord </span><span class="cov8" title="1">{
                                        score++
                                        break</span>
                                }
                        }
                }
        }

        // Normalize by text length to avoid bias towards longer texts
        <span class="cov8" title="1">if len(words) &gt; 0 </span><span class="cov8" title="1">{
                score = score / float64(len(words))
        }</span>

        <span class="cov8" title="1">return score</span>
}

// getUniqueCharacters returns the unique characters in a text
func (mlp *MultiLangProcessor) getUniqueCharacters(text string) []rune <span class="cov8" title="1">{
        seen := make(map[rune]bool)
        var uniqueChars []rune

        for _, r := range text </span><span class="cov8" title="1">{
                if !seen[r] </span><span class="cov8" title="1">{
                        seen[r] = true
                        uniqueChars = append(uniqueChars, r)
                }</span>
        }

        <span class="cov8" title="1">return uniqueChars</span>
}

// countWords counts the number of words in a text
func (mlp *MultiLangProcessor) countWords(text string) int <span class="cov8" title="1">{
        words := strings.Fields(text)
        count := 0
        for _, word := range words </span><span class="cov8" title="1">{
                // Count as a word if it contains at least one letter or digit
                for _, r := range word </span><span class="cov8" title="1">{
                        if unicode.IsLetter(r) || unicode.IsDigit(r) </span><span class="cov8" title="1">{
                                count++
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return count</span>
}

// countSentences counts the number of sentences in a text
func (mlp *MultiLangProcessor) countSentences(text string) int <span class="cov8" title="1">{
        count := 0
        inSentence := false

        for _, r := range text </span><span class="cov8" title="1">{
                if unicode.IsLetter(r) || unicode.IsNumber(r) </span><span class="cov8" title="1">{
                        inSentence = true
                }</span> else<span class="cov8" title="1"> if r == '.' || r == '!' || r == '?' </span><span class="cov8" title="1">{
                        if inSentence </span><span class="cov8" title="1">{
                                count++
                                inSentence = false
                        }</span>
                } else<span class="cov8" title="1"> if unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        // End of potential sentence if we were in one
                        if inSentence &amp;&amp; (r == '\n' || r == '\r') </span><span class="cov0" title="0">{
                                inSentence = false
                        }</span>
                }
        }

        // If we ended with a sentence in progress, count it
        <span class="cov8" title="1">if inSentence </span><span class="cov8" title="1">{
                count++
        }</span>

        <span class="cov8" title="1">return count</span>
}

// ProcessTextWithLanguageDetection processes text with language detection
func (mlp *MultiLangProcessor) ProcessTextWithLanguageDetection(texts []Text) []TextWithLanguage <span class="cov8" title="1">{
        var result []TextWithLanguage

        for _, text := range texts </span><span class="cov8" title="1">{
                langInfo := mlp.DetectLanguage(text.S)
                result = append(result, TextWithLanguage{
                        Text:       text,
                        Language:   langInfo,
                        Confidence: langInfo.Confidence,
                })
        }</span>

        <span class="cov8" title="1">return result</span>
}

// TextWithLanguage represents text with detected language information
type TextWithLanguage struct {
        Text       Text
        Language   LanguageInfo
        Confidence float64
}

// LanguageTextExtractor extracts text while detecting languages
type LanguageTextExtractor struct {
        processor *MultiLangProcessor
}

// NewLanguageTextExtractor creates a new language-aware text extractor
func NewLanguageTextExtractor() *LanguageTextExtractor <span class="cov8" title="1">{
        return &amp;LanguageTextExtractor{
                processor: NewMultiLangProcessor(),
        }
}</span>

// ExtractTextByLanguage extracts text grouped by detected language
func (lte *LanguageTextExtractor) ExtractTextByLanguage(reader *Reader) (map[Language][]Text, error) <span class="cov0" title="0">{
        totalPages := reader.NumPage()
        result := make(map[Language][]Text)

        for pageNum := 1; pageNum &lt;= totalPages; pageNum++ </span><span class="cov0" title="0">{
                page := reader.Page(pageNum)
                content := page.Content()

                // Process each text element to detect language
                for _, text := range content.Text </span><span class="cov0" title="0">{
                        langInfo := lte.processor.DetectLanguage(text.S)
                        result[langInfo.Language] = append(result[langInfo.Language], text)
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// GetTextsByLanguage returns text elements filtered by specific language
func (lte *LanguageTextExtractor) GetTextsByLanguage(texts []Text, targetLang Language) []Text <span class="cov8" title="1">{
        var filtered []Text

        for _, text := range texts </span><span class="cov8" title="1">{
                langInfo := lte.processor.DetectLanguage(text.S)
                if langInfo.Language == targetLang &amp;&amp; langInfo.Confidence &gt; 0.5 </span><span class="cov8" title="1">{ // Only high confidence matches
                        filtered = append(filtered, text)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

// GetLanguageStats returns statistics about languages detected in the text
func (lte *LanguageTextExtractor) GetLanguageStats(texts []Text) map[Language]int <span class="cov8" title="1">{
        stats := make(map[Language]int)

        for _, text := range texts </span><span class="cov8" title="1">{
                langInfo := lte.processor.DetectLanguage(text.S)
                if langInfo.Confidence &gt; 0.5 </span><span class="cov8" title="1">{ // Only count high-confidence detections
                        stats[langInfo.Language]++
                }</span>
        }

        <span class="cov8" title="1">return stats</span>
}

// MultiLanguageTextClassifier extends the text classifier with language awareness
type MultiLanguageTextClassifier struct {
        *TextClassifier
        processor *MultiLangProcessor
}

// NewMultiLanguageTextClassifier creates a new multi-language text classifier
func NewMultiLanguageTextClassifier(texts []Text, pageWidth, pageHeight float64) *MultiLanguageTextClassifier <span class="cov8" title="1">{
        // First classify with the base classifier
        baseClassifier := NewTextClassifier(texts, pageWidth, pageHeight)

        return &amp;MultiLanguageTextClassifier{
                TextClassifier: baseClassifier,
                processor:      NewMultiLangProcessor(),
        }
}</span>

// ClassifyBlocksWithLanguage extends the classification with language information
func (mltc *MultiLanguageTextClassifier) ClassifyBlocksWithLanguage() []ClassifiedBlockWithLanguage <span class="cov8" title="1">{
        baseBlocks := mltc.ClassifyBlocks()
        var result []ClassifiedBlockWithLanguage

        for _, baseBlock := range baseBlocks </span><span class="cov8" title="1">{
                // Detect language for the block text
                langInfo := mltc.processor.DetectLanguage(baseBlock.Text)

                result = append(result, ClassifiedBlockWithLanguage{
                        ClassifiedBlock: baseBlock,
                        Language:        langInfo,
                })
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ClassifiedBlockWithLanguage represents a classified block with language information
type ClassifiedBlockWithLanguage struct {
        ClassifiedBlock
        Language LanguageInfo
}

// ProcessTextWithMultiLanguage handles multi-language text processing for the entire PDF
func ProcessTextWithMultiLanguage(reader *Reader) (map[Language][]ClassifiedBlock, error) <span class="cov8" title="1">{
        totalPages := reader.NumPage()
        result := make(map[Language][]ClassifiedBlock)

        for pageNum := 1; pageNum &lt;= totalPages; pageNum++ </span><span class="cov0" title="0">{
                page := reader.Page(pageNum)
                blocks, err := page.ClassifyTextBlocks()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Process each block to detect language
                <span class="cov0" title="0">processor := NewMultiLangProcessor()
                for _, block := range blocks </span><span class="cov0" title="0">{
                        langInfo := processor.DetectLanguage(block.Text)
                        result[langInfo.Language] = append(result[langInfo.Language], block)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// IsEnglish checks if text is likely English
func (mlp *MultiLangProcessor) IsEnglish(text string) bool <span class="cov8" title="1">{
        langInfo := mlp.DetectLanguage(text)
        return langInfo.Language == English &amp;&amp; langInfo.Confidence &gt; 0.6
}</span>

// IsFrench checks if text is likely French
func (mlp *MultiLangProcessor) IsFrench(text string) bool <span class="cov8" title="1">{
        langInfo := mlp.DetectLanguage(text)
        return langInfo.Language == French &amp;&amp; langInfo.Confidence &gt; 0.6
}</span>

// IsGerman checks if text is likely German
func (mlp *MultiLangProcessor) IsGerman(text string) bool <span class="cov8" title="1">{
        langInfo := mlp.DetectLanguage(text)
        return langInfo.Language == German &amp;&amp; langInfo.Confidence &gt; 0.6
}</span>

// IsSpanish checks if text is likely Spanish
func (mlp *MultiLangProcessor) IsSpanish(text string) bool <span class="cov8" title="1">{
        langInfo := mlp.DetectLanguage(text)
        return langInfo.Language == Spanish &amp;&amp; langInfo.Confidence &gt; 0.6
}</span>

// GetSupportedLanguages returns the list of supported languages
func (mlp *MultiLangProcessor) GetSupportedLanguages() []Language <span class="cov8" title="1">{
        return []Language{English, French, German, Spanish}
}</span>

// GetLanguageName returns the full name of a language
func (mlp *MultiLangProcessor) GetLanguageName(lang Language) string <span class="cov8" title="1">{
        switch lang </span>{
        case English:<span class="cov8" title="1">
                return "English"</span>
        case French:<span class="cov8" title="1">
                return "French"</span>
        case German:<span class="cov8" title="1">
                return "German"</span>
        case Spanish:<span class="cov8" title="1">
                return "Spanish"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// GetLanguageConfidenceThreshold returns a confidence threshold for reliable detection
func (mlp *MultiLangProcessor) GetLanguageConfidenceThreshold() float64 <span class="cov8" title="1">{
        return 0.5
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "sort"
        "sync"
        "sync/atomic"
        "time"
        "unsafe"
)

// ====================  ====================

// AdaptiveCapacityEstimator 
// 
type AdaptiveCapacityEstimator struct {
        mu         sync.RWMutex
        history    []int
        maxSamples int
}

// NewAdaptiveCapacityEstimator 
func NewAdaptiveCapacityEstimator(maxSamples int) *AdaptiveCapacityEstimator <span class="cov8" title="1">{
        return &amp;AdaptiveCapacityEstimator{
                history:    make([]int, 0, maxSamples),
                maxSamples: maxSamples,
        }
}</span>

// Estimate 
func (ace *AdaptiveCapacityEstimator) Estimate(hint int) int <span class="cov8" title="1">{
        ace.mu.RLock()
        defer ace.mu.RUnlock()

        if len(ace.history) == 0 </span><span class="cov8" title="1">{
                // 1.3x
                return int(float64(hint) * 1.3)
        }</span>

        // P80P90P80
        <span class="cov8" title="1">sorted := make([]int, len(ace.history))
        copy(sorted, ace.history)
        sort.Ints(sorted)
        p80Index := int(float64(len(sorted)) * 0.8)
        if p80Index &gt;= len(sorted) </span><span class="cov0" title="0">{
                p80Index = len(sorted) - 1
        }</span>

        <span class="cov8" title="1">estimated := sorted[p80Index]
        // 
        if estimated &lt; hint </span><span class="cov0" title="0">{
                return int(float64(hint) * 1.3)
        }</span>
        <span class="cov8" title="1">return estimated</span>
}

// Record 
func (ace *AdaptiveCapacityEstimator) Record(actual int) <span class="cov8" title="1">{
        ace.mu.Lock()
        defer ace.mu.Unlock()

        ace.history = append(ace.history, actual)
        if len(ace.history) &gt; ace.maxSamples </span><span class="cov8" title="1">{
                // 
                ace.history = ace.history[1:]
        }</span>
}

// 
var (
        lineCapacityEstimator = NewAdaptiveCapacityEstimator(100)
        textCapacityEstimator = NewAdaptiveCapacityEstimator(100)
)

// BatchStringBuilder 
// 
type BatchStringBuilder struct {
        buf []byte
}

// NewBatchStringBuilder 
func NewBatchStringBuilder(texts []Text) *BatchStringBuilder <span class="cov8" title="1">{
        // 
        totalLen := 0
        for _, t := range texts </span><span class="cov8" title="1">{
                totalLen += len(t.S)
        }</span>

        // 
        <span class="cov8" title="1">capacity := totalLen + len(texts)*2

        return &amp;BatchStringBuilder{
                buf: make([]byte, 0, capacity),
        }</span>
}

// AppendTexts 
func (bsb *BatchStringBuilder) AppendTexts(texts []Text) string <span class="cov8" title="1">{
        for i := range texts </span><span class="cov8" title="1">{
                bsb.buf = append(bsb.buf, texts[i].S...)
                // 
                if i &lt; len(texts)-1 </span><span class="cov8" title="1">{
                        // needsSpace
                        bsb.buf = append(bsb.buf, ' ')
                }</span>
        }

        // unsafe.String
        <span class="cov8" title="1">return unsafe.String(unsafe.SliceData(bsb.buf), len(bsb.buf))</span>
}

// String 
func (bsb *BatchStringBuilder) String() string <span class="cov0" title="0">{
        return unsafe.String(unsafe.SliceData(bsb.buf), len(bsb.buf))
}</span>

// Reset 
func (bsb *BatchStringBuilder) Reset() <span class="cov0" title="0">{
        bsb.buf = bsb.buf[:0]
}</span>

// ====================  ====================

// KDNode KD
type KDNode struct {
        point []float64  //  [x, y]
        data  *TextBlock // 
        left  *KDNode
        right *KDNode
        axis  int // 0=x, 1=y
}

// KDTree KD
// O(log n)
type KDTree struct {
        root      *KDNode
        dimension int
}

// BuildKDTree KD
func BuildKDTree(blocks []*TextBlock) *KDTree <span class="cov8" title="1">{
        if len(blocks) == 0 </span><span class="cov0" title="0">{
                return &amp;KDTree{dimension: 2}
        }</span>

        // TextBlock
        <span class="cov8" title="1">points := make([]kdPoint, len(blocks))
        for i, block := range blocks </span><span class="cov8" title="1">{
                center := block.Center()
                points[i] = kdPoint{
                        coords: []float64{center.X, center.Y},
                        data:   block,
                }
        }</span>

        <span class="cov8" title="1">tree := &amp;KDTree{dimension: 2}
        tree.root = buildKDTreeRecursive(points, 0)
        return tree</span>
}

type kdPoint struct {
        coords []float64
        data   *TextBlock
}

func buildKDTreeRecursive(points []kdPoint, depth int) *KDNode <span class="cov8" title="1">{
        if len(points) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">axis := depth % 2 // 2Dxy

        // 
        sort.Slice(points, func(i, j int) bool </span><span class="cov8" title="1">{
                return points[i].coords[axis] &lt; points[j].coords[axis]
        }</span>)

        // 
        <span class="cov8" title="1">medianIdx := len(points) / 2

        return &amp;KDNode{
                point: points[medianIdx].coords,
                data:  points[medianIdx].data,
                axis:  axis,
                left:  buildKDTreeRecursive(points[:medianIdx], depth+1),
                right: buildKDTreeRecursive(points[medianIdx+1:], depth+1),
        }</span>
}

// RangeSearch 
func (tree *KDTree) RangeSearch(target []float64, radius float64) []*TextBlock <span class="cov8" title="1">{
        if tree.root == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var result []*TextBlock
        tree.rangeSearchRecursive(tree.root, target, radius, &amp;result)
        return result</span>
}

func (tree *KDTree) rangeSearchRecursive(node *KDNode, target []float64, radius float64, result *[]*TextBlock) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // 
        <span class="cov8" title="1">dist := euclideanDistance(node.point, target)
        if dist &lt;= radius </span><span class="cov8" title="1">{
                *result = append(*result, node.data)
        }</span>

        // 
        <span class="cov8" title="1">planeDist := target[node.axis] - node.point[node.axis]

        // 
        var nearChild, farChild *KDNode
        if planeDist &lt; 0 </span><span class="cov8" title="1">{
                nearChild = node.left
                farChild = node.right
        }</span> else<span class="cov8" title="1"> {
                nearChild = node.right
                farChild = node.left
        }</span>

        // 
        <span class="cov8" title="1">tree.rangeSearchRecursive(nearChild, target, radius, result)

        // 
        if planeDist*planeDist &lt;= radius*radius </span><span class="cov8" title="1">{
                tree.rangeSearchRecursive(farChild, target, radius, result)
        }</span>
}

func euclideanDistance(p1, p2 []float64) float64 <span class="cov8" title="1">{
        dx := p1[0] - p2[0]
        dy := p1[1] - p2[1]
        return dx*dx + dy*dy // sqrt
}</span>

// ClusterTextBlocksOptimized KD
func ClusterTextBlocksOptimized(texts []Text) []*TextBlock <span class="cov0" title="0">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 
        <span class="cov0" title="0">var totalFontSize float64
        for _, t := range texts </span><span class="cov0" title="0">{
                totalFontSize += t.FontSize
        }</span>
        <span class="cov0" title="0">avgFontSize := totalFontSize / float64(len(texts))
        distThreshold := avgFontSize * 2.0

        // 
        blocks := make([]*TextBlock, len(texts))
        for i, t := range texts </span><span class="cov0" title="0">{
                blocks[i] = &amp;TextBlock{
                        Texts:       []Text{t},
                        MinX:        t.X,
                        MaxX:        t.X + t.W,
                        MinY:        t.Y,
                        MaxY:        t.Y + t.FontSize,
                        AvgFontSize: t.FontSize,
                }
        }</span>

        // KD
        <span class="cov0" title="0">kdtree := BuildKDTree(blocks)

        // 
        parent := make([]int, len(blocks))
        for i := range parent </span><span class="cov0" title="0">{
                parent[i] = i
        }</span>

        <span class="cov0" title="0">var find func(int) int
        find = func(x int) int </span><span class="cov0" title="0">{
                if parent[x] != x </span><span class="cov0" title="0">{
                        parent[x] = find(parent[x]) // 
                }</span>
                <span class="cov0" title="0">return parent[x]</span>
        }

        <span class="cov0" title="0">union := func(x, y int) </span><span class="cov0" title="0">{
                px, py := find(x), find(y)
                if px != py </span><span class="cov0" title="0">{
                        parent[px] = py
                }</span>
        }

        // 
        <span class="cov0" title="0">for i, block := range blocks </span><span class="cov0" title="0">{
                center := block.Center()
                neighbors := kdtree.RangeSearch([]float64{center.X, center.Y}, distThreshold*distThreshold)

                for _, neighbor := range neighbors </span><span class="cov0" title="0">{
                        // neighborblocks
                        for j, b := range blocks </span><span class="cov0" title="0">{
                                if b == neighbor &amp;&amp; i != j </span><span class="cov0" title="0">{
                                        if shouldMergeClusters(block, neighbor, distThreshold) </span><span class="cov0" title="0">{
                                                union(i, j)
                                        }</span>
                                }
                        }
                }
        }

        // 
        <span class="cov0" title="0">clusterMap := make(map[int][]*TextBlock)
        for i, block := range blocks </span><span class="cov0" title="0">{
                root := find(i)
                clusterMap[root] = append(clusterMap[root], block)
        }</span>

        // 
        <span class="cov0" title="0">result := make([]*TextBlock, 0, len(clusterMap))
        for _, cluster := range clusterMap </span><span class="cov0" title="0">{
                merged := mergeTextBlocks(cluster)
                result = append(result, merged)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func mergeTextBlocks(blocks []*TextBlock) *TextBlock <span class="cov0" title="0">{
        if len(blocks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(blocks) == 1 </span><span class="cov0" title="0">{
                return blocks[0]
        }</span>

        <span class="cov0" title="0">merged := &amp;TextBlock{
                Texts:       make([]Text, 0),
                MinX:        blocks[0].MinX,
                MaxX:        blocks[0].MaxX,
                MinY:        blocks[0].MinY,
                MaxY:        blocks[0].MaxY,
                AvgFontSize: 0,
        }

        totalFontSize := 0.0
        totalTexts := 0

        for _, block := range blocks </span><span class="cov0" title="0">{
                merged.Texts = append(merged.Texts, block.Texts...)
                if block.MinX &lt; merged.MinX </span><span class="cov0" title="0">{
                        merged.MinX = block.MinX
                }</span>
                <span class="cov0" title="0">if block.MaxX &gt; merged.MaxX </span><span class="cov0" title="0">{
                        merged.MaxX = block.MaxX
                }</span>
                <span class="cov0" title="0">if block.MinY &lt; merged.MinY </span><span class="cov0" title="0">{
                        merged.MinY = block.MinY
                }</span>
                <span class="cov0" title="0">if block.MaxY &gt; merged.MaxY </span><span class="cov0" title="0">{
                        merged.MaxY = block.MaxY
                }</span>
                <span class="cov0" title="0">totalFontSize += block.AvgFontSize * float64(len(block.Texts))
                totalTexts += len(block.Texts)</span>
        }

        <span class="cov0" title="0">if totalTexts &gt; 0 </span><span class="cov0" title="0">{
                merged.AvgFontSize = totalFontSize / float64(totalTexts)
        }</span>

        <span class="cov0" title="0">return merged</span>
}

// ====================  ====================

// WorkStealingScheduler 
// goroutine
type WorkStealingScheduler struct {
        workers     []*Worker
        globalQueue chan Task
        numWorkers  int
        wg          sync.WaitGroup
        stop        chan struct{}
}

// Worker 
type Worker struct {
        id         int
        localQueue chan Task
        scheduler  *WorkStealingScheduler
        stealing   atomic.Bool // 
}

// Task 
type Task interface {
        Execute() error
}

// NewWorkStealingScheduler 
func NewWorkStealingScheduler(numWorkers int) *WorkStealingScheduler <span class="cov8" title="1">{
        if numWorkers &lt;= 0 </span><span class="cov0" title="0">{
                numWorkers = 4
        }</span>

        <span class="cov8" title="1">scheduler := &amp;WorkStealingScheduler{
                workers:     make([]*Worker, numWorkers),
                globalQueue: make(chan Task, numWorkers*10),
                numWorkers:  numWorkers,
                stop:        make(chan struct{}),
        }

        // worker
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                scheduler.workers[i] = &amp;Worker{
                        id:         i,
                        localQueue: make(chan Task, 100),
                        scheduler:  scheduler,
                }
        }</span>

        <span class="cov8" title="1">return scheduler</span>
}

// Start 
func (wss *WorkStealingScheduler) Start() <span class="cov8" title="1">{
        for _, worker := range wss.workers </span><span class="cov8" title="1">{
                wss.wg.Add(1)
                go worker.run()
        }</span>
}

// Submit 
func (wss *WorkStealingScheduler) Submit(task Task) <span class="cov8" title="1">{
        // worker
        select </span>{
        case wss.globalQueue &lt;- task:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                // 
                task.Execute()</span>
        }
}

// Stop 
func (wss *WorkStealingScheduler) Stop() <span class="cov8" title="1">{
        close(wss.stop)
        wss.wg.Wait()
}</span>

// Wait 
func (wss *WorkStealingScheduler) Wait() <span class="cov8" title="1">{
        // 
        for </span><span class="cov8" title="1">{
                allEmpty := true
                if len(wss.globalQueue) &gt; 0 </span><span class="cov8" title="1">{
                        allEmpty = false
                }</span>
                <span class="cov8" title="1">for _, worker := range wss.workers </span><span class="cov8" title="1">{
                        if len(worker.localQueue) &gt; 0 </span><span class="cov0" title="0">{
                                allEmpty = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if allEmpty </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">time.Sleep(10 * time.Millisecond)</span>
        }
}

func (w *Worker) run() <span class="cov8" title="1">{
        defer w.scheduler.wg.Done()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-w.scheduler.stop:<span class="cov8" title="1">
                        return</span>

                case task := &lt;-w.localQueue:<span class="cov0" title="0">
                        // 
                        task.Execute()</span>

                case task := &lt;-w.scheduler.globalQueue:<span class="cov8" title="1">
                        // 
                        task.Execute()</span>

                default:<span class="cov8" title="1">
                        // worker
                        if task := w.steal(); task != nil </span><span class="cov0" title="0">{
                                task.Execute()
                        }</span> else<span class="cov8" title="1"> {
                                // 
                                time.Sleep(100 * time.Microsecond)
                        }</span>
                }
        }
}

func (w *Worker) steal() Task <span class="cov8" title="1">{
        if w.stealing.Load() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">w.stealing.Store(true)
        defer w.stealing.Store(false)

        // worker
        for i := 0; i &lt; w.scheduler.numWorkers; i++ </span><span class="cov8" title="1">{
                if i == w.id </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">victim := w.scheduler.workers[i]
                select </span>{
                case task := &lt;-victim.localQueue:<span class="cov0" title="0">
                        return task</span>
                default:<span class="cov8" title="1"></span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// ====================  ====================

// MultiLevelCache 
type MultiLevelCache struct {
        l1    sync.Map     // L1: 
        l2    *ResultCache // L2: LRU
        l3    *ResultCache // L3: 
        stats struct {
                l1Hits   atomic.Uint64
                l2Hits   atomic.Uint64
                l3Hits   atomic.Uint64
                misses   atomic.Uint64
                prefetch atomic.Uint64
        }
}

// NewMultiLevelCache 
func NewMultiLevelCache() *MultiLevelCache <span class="cov8" title="1">{
        return &amp;MultiLevelCache{
                l2: NewResultCache(10*1024*1024, 5*time.Minute, "LRU"),   // 10MB, 5min
                l3: NewResultCache(100*1024*1024, 30*time.Minute, "LFU"), // 100MB, 30min
        }
}</span>

// Get 
func (mlc *MultiLevelCache) Get(key string) (interface{}, bool) <span class="cov8" title="1">{
        // L1
        if val, ok := mlc.l1.Load(key); ok </span><span class="cov8" title="1">{
                mlc.stats.l1Hits.Add(1)
                return val, true
        }</span>

        // L2
        <span class="cov8" title="1">if val, ok := mlc.l2.Get(key); ok </span><span class="cov0" title="0">{
                mlc.stats.l2Hits.Add(1)
                // L1
                mlc.l1.Store(key, val)
                return val, true
        }</span>

        // L3
        <span class="cov8" title="1">if val, ok := mlc.l3.Get(key); ok </span><span class="cov0" title="0">{
                mlc.stats.l3Hits.Add(1)
                // L2
                mlc.l2.Put(key, val)
                return val, true
        }</span>

        <span class="cov8" title="1">mlc.stats.misses.Add(1)
        return nil, false</span>
}

// Put 
func (mlc *MultiLevelCache) Put(key string, value interface{}) <span class="cov8" title="1">{
        // L1
        mlc.l1.Store(key, value)
        // L2
        mlc.l2.Put(key, value)
}</span>

// Prefetch 
func (mlc *MultiLevelCache) Prefetch(keys []string) <span class="cov0" title="0">{
        mlc.stats.prefetch.Add(uint64(len(keys)))
        // 
        go func() </span><span class="cov0" title="0">{
                for _, key := range keys </span><span class="cov0" title="0">{
                        mlc.Get(key)
                        // 
                }</span>
        }()
}

// Stats 
func (mlc *MultiLevelCache) Stats() map[string]uint64 <span class="cov8" title="1">{
        total := mlc.stats.l1Hits.Load() + mlc.stats.l2Hits.Load() +
                mlc.stats.l3Hits.Load() + mlc.stats.misses.Load()

        hitRate := float64(0)
        if total &gt; 0 </span><span class="cov8" title="1">{
                hits := mlc.stats.l1Hits.Load() + mlc.stats.l2Hits.Load() + mlc.stats.l3Hits.Load()
                hitRate = float64(hits) / float64(total) * 100
        }</span>

        <span class="cov8" title="1">return map[string]uint64{
                "l1_hits":  mlc.stats.l1Hits.Load(),
                "l2_hits":  mlc.stats.l2Hits.Load(),
                "l3_hits":  mlc.stats.l3Hits.Load(),
                "misses":   mlc.stats.misses.Load(),
                "prefetch": mlc.stats.prefetch.Load(),
                "hit_rate": uint64(hitRate),
        }</span>
}

// ====================  ====================

// PerformanceMetrics 
type PerformanceMetrics struct {
        ExtractDuration atomic.Int64 // 
        ParseDuration   atomic.Int64
        SortDuration    atomic.Int64
        TotalAllocs     atomic.Uint64
        BytesAllocated  atomic.Uint64
        GoroutineCount  atomic.Int32
        CacheHitRate    atomic.Uint64 //  * 100
}

// RecordExtractDuration 
func (pm *PerformanceMetrics) RecordExtractDuration(d time.Duration) <span class="cov8" title="1">{
        pm.ExtractDuration.Store(int64(d))
}</span>

// RecordAllocation 
func (pm *PerformanceMetrics) RecordAllocation(bytes uint64) <span class="cov8" title="1">{
        pm.TotalAllocs.Add(1)
        pm.BytesAllocated.Add(bytes)
}</span>

// GetMetrics 
func (pm *PerformanceMetrics) GetMetrics() map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "extract_duration_ms": float64(pm.ExtractDuration.Load()) / 1e6,
                "parse_duration_ms":   float64(pm.ParseDuration.Load()) / 1e6,
                "sort_duration_ms":    float64(pm.SortDuration.Load()) / 1e6,
                "total_allocs":        pm.TotalAllocs.Load(),
                "bytes_allocated":     pm.BytesAllocated.Load(),
                "goroutine_count":     pm.GoroutineCount.Load(),
                "cache_hit_rate":      float64(pm.CacheHitRate.Load()) / 100.0,
        }
}</span>

// 
var GlobalMetrics = &amp;PerformanceMetrics{}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "math"
        "math/bits"
        "runtime"
        "sync"
        "sync/atomic"
        "unsafe"
)

// ====================  ====================

// 1.  - 
type SizedPool struct {
        pools [8]*sync.Pool
        sizes [8]int
}

func NewSizedPool() *SizedPool <span class="cov0" title="0">{
        sp := &amp;SizedPool{
                sizes: [8]int{16, 32, 64, 128, 256, 512, 1024, 4096},
        }

        for i := range sp.pools </span><span class="cov0" title="0">{
                size := sp.sizes[i]
                sp.pools[i] = &amp;sync.Pool{
                        New: func() interface{} </span><span class="cov0" title="0">{
                                return make([]byte, 0, size)
                        }</span>,
                }
        }
        <span class="cov0" title="0">return sp</span>
}

func (sp *SizedPool) Get(size int) []byte <span class="cov0" title="0">{
        // 
        idx := bits.Len(uint(size)) - 5
        if idx &lt; 0 </span><span class="cov0" title="0">{
                idx = 0
        }</span> else<span class="cov0" title="0"> if idx &gt;= len(sp.pools) </span><span class="cov0" title="0">{
                idx = len(sp.pools) - 1
        }</span>

        <span class="cov0" title="0">buf := sp.pools[idx].Get().([]byte)
        return buf[:0]</span>
}

func (sp *SizedPool) Put(bufPtr *[]byte) <span class="cov0" title="0">{
        size := cap(*bufPtr)
        idx := bits.Len(uint(size)) - 5
        if idx &lt; 0 </span><span class="cov0" title="0">{
                idx = 0
        }</span> else<span class="cov0" title="0"> if idx &gt;= len(sp.pools) </span><span class="cov0" title="0">{
                idx = len(sp.pools) - 1
        }</span>

        // Return buffer to appropriate pool (slice to zero length)
        <span class="cov0" title="0">*bufPtr = (*bufPtr)[:0]
        sp.pools[idx].Put(bufPtr)</span>
}

// 2. 
type ZeroCopyBuilder struct {
        buf []byte
}

func NewZeroCopyBuilder(cap int) *ZeroCopyBuilder <span class="cov0" title="0">{
        return &amp;ZeroCopyBuilder{
                buf: make([]byte, 0, cap),
        }
}</span>

func (b *ZeroCopyBuilder) WriteString(s string) <span class="cov0" title="0">{
        b.buf = append(b.buf, s...)
}</span>

func (b *ZeroCopyBuilder) WriteByte(c byte) error <span class="cov0" title="0">{
        b.buf = append(b.buf, c)
        return nil
}</span>

// UnsafeString buffer
func (b *ZeroCopyBuilder) UnsafeString() string <span class="cov0" title="0">{
        return unsafe.String(unsafe.SliceData(b.buf), len(b.buf))
}</span>

func (b *ZeroCopyBuilder) Reset() <span class="cov0" title="0">{
        b.buf = b.buf[:0]
}</span>

// 3. Lock-free -
type LockFreeRingBuffer struct {
        buffer []interface{}
        mask   uint64
        head   uint64   // 
        tail   uint64   // 
        _      [56]byte // cache line padding to prevent false sharing
}

func NewLockFreeRingBuffer(size int) *LockFreeRingBuffer <span class="cov0" title="0">{
        // size2
        size = 1 &lt;&lt; bits.Len(uint(size-1))

        return &amp;LockFreeRingBuffer{
                buffer: make([]interface{}, size),
                mask:   uint64(size - 1),
        }
}</span>

func (rb *LockFreeRingBuffer) Push(item interface{}) bool <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                head := atomic.LoadUint64(&amp;rb.head)
                tail := atomic.LoadUint64(&amp;rb.tail)

                // 
                if head-tail &gt;= uint64(len(rb.buffer)) </span><span class="cov0" title="0">{
                        return false
                }</span>

                // CAShead
                <span class="cov0" title="0">if atomic.CompareAndSwapUint64(&amp;rb.head, head, head+1) </span><span class="cov0" title="0">{
                        rb.buffer[head&amp;rb.mask] = item
                        return true
                }</span>
        }
}

func (rb *LockFreeRingBuffer) Pop() (interface{}, bool) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                tail := atomic.LoadUint64(&amp;rb.tail)
                head := atomic.LoadUint64(&amp;rb.head)

                // 
                if tail &gt;= head </span><span class="cov0" title="0">{
                        return nil, false
                }</span>

                // CAStail
                <span class="cov0" title="0">if atomic.CompareAndSwapUint64(&amp;rb.tail, tail, tail+1) </span><span class="cov0" title="0">{
                        item := rb.buffer[tail&amp;rb.mask]
                        return item, true
                }</span>
        }
}

// 4. 
type CacheLinePadded struct {
        value uint64
        _     [7]uint64 // 64
}

type CacheLineAlignedCounter struct {
        counters []CacheLinePadded
}

func NewCacheLineAlignedCounter(n int) *CacheLineAlignedCounter <span class="cov0" title="0">{
        return &amp;CacheLineAlignedCounter{
                counters: make([]CacheLinePadded, n),
        }
}</span>

func (c *CacheLineAlignedCounter) Add(idx int, delta uint64) <span class="cov0" title="0">{
        atomic.AddUint64(&amp;c.counters[idx].value, delta)
}</span>

func (c *CacheLineAlignedCounter) Get(idx int) uint64 <span class="cov0" title="0">{
        return atomic.LoadUint64(&amp;c.counters[idx].value)
}</span>

// 5. Work-Stealing Deque (Chase-Lev)
type WSDeque struct {
        buffer atomic.Value // *circularArray
        top    atomic.Int64
        bottom atomic.Int64
}

type circularArray struct {
        data []WSTask
        size int64
}

type WSTask interface {
        Execute()
}

func NewWSDeque(size int) *WSDeque <span class="cov0" title="0">{
        d := &amp;WSDeque{}
        d.buffer.Store(&amp;circularArray{
                data: make([]WSTask, size),
                size: int64(size),
        })
        d.top.Store(0)
        d.bottom.Store(0)
        return d
}</span>

// PushBottom - owner
func (d *WSDeque) PushBottom(task WSTask) <span class="cov0" title="0">{
        b := d.bottom.Load()
        t := d.top.Load()
        arr := d.buffer.Load().(*circularArray)

        size := b - t
        if size &gt;= arr.size </span><span class="cov0" title="0">{
                // 
                newArr := &amp;circularArray{
                        data: make([]WSTask, arr.size*2),
                        size: arr.size * 2,
                }
                for i := t; i &lt; b; i++ </span><span class="cov0" title="0">{
                        newArr.data[i%newArr.size] = arr.data[i%arr.size]
                }</span>
                <span class="cov0" title="0">d.buffer.Store(newArr)
                arr = newArr</span>
        }

        <span class="cov0" title="0">arr.data[b%arr.size] = task
        d.bottom.Store(b + 1)</span>
}

// PopBottom - ownerLIFO
func (d *WSDeque) PopBottom() WSTask <span class="cov0" title="0">{
        b := d.bottom.Load() - 1
        d.bottom.Store(b)

        arr := d.buffer.Load().(*circularArray)
        t := d.top.Load()

        if b &lt; t </span><span class="cov0" title="0">{
                d.bottom.Store(t)
                return nil
        }</span>

        <span class="cov0" title="0">task := arr.data[b%arr.size]
        if b &gt; t </span><span class="cov0" title="0">{
                return task
        }</span>

        // CAS
        <span class="cov0" title="0">if !d.top.CompareAndSwap(t, t+1) </span><span class="cov0" title="0">{
                task = nil
        }</span>
        <span class="cov0" title="0">d.bottom.Store(t + 1)
        return task</span>
}

// Steal - FIFO
func (d *WSDeque) Steal() WSTask <span class="cov0" title="0">{
        t := d.top.Load()
        b := d.bottom.Load()

        if t &gt;= b </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">arr := d.buffer.Load().(*circularArray)
        task := arr.data[t%arr.size]

        if !d.top.CompareAndSwap(t, t+1) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return task</span>
}

// 6. Work-Stealing
type WorkStealingExecutor struct {
        workers    []*WSWorker
        numWorkers int
        stopped    atomic.Bool
}

type WSWorker struct {
        id    int
        deque *WSDeque
        pool  *WorkStealingExecutor
}

func NewWorkStealingExecutor(numWorkers int) *WorkStealingExecutor <span class="cov0" title="0">{
        if numWorkers &lt;= 0 </span><span class="cov0" title="0">{
                numWorkers = runtime.NumCPU()
        }</span>

        <span class="cov0" title="0">pool := &amp;WorkStealingExecutor{
                workers:    make([]*WSWorker, numWorkers),
                numWorkers: numWorkers,
        }

        for i := 0; i &lt; numWorkers; i++ </span><span class="cov0" title="0">{
                pool.workers[i] = &amp;WSWorker{
                        id:    i,
                        deque: NewWSDeque(256),
                        pool:  pool,
                }
        }</span>

        <span class="cov0" title="0">return pool</span>
}

func (p *WorkStealingExecutor) Start() <span class="cov0" title="0">{
        for _, w := range p.workers </span><span class="cov0" title="0">{
                go w.run()
        }</span>
}

func (p *WorkStealingExecutor) Stop() <span class="cov0" title="0">{
        p.stopped.Store(true)
}</span>

func (p *WorkStealingExecutor) Submit(task WSTask) <span class="cov0" title="0">{
        // worker
        idx := runtime.GOMAXPROCS(0) % p.numWorkers
        p.workers[idx].deque.PushBottom(task)
}</span>

func (w *WSWorker) run() <span class="cov0" title="0">{
        for !w.pool.stopped.Load() </span><span class="cov0" title="0">{
                // 1. dequeLIFO
                if task := w.deque.PopBottom(); task != nil </span><span class="cov0" title="0">{
                        task.Execute()
                        continue</span>
                }

                // 2. worker
                <span class="cov0" title="0">victim := (w.id + 1 + runtime.GOMAXPROCS(0)) % w.pool.numWorkers
                if task := w.pool.workers[victim].deque.Steal(); task != nil </span><span class="cov0" title="0">{
                        task.Execute()
                        continue</span>
                }

                // 3. CPU
                <span class="cov0" title="0">runtime.Gosched()</span>
        }
}

// 7. Radix Sort 
func RadixSortFloat64(values []float64) <span class="cov0" title="0">{
        if len(values) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        // float64uint64
        <span class="cov0" title="0">keys := make([]uint64, len(values))
        for i, v := range values </span><span class="cov0" title="0">{
                bits := math.Float64bits(v)
                // 1
                mask := -uint64(int64(bits)&gt;&gt;63) | 0x8000000000000000
                keys[i] = bits ^ mask
        }</span>

        // Radix sort
        <span class="cov0" title="0">const radix = 256
        buckets := make([][]int, radix)
        for i := range buckets </span><span class="cov0" title="0">{
                buckets[i] = make([]int, 0, len(values)/radix)
        }</span>

        <span class="cov0" title="0">for shift := uint(0); shift &lt; 64; shift += 8 </span><span class="cov0" title="0">{
                // 
                for i := range buckets </span><span class="cov0" title="0">{
                        buckets[i] = buckets[i][:0]
                }</span>

                // 
                <span class="cov0" title="0">for i, k := range keys </span><span class="cov0" title="0">{
                        bucket := (k &gt;&gt; shift) &amp; 0xFF
                        buckets[bucket] = append(buckets[bucket], i)
                }</span>

                // 
                <span class="cov0" title="0">idx := 0
                for _, bucket := range buckets </span><span class="cov0" title="0">{
                        for _, i := range bucket </span><span class="cov0" title="0">{
                                values[idx] = values[i]
                                keys[idx] = keys[i]
                                idx++
                        }</span>
                }
        }
}

// 8. Hilbert
func HilbertXYToIndex(x, y, order uint32) uint64 <span class="cov0" title="0">{
        var index uint64
        var rx, ry, s uint32
        n := uint32(1 &lt;&lt; order)

        for s = n / 2; s &gt; 0; s /= 2 </span><span class="cov0" title="0">{
                rx = (x &amp; s) &gt;&gt; (bits.TrailingZeros32(s))
                ry = (y &amp; s) &gt;&gt; (bits.TrailingZeros32(s))

                index += uint64(s * s * ((3 * rx) ^ ry))

                // 
                if ry == 0 </span><span class="cov0" title="0">{
                        if rx == 1 </span><span class="cov0" title="0">{
                                x = n - 1 - x
                                y = n - 1 - y
                        }</span>
                        <span class="cov0" title="0">x, y = y, x</span>
                }
        }

        <span class="cov0" title="0">return index</span>
}

// 9. SIMD
func BatchCompareFloat64(a, b []float64, threshold float64) []bool <span class="cov0" title="0">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                panic("length mismatch")</span>
        }

        <span class="cov0" title="0">result := make([]bool, len(a))

        // AVX24float64
        // 
        i := 0
        for ; i+4 &lt;= len(a); i += 4 </span><span class="cov0" title="0">{
                // AVX2: 4
                result[i] = math.Abs(a[i]-b[i]) &lt; threshold
                result[i+1] = math.Abs(a[i+1]-b[i+1]) &lt; threshold
                result[i+2] = math.Abs(a[i+2]-b[i+2]) &lt; threshold
                result[i+3] = math.Abs(a[i+3]-b[i+3]) &lt; threshold
        }</span>

        // 
        <span class="cov0" title="0">for ; i &lt; len(a); i++ </span><span class="cov0" title="0">{
                result[i] = math.Abs(a[i]-b[i]) &lt; threshold
        }</span>

        <span class="cov0" title="0">return result</span>
}

// 10. GC
type MemoryArena struct {
        chunks    [][]byte
        chunkSize int
        offset    int
        mu        sync.Mutex
}

func NewMemoryArena(chunkSize int) *MemoryArena <span class="cov0" title="0">{
        return &amp;MemoryArena{
                chunkSize: chunkSize,
                chunks:    make([][]byte, 0, 4),
        }
}</span>

func (a *MemoryArena) Alloc(size int) []byte <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        if size &gt; a.chunkSize </span><span class="cov0" title="0">{
                // 
                return make([]byte, size)
        }</span>

        // chunk
        <span class="cov0" title="0">if len(a.chunks) == 0 || a.offset+size &gt; a.chunkSize </span><span class="cov0" title="0">{
                // chunk
                a.chunks = append(a.chunks, make([]byte, a.chunkSize))
                a.offset = 0
        }</span>

        <span class="cov0" title="0">chunk := a.chunks[len(a.chunks)-1]
        ptr := chunk[a.offset : a.offset+size]
        a.offset += size

        return ptr</span>
}

func (a *MemoryArena) Reset() <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        a.chunks = a.chunks[:0]
        a.offset = 0
}</span>

// 
func ExampleOptimizations() <span class="cov0" title="0">{
        // 1. 
        pool := NewSizedPool()
        buf := pool.Get(100)
        // ... buf
        pool.Put(&amp;buf)

        // 2. 
        builder := NewZeroCopyBuilder(1024)
        builder.WriteString("Hello")
        builder.WriteString(" World")
        str := builder.UnsafeString() // 
        _ = str

        // 3. Work-stealing
        executor := NewWorkStealingExecutor(4)
        executor.Start()
        defer executor.Stop()

        // 
        task := &amp;wsSimpleTask{fn: func() </span>{<span class="cov0" title="0">
                // 
        }</span>}
        <span class="cov0" title="0">executor.Submit(task)

        // 4. Radix sort
        values := []float64{3.14, 1.41, 2.71, 1.73}
        RadixSortFloat64(values)

        // 5. Hilbert
        idx := HilbertXYToIndex(10, 20, 8)
        _ = idx</span>
}

// WSTask
type wsSimpleTask struct {
        fn func()
}

func (t *wsSimpleTask) Execute() <span class="cov0" title="0">{
        t.fn()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "fmt"
        "math"
        "sort"
        "strings"
)

// OptimizedGetPlainText returns the page's all text using optimized string building.
// This version uses object pools and pre-allocation to reduce memory allocations.
func (p Page) OptimizedGetPlainText(fonts map[string]*Font) (string, error) <span class="cov0" title="0">{
        // Handle in case the content page is empty
        if p.V.IsNull() || p.V.Key("Contents").Kind() == Null </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">content, err := p.contentWithFonts(fonts)
        if err != nil </span><span class="cov0" title="0">{
                return "", wrapError("extract page content", err)
        }</span>

        <span class="cov0" title="0">return optimizedTextRunsToPlain(content.Text), nil</span>
}

// optimizedTextRunsToPlain converts text runs to plain text with optimized memory usage
func optimizedTextRunsToPlain(texts []Text) string <span class="cov0" title="0">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // work on a copy so callers of Content() are not affected by ordering changes
        <span class="cov0" title="0">runs := append([]Text(nil), texts...)
        sort.Sort(TextVertical(runs))

        const lineTolerance = 2.0
        // P0: 
        lineCapacity := lineCapacityEstimator.Estimate(len(runs)/5 + 1)
        textCapacity := textCapacityEstimator.Estimate(10)
        lines := make([][]Text, 0, lineCapacity)
        currentLine := make([]Text, 0, textCapacity)
        var currentCoord float64

        for i, t := range runs </span><span class="cov0" title="0">{
                lineCoord := effectiveLineCoord(t)
                if i == 0 || math.Abs(lineCoord-currentCoord) &lt;= lineTolerance </span><span class="cov0" title="0">{
                        currentLine = append(currentLine, t)
                        if len(currentLine) == 1 </span><span class="cov0" title="0">{
                                currentCoord = lineCoord
                        }</span> else<span class="cov0" title="0"> {
                                currentCoord = (currentCoord*float64(len(currentLine)-1) + lineCoord) / float64(len(currentLine))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if len(currentLine) &gt; 0 </span><span class="cov0" title="0">{
                        sort.Slice(currentLine, func(i, j int) bool </span><span class="cov0" title="0">{
                                return effectiveOrderCoord(currentLine[i]) &lt; effectiveOrderCoord(currentLine[j])
                        }</span>)
                        <span class="cov0" title="0">lines = append(lines, currentLine)</span>
                }
                <span class="cov0" title="0">currentLine = make([]Text, 0, 10)
                currentLine = append(currentLine, t)
                currentCoord = lineCoord</span>
        }

        <span class="cov0" title="0">if len(currentLine) &gt; 0 </span><span class="cov0" title="0">{
                sort.Slice(currentLine, func(i, j int) bool </span><span class="cov0" title="0">{
                        return effectiveOrderCoord(currentLine[i]) &lt; effectiveOrderCoord(currentLine[j])
                }</span>)
                <span class="cov0" title="0">lines = append(lines, currentLine)</span>
        }

        // P0: 
        <span class="cov0" title="0">totalChars := 0
        for _, line := range lines </span><span class="cov0" title="0">{
                for _, t := range line </span><span class="cov0" title="0">{
                        totalChars += len(t.S)
                }</span>
        }
        <span class="cov0" title="0">estimatedSize := totalChars + len(lines)*2 // 

        builder := GetBuilder()
        defer PutBuilder(builder)

        // Pre-grow to avoid multiple allocations
        builder.Grow(estimatedSize)

        for i, line := range lines </span><span class="cov0" title="0">{
                optimizedAppendLine(builder, line)
                if i &lt; len(lines)-1 </span><span class="cov0" title="0">{
                        builder.WriteByte('\n')
                }</span>
        }

        <span class="cov0" title="0">result := builder.String()

        // P0: 
        lineCapacityEstimator.Record(len(lines))

        return strings.TrimRight(result, "\n")</span>
}

// optimizedAppendLine appends a line of text with space detection (optimized version)
//
//go:inline
func optimizedAppendLine(builder *strings.Builder, line []Text) <span class="cov0" title="0">{
        const minGap = 0.5
        var prevEnd float64
        hasPrev := false
        allVertical := true
        for _, t := range line </span><span class="cov0" title="0">{
                if !t.Vertical </span><span class="cov0" title="0">{
                        allVertical = false
                        break</span>
                }
        }

        <span class="cov0" title="0">for _, t := range line </span><span class="cov0" title="0">{
                if hasPrev </span><span class="cov0" title="0">{
                        var gap float64
                        if allVertical </span><span class="cov0" title="0">{
                                gap = math.Abs(t.Y - prevEnd)
                        }</span> else<span class="cov0" title="0"> {
                                gap = t.X - prevEnd
                        }</span>
                        <span class="cov0" title="0">spaceThreshold := math.Max(t.FontSize*0.2, minGap)
                        if gap &gt; spaceThreshold &amp;&amp; !allVertical </span><span class="cov0" title="0">{
                                builder.WriteByte(' ')
                        }</span>
                }
                <span class="cov0" title="0">builder.WriteString(t.S)
                if allVertical </span><span class="cov0" title="0">{
                        prevEnd = t.Y - t.W
                }</span> else<span class="cov0" title="0"> {
                        prevEnd = t.X + t.W
                }</span>
                <span class="cov0" title="0">hasPrev = true</span>
        }
}

// OptimizedGetTextByRow returns the page's all text grouped by rows using optimized allocation
func (p Page) OptimizedGetTextByRow() (Rows, error) <span class="cov0" title="0">{
        var result Rows
        var err error

        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        result = Rows{}
                        if e, ok := r.(error); ok </span><span class="cov0" title="0">{
                                err = wrapError("extract text by row", e)
                        }</span> else<span class="cov0" title="0"> {
                                err = wrapError("extract text by row", fmt.Errorf("%v", r))
                        }</span>
                }
        }()

        // Pre-allocate result with reasonable capacity
        <span class="cov0" title="0">result = make(Rows, 0, 20)

        showText := func(enc TextEncoding, currentX, currentY float64, s string) </span><span class="cov0" title="0">{
                // Use strings.Builder from pool for text accumulation
                builder := GetBuilder()
                defer PutBuilder(builder)

                for _, ch := range enc.Decode(s) </span><span class="cov0" title="0">{
                        builder.WriteRune(ch)
                }</span>

                <span class="cov0" title="0">text := Text{
                        S: builder.String(),
                        X: currentX,
                        Y: currentY,
                }

                var currentRow *Row
                rowFound := false
                rowPosition := int64(currentY)

                // Linear search is acceptable for small result sets
                // For larger sets, consider using a map
                for _, row := range result </span><span class="cov0" title="0">{
                        if rowPosition == row.Position </span><span class="cov0" title="0">{
                                currentRow = row
                                rowFound = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !rowFound </span><span class="cov0" title="0">{
                        currentRow = &amp;Row{
                                Position: rowPosition,
                                Content:  make(TextHorizontal, 0, 10), // Pre-allocate
                        }
                        result = append(result, currentRow)
                }</span>

                <span class="cov0" title="0">currentRow.Content = append(currentRow.Content, text)</span>
        }

        <span class="cov0" title="0">p.walkTextBlocks(showText)

        for _, row := range result </span><span class="cov0" title="0">{
                sort.Sort(row.Content)
        }</span>

        <span class="cov0" title="0">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                return result[i].Position &gt; result[j].Position
        }</span>)

        <span class="cov0" title="0">return result, err</span>
}

// OptimizedGetTextByColumn returns the page's all text grouped by column using optimized allocation
func (p Page) OptimizedGetTextByColumn() (Columns, error) <span class="cov0" title="0">{
        var result Columns
        var err error

        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        result = Columns{}
                        if e, ok := r.(error); ok </span><span class="cov0" title="0">{
                                err = wrapError("extract text by column", e)
                        }</span> else<span class="cov0" title="0"> {
                                err = wrapError("extract text by column", fmt.Errorf("%v", r))
                        }</span>
                }
        }()

        // Pre-allocate result with reasonable capacity
        <span class="cov0" title="0">result = make(Columns, 0, 5) // Estimate ~5 columns max

        showText := func(enc TextEncoding, currentX, currentY float64, s string) </span><span class="cov0" title="0">{
                // Use strings.Builder from pool
                builder := GetBuilder()
                defer PutBuilder(builder)

                for _, ch := range enc.Decode(s) </span><span class="cov0" title="0">{
                        builder.WriteRune(ch)
                }</span>

                <span class="cov0" title="0">text := Text{
                        S: builder.String(),
                        X: currentX,
                        Y: currentY,
                }

                var currentColumn *Column
                columnFound := false
                columnPosition := int64(currentX)

                for _, column := range result </span><span class="cov0" title="0">{
                        if columnPosition == column.Position </span><span class="cov0" title="0">{
                                currentColumn = column
                                columnFound = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !columnFound </span><span class="cov0" title="0">{
                        currentColumn = &amp;Column{
                                Position: columnPosition,
                                Content:  make(TextVertical, 0, 20), // Pre-allocate
                        }
                        result = append(result, currentColumn)
                }</span>

                <span class="cov0" title="0">currentColumn.Content = append(currentColumn.Content, text)</span>
        }

        <span class="cov0" title="0">p.walkTextBlocks(showText)

        for _, column := range result </span><span class="cov0" title="0">{
                sort.Sort(column.Content)
        }</span>

        <span class="cov0" title="0">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                return result[i].Position &lt; result[j].Position
        }</span>)

        <span class="cov0" title="0">return result, err</span>
}

// BatchExtractText extracts text from multiple pages using lazy loading and object pooling
// This is optimized for processing many pages without keeping all in memory
func (r *Reader) BatchExtractText(pageNums []int, useLazy bool) (map[int]string, error) <span class="cov0" title="0">{
        if len(pageNums) == 0 </span><span class="cov0" title="0">{
                return make(map[int]string), nil
        }</span>

        <span class="cov0" title="0">results := make(map[int]string, len(pageNums))

        if useLazy </span><span class="cov0" title="0">{
                // Use lazy page manager for memory efficiency
                manager := NewLazyPageManager(r, 10) // Keep max 10 pages in memory
                defer manager.Clear()

                for _, pageNum := range pageNums </span><span class="cov0" title="0">{
                        lazyPage := manager.GetPage(pageNum)
                        content := lazyPage.GetContent()

                        text := optimizedTextRunsToPlain(content.Text)
                        results[pageNum] = text
                }</span>
        } else<span class="cov0" title="0"> {
                // Direct extraction without lazy loading
                fontCache := make(map[string]*Font)
                for _, pageNum := range pageNums </span><span class="cov0" title="0">{
                        page := r.Page(pageNum)
                        text, err := page.OptimizedGetPlainText(fontCache)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, wrapPageError("batch extract text", pageNum, err)
                        }</span>
                        <span class="cov0" title="0">results[pageNum] = text</span>
                }
        }

        <span class="cov0" title="0">return results, nil</span>
}

// StreamingTextExtractor provides memory-efficient text extraction for large PDFs
type StreamingTextExtractor struct {
        reader      *Reader
        pageManager *LazyPageManager
        currentPage int
        totalPages  int
        batchSize   int
        fontCache   map[string]*Font
}

// NewStreamingTextExtractor creates a streaming extractor for large PDFs
func NewStreamingTextExtractor(r *Reader, maxCachedPages int) *StreamingTextExtractor <span class="cov0" title="0">{
        if maxCachedPages &lt;= 0 </span><span class="cov0" title="0">{
                maxCachedPages = 10
        }</span>

        <span class="cov0" title="0">return &amp;StreamingTextExtractor{
                reader:      r,
                pageManager: NewLazyPageManager(r, maxCachedPages),
                currentPage: 1,
                totalPages:  r.NumPage(),
                batchSize:   maxCachedPages,
                fontCache:   make(map[string]*Font),
        }</span>
}

// NextPage extracts text from the next page
func (e *StreamingTextExtractor) NextPage() (pageNum int, text string, hasMore bool, err error) <span class="cov0" title="0">{
        if e.currentPage &gt; e.totalPages </span><span class="cov0" title="0">{
                return 0, "", false, nil
        }</span>

        <span class="cov0" title="0">pageNum = e.currentPage
        page := e.reader.Page(pageNum)

        text, err = page.OptimizedGetPlainText(e.fontCache)
        if err != nil </span><span class="cov0" title="0">{
                return pageNum, "", false, wrapPageError("extract next page", pageNum, err)
        }</span>

        <span class="cov0" title="0">e.currentPage++
        hasMore = e.currentPage &lt;= e.totalPages

        return pageNum, text, hasMore, nil</span>
}

// NextBatch extracts text from the next batch of pages
func (e *StreamingTextExtractor) NextBatch() (results map[int]string, hasMore bool, err error) <span class="cov0" title="0">{
        if e.currentPage &gt; e.totalPages </span><span class="cov0" title="0">{
                return make(map[int]string), false, nil
        }</span>

        <span class="cov0" title="0">endPage := e.currentPage + e.batchSize - 1
        if endPage &gt; e.totalPages </span><span class="cov0" title="0">{
                endPage = e.totalPages
        }</span>

        <span class="cov0" title="0">results = make(map[int]string, endPage-e.currentPage+1)

        for i := e.currentPage; i &lt;= endPage; i++ </span><span class="cov0" title="0">{
                page := e.reader.Page(i)
                text, err := page.OptimizedGetPlainText(e.fontCache)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, false, wrapPageError("extract batch", i, err)
                }</span>
                <span class="cov0" title="0">results[i] = text</span>
        }

        <span class="cov0" title="0">e.currentPage = endPage + 1
        hasMore = e.currentPage &lt;= e.totalPages

        return results, hasMore, nil</span>
}

// Close releases resources used by the extractor
func (e *StreamingTextExtractor) Close() <span class="cov0" title="0">{
        if e.pageManager != nil </span><span class="cov0" title="0">{
                e.pageManager.Clear()
        }</span>
        <span class="cov0" title="0">e.fontCache = nil</span>
}

// Reset resets the extractor to the beginning
func (e *StreamingTextExtractor) Reset() <span class="cov0" title="0">{
        e.currentPage = 1
        if e.pageManager != nil </span><span class="cov0" title="0">{
                e.pageManager.Clear()
        }</span>
}

// GetProgress returns the extraction progress (0.0 to 1.0)
func (e *StreamingTextExtractor) GetProgress() float64 <span class="cov0" title="0">{
        if e.totalPages == 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>
        <span class="cov0" title="0">return float64(e.currentPage-1) / float64(e.totalPages)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "runtime"
        "sort"
        "sync"
)

// OptimizedSorter provides optimized sorting algorithms for large text collections
type OptimizedSorter struct {
        parallelThreshold int // Minimum size to use parallel sorting
}

// NewOptimizedSorter creates a new optimized sorter
func NewOptimizedSorter() *OptimizedSorter <span class="cov8" title="1">{
        return &amp;OptimizedSorter{
                parallelThreshold: 10000, // Use parallel sort for collections with 10k+ items
        }
}</span>

// SortTexts sorts a collection of texts using the most appropriate algorithm
func (os *OptimizedSorter) SortTexts(texts []Text, less func(i, j int) bool) <span class="cov8" title="1">{
        if len(texts) &lt;= 1 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if len(texts) &lt; os.parallelThreshold </span><span class="cov8" title="1">{
                // Use optimized sort for smaller collections
                os.timSort(texts, less)
        }</span> else<span class="cov8" title="1"> {
                // Use parallel sort for larger collections
                os.parallelSort(texts, less)
        }</span>
}

// standardSort uses an optimized version of standard sort
func (os *OptimizedSorter) standardSort(texts []Text, less func(i, j int) bool) <span class="cov0" title="0">{
        // Use Go's standard library sort, which is already highly optimized
        sort.Slice(texts, less)
}</span>

// timSort implements an optimized Timsort-like algorithm
func (os *OptimizedSorter) timSort(texts []Text, less func(i, j int) bool) <span class="cov8" title="1">{
        const minRun = 32

        n := len(texts)
        if n &lt;= minRun </span><span class="cov8" title="1">{
                os.insertionSort(texts, less)
                return
        }</span>

        // Calculate min run length
        <span class="cov0" title="0">minRunLen := os.calcMinRun(n)

        runs := make([]run, 0, n/minRunLen+1)

        // Create initial runs
        for i := 0; i &lt; n; </span><span class="cov0" title="0">{
                start := i
                end := min(i+minRunLen, n)

                // Find natural run
                for j := start + 1; j &lt; end &amp;&amp; !less(j, j-1); j++ </span>{<span class="cov0" title="0">
                        // Continue while ascending
                }</span>

                // If descending, reverse
                <span class="cov0" title="0">if start+1 &lt; end &amp;&amp; less(end-1, start) </span><span class="cov0" title="0">{
                        os.reverse(texts[start:end])
                }</span>

                // Insertion sort the run
                <span class="cov0" title="0">os.insertionSort(texts[start:end], func(i, j int) bool </span><span class="cov0" title="0">{
                        return less(start+i, start+j)
                }</span>)

                <span class="cov0" title="0">runs = append(runs, run{start: start, len: end - start})
                i = end</span>
        }

        // Merge runs
        <span class="cov0" title="0">for len(runs) &gt; 1 </span><span class="cov0" title="0">{
                i := 0
                for i &lt; len(runs)-1 </span><span class="cov0" title="0">{
                        if i+2 &lt; len(runs) &amp;&amp; runs[i+1].len &lt; runs[i+2].len </span><span class="cov0" title="0">{
                                // Merge runs[i] and runs[i+1]
                                os.mergeRuns(texts, &amp;runs[i], &amp;runs[i+1], less)
                                runs = append(runs[:i+1], runs[i+2:]...)
                        }</span> else<span class="cov0" title="0"> {
                                i++
                        }</span>
                }
        }
}

// run represents a sorted run in Timsort
type run struct {
        start, len int
}

// calcMinRun calculates the minimum run length for Timsort
func (os *OptimizedSorter) calcMinRun(n int) int <span class="cov0" title="0">{
        r := 0
        for n &gt;= 64 </span><span class="cov0" title="0">{
                r |= n &amp; 1
                n &gt;&gt;= 1
        }</span>
        <span class="cov0" title="0">return n + r</span>
}

// insertionSort performs insertion sort on a subarray
func (os *OptimizedSorter) insertionSort(texts []Text, less func(i, j int) bool) <span class="cov8" title="1">{
        for i := 1; i &lt; len(texts); i++ </span><span class="cov8" title="1">{
                for j := i; j &gt; 0 &amp;&amp; less(j, j-1); j-- </span><span class="cov8" title="1">{
                        texts[j], texts[j-1] = texts[j-1], texts[j]
                }</span>
        }
}

// insertionSortRange performs insertion sort on a range
func (os *OptimizedSorter) insertionSortRange(texts []Text, low, high int, less func(i, j int) bool) <span class="cov8" title="1">{
        for i := low + 1; i &lt;= high; i++ </span><span class="cov8" title="1">{
                for j := i; j &gt; low &amp;&amp; less(j, j-1); j-- </span><span class="cov8" title="1">{
                        texts[j], texts[j-1] = texts[j-1], texts[j]
                }</span>
        }
}

// reverse reverses a subarray
func (os *OptimizedSorter) reverse(texts []Text) <span class="cov0" title="0">{
        for i, j := 0, len(texts)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                texts[i], texts[j] = texts[j], texts[i]
        }</span>
}

// mergeRuns merges two adjacent runs
func (os *OptimizedSorter) mergeRuns(texts []Text, run1, run2 *run, less func(i, j int) bool) <span class="cov0" title="0">{
        // Use galloping mode for better performance on partially sorted data
        os.gallopMerge(texts, run1.start, run1.start+run1.len, run2.start+run2.len, less)
        run1.len += run2.len
}</span>

// gallopMerge performs a galloping merge
func (os *OptimizedSorter) gallopMerge(texts []Text, start, mid, end int, less func(i, j int) bool) <span class="cov0" title="0">{
        if mid-start &lt;= end-mid </span><span class="cov0" title="0">{
                // Left run is smaller, merge right to left
                for i := mid; i &lt; end; i++ </span><span class="cov0" title="0">{
                        temp := texts[i]
                        j := i
                        for j &gt; start &amp;&amp; less(i, j-1) </span><span class="cov0" title="0">{
                                texts[j] = texts[j-1]
                                j--
                        }</span>
                        <span class="cov0" title="0">texts[j] = temp</span>
                }
        } else<span class="cov0" title="0"> {
                // Right run is smaller, merge left to right
                for i := mid - 1; i &gt;= start; i-- </span><span class="cov0" title="0">{
                        temp := texts[i]
                        j := i
                        for j &lt; end-1 &amp;&amp; less(j+1, j) </span><span class="cov0" title="0">{
                                texts[j] = texts[j+1]
                                j++
                        }</span>
                        <span class="cov0" title="0">texts[j] = temp</span>
                }
        }
}

// parallelSort performs parallel merge sort for large collections
func (os *OptimizedSorter) parallelSort(texts []Text, less func(i, j int) bool) <span class="cov8" title="1">{
        if len(texts) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        // Determine number of goroutines to use
        <span class="cov8" title="1">numWorkers := runtime.NumCPU()
        if len(texts) &lt; numWorkers*1000 </span><span class="cov8" title="1">{
                // For collections that aren't extremely large, use fewer workers
                numWorkers = (len(texts) + 999) / 1000 // Ceiling division
                if numWorkers &lt; 2 </span><span class="cov8" title="1">{
                        numWorkers = 2
                }</span>
        }

        // Divide the slice into chunks for each worker (rounded up to avoid zero-sized chunks)
        <span class="cov8" title="1">chunkSize := (len(texts) + numWorkers - 1) / numWorkers
        if chunkSize &lt; 100 &amp;&amp; len(texts) &gt;= 100 </span><span class="cov0" title="0">{
                chunkSize = 100
        }</span>
        <span class="cov8" title="1">numWorkers = (len(texts) + chunkSize - 1) / chunkSize
        if numWorkers &lt; 1 </span><span class="cov0" title="0">{
                numWorkers = 1
        }</span>

        // Channel to receive sorted chunks
        <span class="cov8" title="1">results := make(chan struct {
                start, end int
        }, numWorkers)

        var wg sync.WaitGroup

        // Launch sorting goroutines
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(workerID int) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        start := workerID * chunkSize
                        end := (workerID + 1) * chunkSize
                        if workerID == numWorkers-1 </span><span class="cov8" title="1">{ // Last worker takes any remainder
                                end = len(texts)
                        }</span>

                        // Sort this chunk sequentially. Chunk-level parallelism is already provided by goroutines.
                        <span class="cov8" title="1">sort.Slice(texts[start:end], func(i, j int) bool </span><span class="cov8" title="1">{
                                return less(start+i, start+j)
                        }</span>)

                        <span class="cov8" title="1">results &lt;- struct {
                                start, end int
                        }{start: start, end: end}</span>
                }(i)
        }

        // Close the results channel when all workers are done
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(results)
        }</span>()

        // Wait for all chunks to be sorted
        <span class="cov8" title="1">for range results </span>{<span class="cov8" title="1">
                // Just receive to ensure all workers complete
        }</span>

        // Merge sorted chunks
        <span class="cov8" title="1">os.mergeChunks(texts, chunkSize, less)</span>
}

// mergeChunks merges sorted chunks in the array
func (os *OptimizedSorter) mergeChunks(texts []Text, chunkSize int, less func(i, j int) bool) <span class="cov8" title="1">{
        // For multiple chunks, perform multi-way merge
        // This implementation will handle merging in pairs until one sorted array remains
        numChunks := (len(texts) + chunkSize - 1) / chunkSize // Ceiling division
        if numChunks &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        // Create a temporary array for merging
        <span class="cov8" title="1">temp := make([]Text, len(texts))

        // Multi-way merge of all chunks
        os.multiWayMerge(texts, temp, chunkSize, less)</span>
}

// multiWayMerge performs a multi-way merge of sorted chunks
func (os *OptimizedSorter) multiWayMerge(texts, temp []Text, chunkSize int, less func(i, j int) bool) <span class="cov8" title="1">{
        // Use a simpler approach: iteratively merge pairs of chunks
        for currentSize := chunkSize; currentSize &lt; len(texts); currentSize *= 2 </span><span class="cov8" title="1">{
                // Merge pairs of chunks of currentSize
                for start := 0; start &lt; len(texts); start += 2 * currentSize </span><span class="cov8" title="1">{
                        mid := start + currentSize
                        end := start + 2*currentSize
                        if mid &gt; len(texts) </span><span class="cov0" title="0">{
                                mid = len(texts)
                        }</span>
                        <span class="cov8" title="1">if end &gt; len(texts) </span><span class="cov8" title="1">{
                                end = len(texts)
                        }</span>

                        <span class="cov8" title="1">if mid &lt; end </span><span class="cov8" title="1">{ // Only merge if both halves exist
                                os.merge(texts, temp, start, mid, end, less)
                                // Copy merged result back to original
                                copy(texts[start:end], temp[start:end])
                        }</span>
                }
        }
}

// merge merges two sorted subarrays
func (os *OptimizedSorter) merge(texts, temp []Text, start, mid, end int, less func(i, j int) bool) <span class="cov8" title="1">{
        i, j, k := start, mid, start

        for i &lt; mid &amp;&amp; j &lt; end </span><span class="cov8" title="1">{
                if less(i, j) || !less(j, i) </span><span class="cov8" title="1">{ // Equal case: take from left to maintain stability
                        temp[k] = texts[i]
                        i++
                }</span> else<span class="cov8" title="1"> {
                        temp[k] = texts[j]
                        j++
                }</span>
                <span class="cov8" title="1">k++</span>
        }

        // Copy remaining elements
        <span class="cov8" title="1">for i &lt; mid </span><span class="cov8" title="1">{
                temp[k] = texts[i]
                i++
                k++
        }</span>
        <span class="cov8" title="1">for j &lt; end </span><span class="cov8" title="1">{
                temp[k] = texts[j]
                j++
                k++
        }</span>
}

// SortTextVerticalByOptimized sorts TextVertical using optimized algorithm
func (os *OptimizedSorter) SortTextVerticalByOptimized(tv TextVertical) <span class="cov8" title="1">{
        os.SortTexts(tv, func(i, j int) bool </span><span class="cov8" title="1">{
                if tv[i].Y != tv[j].Y </span><span class="cov8" title="1">{
                        return tv[i].Y &gt; tv[j].Y
                }</span>
                <span class="cov8" title="1">return tv[i].X &lt; tv[j].X</span>
        })
}

// SortTextHorizontalByOptimized sorts TextHorizontal using optimized algorithm
func (os *OptimizedSorter) SortTextHorizontalByOptimized(th TextHorizontal) <span class="cov8" title="1">{
        os.SortTexts(th, func(i, j int) bool </span><span class="cov8" title="1">{
                if th[i].X != th[j].X </span><span class="cov8" title="1">{
                        return th[i].X &lt; th[j].X
                }</span>
                <span class="cov8" title="1">return th[i].Y &gt; th[j].Y</span>
        })
}

// QuickSortTexts implements quicksort for text collections
func (os *OptimizedSorter) QuickSortTexts(texts []Text, less func(i, j int) bool) <span class="cov8" title="1">{
        if len(texts) &lt;= 1 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">os.quickSortRange(texts, 0, len(texts)-1, less)</span>
}

// quickSortRange sorts a range of texts using quicksort
func (os *OptimizedSorter) quickSortRange(texts []Text, low, high int, less func(i, j int) bool) <span class="cov8" title="1">{
        if low &lt; high </span><span class="cov8" title="1">{
                // For very small ranges, use insertion sort
                if high-low &lt; 10 </span><span class="cov8" title="1">{
                        os.insertionSortRange(texts, low, high, less)
                        return
                }</span>

                // Partition and recursively sort
                <span class="cov0" title="0">pivot := os.partition(texts, low, high, less)
                os.quickSortRange(texts, low, pivot-1, less)
                os.quickSortRange(texts, pivot+1, high, less)</span>
        }
}

// partition partitions the array for quicksort
func (os *OptimizedSorter) partition(texts []Text, low, high int, less func(i, j int) bool) int <span class="cov8" title="1">{
        // Use median-of-three to choose pivot
        mid := (low + high) / 2
        if less(mid, low) </span><span class="cov0" title="0">{
                texts[low], texts[mid] = texts[mid], texts[low]
        }</span>
        <span class="cov8" title="1">if less(high, low) </span><span class="cov0" title="0">{
                texts[low], texts[high] = texts[high], texts[low]
        }</span>
        <span class="cov8" title="1">if less(high, mid) </span><span class="cov0" title="0">{
                texts[mid], texts[high] = texts[high], texts[mid]
        }</span>

        // Move median to end
        <span class="cov8" title="1">texts[mid], texts[high] = texts[high], texts[mid]

        pivot := high
        i := low - 1

        for j := low; j &lt; high; j++ </span><span class="cov8" title="1">{
                if less(j, pivot) || !less(pivot, j) </span><span class="cov8" title="1">{
                        i++
                        texts[i], texts[j] = texts[j], texts[i]
                }</span>
        }

        <span class="cov8" title="1">texts[i+1], texts[high] = texts[high], texts[i+1]
        return i + 1</span>
}

// OptimizedTextClusterSorter provides optimized sorting for text clusters
type OptimizedTextClusterSorter struct {
        sorter *OptimizedSorter
}

// NewOptimizedTextClusterSorter creates a new optimized cluster sorter
func NewOptimizedTextClusterSorter() *OptimizedTextClusterSorter <span class="cov8" title="1">{
        return &amp;OptimizedTextClusterSorter{
                sorter: NewOptimizedSorter(),
        }
}</span>

// SortTextBlocks sorts text blocks by various criteria
func (otcs *OptimizedTextClusterSorter) SortTextBlocks(blocks []*TextBlock, sortBy string) <span class="cov8" title="1">{
        switch sortBy </span>{
        case "position":<span class="cov8" title="1">
                otcs.sortByPosition(blocks)</span>
        case "size":<span class="cov8" title="1">
                otcs.sortBySize(blocks)</span>
        case "alphabetical":<span class="cov0" title="0">
                otcs.sortAlphabetically(blocks)</span>
        default:<span class="cov8" title="1">
                otcs.sortByPosition(blocks)</span> // Default to position-based sorting
        }
}

// sortByPosition sorts text blocks by position (top to bottom, then left to right)
func (otcs *OptimizedTextClusterSorter) sortByPosition(blocks []*TextBlock) <span class="cov8" title="1">{
        // Sort by Y descending (top to bottom in PDF coordinates), then X ascending
        sort.Slice(blocks, func(i, j int) bool </span><span class="cov8" title="1">{
                if blocks[i].Center().Y != blocks[j].Center().Y </span><span class="cov8" title="1">{
                        return blocks[i].Center().Y &gt; blocks[j].Center().Y // Higher Y is top in PDF
                }</span>
                <span class="cov0" title="0">return blocks[i].Center().X &lt; blocks[j].Center().X</span>
        })
}

// sortBySize sorts text blocks by size
func (otcs *OptimizedTextClusterSorter) sortBySize(blocks []*TextBlock) <span class="cov8" title="1">{
        sort.Slice(blocks, func(i, j int) bool </span><span class="cov8" title="1">{
                area1 := blocks[i].Width() * blocks[i].Height()
                area2 := blocks[j].Width() * blocks[j].Height()
                return area1 &gt; area2
        }</span>)
}

// sortAlphabetically sorts text blocks by their text content
func (otcs *OptimizedTextClusterSorter) sortAlphabetically(blocks []*TextBlock) <span class="cov0" title="0">{
        sort.Slice(blocks, func(i, j int) bool </span><span class="cov0" title="0">{
                if len(blocks[i].Texts) == 0 </span><span class="cov0" title="0">{
                        return len(blocks[j].Texts) &gt; 0
                }</span>
                <span class="cov0" title="0">if len(blocks[j].Texts) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return blocks[i].Texts[0].S &lt; blocks[j].Texts[0].S</span>
        })
}

// SortTextsWithAlgorithm allows choosing a specific sorting algorithm
func (os *OptimizedSorter) SortTextsWithAlgorithm(texts []Text, less func(i, j int) bool, algorithm string) <span class="cov8" title="1">{
        switch algorithm </span>{
        case "quicksort":<span class="cov8" title="1">
                os.QuickSortTexts(texts, less)</span>
        case "mergesort", "parallel":<span class="cov8" title="1">
                os.parallelSort(texts, less)</span>
        case "stdsort":<span class="cov8" title="1">
                sort.Slice(texts, less)</span>
        default:<span class="cov0" title="0">
                // Use adaptive approach based on size
                os.SortTexts(texts, less)</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "bytes"
        "fmt"
        "io"
        "math"
        "runtime"
        "sort"
        "strings"
        "sync"
)

// parseFontStyles parses font name to detect bold, italic, underline styles
func parseFontStyles(fontName string) (bold, italic, underline bool) <span class="cov8" title="1">{
        lower := strings.ToLower(fontName)
        if strings.Contains(lower, "bold") || strings.Contains(lower, "black") </span><span class="cov8" title="1">{
                bold = true
        }</span>
        <span class="cov8" title="1">if strings.Contains(lower, "italic") || strings.Contains(lower, "oblique") </span><span class="cov8" title="1">{
                italic = true
        }</span>
        // Underline detection is more complex, often not in font name
        // For now, set to false; can be enhanced later
        <span class="cov8" title="1">underline = false
        return</span>
}

// A Page represent a single page in a PDF file.
// The methods interpret a Page dictionary stored in V.
type Page struct {
        V         Value
        fontCache FontCacheInterface // Optional font cache for performance optimization (interface supports both implementations)
}

// Page returns the page for the given page number.
// Page numbers are indexed starting at 1, not 0.
// If the page is not found, Page returns a Page with p.V.IsNull().
func (r *Reader) Page(num int) Page <span class="cov0" title="0">{
        num-- // now 0-indexed
        page := r.Trailer().Key("Root").Key("Pages")
Search:
        for page.Key("Type").Name() == "Pages" </span><span class="cov0" title="0">{
                count := int(page.Key("Count").Int64())
                if count &lt; num </span><span class="cov0" title="0">{
                        return Page{V: Value{}}
                }</span>
                <span class="cov0" title="0">kids := page.Key("Kids")
                for i := 0; i &lt; kids.Len(); i++ </span><span class="cov0" title="0">{
                        kid := kids.Index(i)
                        if kid.Key("Type").Name() == "Pages" </span><span class="cov0" title="0">{
                                c := int(kid.Key("Count").Int64())
                                if num &lt; c </span><span class="cov0" title="0">{
                                        page = kid
                                        continue Search</span>
                                }
                                <span class="cov0" title="0">num -= c
                                continue</span>
                        }
                        <span class="cov0" title="0">if kid.Key("Type").Name() == "Page" </span><span class="cov0" title="0">{
                                if num == 0 </span><span class="cov0" title="0">{
                                        return Page{V: kid}
                                }</span>
                                <span class="cov0" title="0">num--</span>
                        }
                }
                <span class="cov0" title="0">break</span>
        }
        <span class="cov0" title="0">return Page{V: Value{}}</span>
}

// NumPage returns the number of pages in the PDF file.
func (r *Reader) NumPage() int <span class="cov8" title="1">{
        return int(r.Trailer().Key("Root").Key("Pages").Key("Count").Int64())
}</span>

// SetFontCache sets a font cache for this page to improve performance
// during text extraction by reusing parsed fonts.
// Deprecated: Use SetFontCacheInterface for better flexibility.
func (p *Page) SetFontCache(cache *GlobalFontCache) <span class="cov8" title="1">{
        p.fontCache = cache
}</span>

// SetFontCacheInterface sets a font cache using the interface
// This supports both GlobalFontCache and OptimizedFontCache
func (p *Page) SetFontCacheInterface(cache FontCacheInterface) <span class="cov8" title="1">{
        p.fontCache = cache
}</span>

// GetPlainText returns all the text in the PDF file
func (r *Reader) GetPlainText() (reader io.Reader, err error) <span class="cov0" title="0">{
        pages := r.NumPage()
        var buf bytes.Buffer
        fonts := make(map[string]*Font)
        for i := 1; i &lt;= pages; i++ </span><span class="cov0" title="0">{
                p := r.Page(i)
                for _, name := range p.Fonts() </span><span class="cov0" title="0">{ // cache fonts so we don't continually parse charmap
                        if _, ok := fonts[name]; !ok </span><span class="cov0" title="0">{
                                f := p.Font(name)
                                fonts[name] = &amp;f
                        }</span>
                }
                <span class="cov0" title="0">text, err := p.GetPlainText(fonts)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;bytes.Buffer{}, err
                }</span>
                <span class="cov0" title="0">buf.WriteString(text)</span>
        }
        <span class="cov0" title="0">return &amp;buf, nil</span>
}

// GetStyledTexts returns list all sentences in an array, that are included styles
func (r *Reader) GetStyledTexts() (sentences []Text, err error) <span class="cov0" title="0">{
        totalPage := r.NumPage()
        for pageIndex := 1; pageIndex &lt;= totalPage; pageIndex++ </span><span class="cov0" title="0">{
                p := r.Page(pageIndex)

                if p.V.IsNull() || p.V.Key("Contents").Kind() == Null </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var lastTextStyle Text
                texts := p.Content().Text
                for _, text := range texts </span><span class="cov0" title="0">{
                        if lastTextStyle == (Text{}) </span><span class="cov0" title="0">{
                                lastTextStyle = text
                                continue</span>
                        }

                        <span class="cov0" title="0">if IsSameSentence(lastTextStyle, text) </span><span class="cov0" title="0">{
                                lastTextStyle.S = lastTextStyle.S + text.S
                        }</span> else<span class="cov0" title="0"> {
                                sentences = append(sentences, lastTextStyle)
                                lastTextStyle = text
                        }</span>
                }
                <span class="cov0" title="0">if len(lastTextStyle.S) &gt; 0 </span><span class="cov0" title="0">{
                        sentences = append(sentences, lastTextStyle)
                }</span>
        }

        <span class="cov0" title="0">return sentences, err</span>
}

func (p Page) findInherited(key string) Value <span class="cov8" title="1">{
        for v := p.V; !v.IsNull(); v = v.Key("Parent") </span><span class="cov0" title="0">{
                if r := v.Key(key); !r.IsNull() </span><span class="cov0" title="0">{
                        return r
                }</span>
        }
        <span class="cov8" title="1">return Value{}</span>
}

/*
func (p Page) MediaBox() Value {
        return p.findInherited("MediaBox")
}

func (p Page) CropBox() Value {
        return p.findInherited("CropBox")
}
*/

// Resources returns the resources dictionary associated with the page.
func (p Page) Resources() Value <span class="cov8" title="1">{
        return p.findInherited("Resources")
}</span>

// Fonts returns a list of the fonts associated with the page.
func (p Page) Fonts() []string <span class="cov0" title="0">{
        return p.Resources().Key("Font").Keys()
}</span>

// Font returns the font with the given name associated with the page.
func (p Page) Font(name string) Font <span class="cov8" title="1">{
        fontValue := p.Resources().Key("Font").Key(name)

        // Use global font cache if available
        if p.fontCache != nil </span><span class="cov8" title="1">{
                // Generate cache key from page resources and font name
                key := fmt.Sprintf("page:%v:font:%s", p.V, name)

                // Try to get from cache
                if cached, ok := p.fontCache.Get(key); ok </span><span class="cov8" title="1">{
                        return *cached
                }</span>

                // Create new font and cache it
                <span class="cov8" title="1">font := Font{fontValue, nil}
                p.fontCache.Set(key, &amp;font)
                return font</span>
        }

        // No cache available, return new font
        <span class="cov8" title="1">return Font{fontValue, nil}</span>
}

// A Font represent a font in a PDF file.
// The methods interpret a Font dictionary stored in V.
type Font struct {
        V   Value
        enc TextEncoding
}

type fontScope struct {
        fonts  map[string]*Font
        parent *fontScope
}

func (s *fontScope) Get(name string) *Font <span class="cov0" title="0">{
        for scope := s; scope != nil; scope = scope.parent </span><span class="cov0" title="0">{
                if scope.fonts == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if f, ok := scope.fonts[name]; ok </span><span class="cov0" title="0">{
                        return f
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (p Page) buildFontScope(resources Value, cache map[string]*Font, parent *fontScope) *fontScope <span class="cov0" title="0">{
        scope := &amp;fontScope{parent: parent}
        fontDict := resources.Key("Font")
        if fontDict.Kind() != Dict </span><span class="cov0" title="0">{
                return scope
        }</span>
        <span class="cov0" title="0">scope.fonts = make(map[string]*Font)
        for _, name := range fontDict.Keys() </span><span class="cov0" title="0">{
                if cache != nil </span><span class="cov0" title="0">{
                        if f, ok := cache[name]; ok </span><span class="cov0" title="0">{
                                scope.fonts[name] = f
                                continue</span>
                        }
                }
                <span class="cov0" title="0">fontValue := fontDict.Key(name)
                font := &amp;Font{fontValue, nil}
                scope.fonts[name] = font
                if cache != nil </span><span class="cov0" title="0">{
                        cache[name] = font
                }</span>
        }
        <span class="cov0" title="0">return scope</span>
}

// BaseFont returns the font's name (BaseFont property).
func (f Font) BaseFont() string <span class="cov8" title="1">{
        return f.V.Key("BaseFont").Name()
}</span>

// FirstChar returns the code point of the first character in the font.
func (f Font) FirstChar() int <span class="cov8" title="1">{
        return int(f.V.Key("FirstChar").Int64())
}</span>

// LastChar returns the code point of the last character in the font.
func (f Font) LastChar() int <span class="cov8" title="1">{
        return int(f.V.Key("LastChar").Int64())
}</span>

// Widths returns the widths of the glyphs in the font.
// In a well-formed PDF, len(f.Widths()) == f.LastChar()+1 - f.FirstChar().
func (f Font) Widths() []float64 <span class="cov8" title="1">{
        x := f.V.Key("Widths")
        var out []float64
        for i := 0; i &lt; x.Len(); i++ </span><span class="cov0" title="0">{
                out = append(out, x.Index(i).Float64())
        }</span>
        <span class="cov8" title="1">return out</span>
}

// Width returns the width of the given code point.
func (f Font) Width(code int) float64 <span class="cov0" title="0">{
        first := f.FirstChar()
        last := f.LastChar()
        if code &lt; first || last &lt; code </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return f.V.Key("Widths").Index(code - first).Float64()</span>
}

// Encoder returns the encoding between font code point sequences and UTF-8.
func (f Font) Encoder() TextEncoding <span class="cov0" title="0">{
        if f.enc == nil </span><span class="cov0" title="0">{ // caching the Encoder so we don't have to continually parse charmap
                f.enc = f.buildEncoder()
                if f.enc == nil </span><span class="cov0" title="0">{
                        f.enc = &amp;nopEncoder{}
                }</span>
        }
        <span class="cov0" title="0">return f.enc</span>
}

func (f Font) buildEncoder() TextEncoding <span class="cov0" title="0">{
        if f.subtype() == "Type0" </span><span class="cov0" title="0">{
                if enc := f.type0Encoder(); enc != nil </span><span class="cov0" title="0">{
                        return enc
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">if f.subtype() == "Type3" </span><span class="cov0" title="0">{
                if enc := f.cmapEncodingFromValue(f.V.Key("ToUnicode")); enc != nil </span><span class="cov0" title="0">{
                        return enc
                }</span>
                <span class="cov0" title="0">return f.simpleEncoder()</span>
        }
        <span class="cov0" title="0">return f.simpleEncoder()</span>
}

func (f Font) simpleEncoder() TextEncoding <span class="cov0" title="0">{
        enc := f.V.Key("Encoding")
        switch enc.Kind() </span>{
        case Name:<span class="cov0" title="0">
                switch enc.Name() </span>{
                case "WinAnsiEncoding":<span class="cov0" title="0">
                        return &amp;byteEncoder{&amp;winAnsiEncoding}</span>
                case "MacRomanEncoding":<span class="cov0" title="0">
                        return &amp;byteEncoder{&amp;macRomanEncoding}</span>
                case "Identity-H":<span class="cov0" title="0">
                        return f.charmapEncoding()</span>
                default:<span class="cov0" title="0">
                        if DebugOn </span><span class="cov0" title="0">{
                                println("unknown encoding", enc.Name())
                        }</span>
                        <span class="cov0" title="0">return &amp;nopEncoder{}</span>
                }
        case Dict:<span class="cov0" title="0">
                return &amp;dictEncoder{enc.Key("Differences")}</span>
        case Null:<span class="cov0" title="0">
                return f.charmapEncoding()</span>
        case Stream:<span class="cov0" title="0">
                return f.cmapEncodingFromValue(enc)</span>
        default:<span class="cov0" title="0">
                if DebugOn </span><span class="cov0" title="0">{
                        println("unexpected encoding", enc.String())
                }</span>
                <span class="cov0" title="0">return &amp;nopEncoder{}</span>
        }
}

func (f Font) type0Encoder() TextEncoding <span class="cov0" title="0">{
        // Prefer ToUnicode if available
        if enc := f.cmapEncodingFromValue(f.V.Key("ToUnicode")); enc != nil </span><span class="cov0" title="0">{
                return enc
        }</span>

        <span class="cov0" title="0">encoding := f.V.Key("Encoding")
        switch encoding.Kind() </span>{
        case Stream:<span class="cov0" title="0">
                if enc := f.cmapEncodingFromValue(encoding); enc != nil </span><span class="cov0" title="0">{
                        return enc
                }</span>
        case Name:<span class="cov0" title="0">
                if enc := builtinCMapEncoding(encoding.Name()); enc != nil </span><span class="cov0" title="0">{
                        return enc
                }</span>
        case Null:<span class="cov0" title="0"></span>
                // fall through to descendant or builtins
        default:<span class="cov0" title="0">
                if DebugOn </span><span class="cov0" title="0">{
                        fmt.Printf("type0 encoding unexpected kind %s\n", encoding.String())
                }</span>
        }

        // Some documents embed ToUnicode on the descendant font
        <span class="cov0" title="0">if desc := f.descendantFont(); desc.Kind() == Dict </span><span class="cov0" title="0">{
                if enc := f.cmapEncodingFromValue(desc.Key("ToUnicode")); enc != nil </span><span class="cov0" title="0">{
                        return enc
                }</span>
        }

        // Final fallback to Identity-H encoding
        <span class="cov0" title="0">fallback := "Identity-H"
        if f.writingMode() == 1 </span><span class="cov0" title="0">{
                fallback = "Identity-V"
        }</span>
        <span class="cov0" title="0">if enc := builtinCMapEncoding(fallback); enc != nil </span><span class="cov0" title="0">{
                return enc
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (f Font) cmapEncodingFromValue(v Value) TextEncoding <span class="cov0" title="0">{
        if v.Kind() != Stream </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">m := readCmap(v)
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (f Font) subtype() string <span class="cov8" title="1">{
        return f.V.Key("Subtype").Name()
}</span>

func (f Font) descendantFont() Value <span class="cov0" title="0">{
        desc := f.V.Key("DescendantFonts")
        if desc.Kind() != Array || desc.Len() == 0 </span><span class="cov0" title="0">{
                return Value{}
        }</span>
        <span class="cov0" title="0">return desc.Index(0)</span>
}

func (f Font) writingMode() int <span class="cov0" title="0">{
        desc := f.descendantFont()
        if desc.Kind() != Dict </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return int(desc.Key("WMode").Int64())</span>
}

func (f *Font) charmapEncoding() TextEncoding <span class="cov0" title="0">{
        if enc := f.cmapEncodingFromValue(f.V.Key("ToUnicode")); enc != nil </span><span class="cov0" title="0">{
                return enc
        }</span>
        <span class="cov0" title="0">return &amp;byteEncoder{&amp;pdfDocEncoding}</span>
}

type dictEncoder struct {
        v Value
}

func (e *dictEncoder) Decode(raw string) (text string) <span class="cov0" title="0">{
        r := make([]rune, 0, len(raw))
        for i := 0; i &lt; len(raw); i++ </span><span class="cov0" title="0">{
                ch := rune(raw[i])
                n := -1
                for j := 0; j &lt; e.v.Len(); j++ </span><span class="cov0" title="0">{
                        x := e.v.Index(j)
                        if x.Kind() == Integer </span><span class="cov0" title="0">{
                                n = int(x.Int64())
                                continue</span>
                        }
                        <span class="cov0" title="0">if x.Kind() == Name </span><span class="cov0" title="0">{
                                if int(raw[i]) == n </span><span class="cov0" title="0">{
                                        r := nameToRune[x.Name()]
                                        if r != 0 </span><span class="cov0" title="0">{
                                                ch = r
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">n++</span>
                        }
                }
                <span class="cov0" title="0">r = append(r, ch)</span>
        }
        <span class="cov0" title="0">return string(r)</span>
}

// A TextEncoding represents a mapping between
// font code points and UTF-8 text.
type TextEncoding interface {
        // Decode returns the UTF-8 text corresponding to
        // the sequence of code points in raw.
        Decode(raw string) (text string)
}

type nopEncoder struct {
}

func (e *nopEncoder) Decode(raw string) (text string) <span class="cov0" title="0">{
        return raw
}</span>

type byteEncoder struct {
        table *[256]rune
}

func (e *byteEncoder) Decode(raw string) (text string) <span class="cov0" title="0">{
        r := make([]rune, 0, len(raw))
        for i := 0; i &lt; len(raw); i++ </span><span class="cov0" title="0">{
                r = append(r, e.table[raw[i]])
        }</span>
        <span class="cov0" title="0">return string(r)</span>
}

type byteRange struct {
        low  string
        high string
}

type bfchar struct {
        orig string
        repl string
}

type bfrange struct {
        lo  string
        hi  string
        dst Value
}

type cmap struct {
        space   [4][]byteRange // codespace range
        bfrange []bfrange
        bfchar  []bfchar
        use     TextEncoding
}

var cmapRegistry sync.Map

func registerCMap(name string, enc TextEncoding) <span class="cov0" title="0">{
        if name == "" || enc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">cmapRegistry.Store(name, enc)</span>
}

func lookupCMap(name string) TextEncoding <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if v, ok := cmapRegistry.Load(name); ok </span><span class="cov0" title="0">{
                if enc, ok := v.(TextEncoding); ok </span><span class="cov0" title="0">{
                        return enc
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *cmap) Decode(raw string) (text string) <span class="cov0" title="0">{
        var r []rune
Parse:
        for len(raw) &gt; 0 </span><span class="cov0" title="0">{
                for n := 1; n &lt;= 4 &amp;&amp; n &lt;= len(raw); n++ </span><span class="cov0" title="0">{ // number of digits in character replacement (1-4 possible)
                        for _, space := range m.space[n-1] </span><span class="cov0" title="0">{ // find matching codespace Ranges for number of digits
                                if space.low &lt;= raw[:n] &amp;&amp; raw[:n] &lt;= space.high </span><span class="cov0" title="0">{ // see if value is in range
                                        text := raw[:n]
                                        raw = raw[n:]
                                        for _, bfchar := range m.bfchar </span><span class="cov0" title="0">{ // check for matching bfchar
                                                if len(bfchar.orig) == n &amp;&amp; bfchar.orig == text </span><span class="cov0" title="0">{
                                                        r = append(r, []rune(utf16Decode(bfchar.repl))...)
                                                        continue Parse</span>
                                                }
                                        }
                                        <span class="cov0" title="0">for _, bfrange := range m.bfrange </span><span class="cov0" title="0">{ // check for matching bfrange
                                                if len(bfrange.lo) == n &amp;&amp; bfrange.lo &lt;= text &amp;&amp; text &lt;= bfrange.hi </span><span class="cov0" title="0">{
                                                        if bfrange.dst.Kind() == String </span><span class="cov0" title="0">{
                                                                s := bfrange.dst.RawString()
                                                                if bfrange.lo != text </span><span class="cov0" title="0">{ // value isn't at the beginning of the range so scale result
                                                                        b := []byte(s)
                                                                        b[len(b)-1] += text[len(text)-1] - bfrange.lo[len(bfrange.lo)-1] // increment last byte by difference
                                                                        s = string(b)
                                                                }</span>
                                                                <span class="cov0" title="0">r = append(r, []rune(utf16Decode(s))...)
                                                                continue Parse</span>
                                                        }
                                                        <span class="cov0" title="0">if bfrange.dst.Kind() == Array </span><span class="cov0" title="0">{
                                                                n := text[len(text)-1] - bfrange.lo[len(bfrange.lo)-1]
                                                                v := bfrange.dst.Index(int(n))
                                                                if v.Kind() == String </span><span class="cov0" title="0">{
                                                                        s := v.RawString()
                                                                        r = append(r, []rune(utf16Decode(s))...)
                                                                        continue Parse</span>
                                                                }
                                                                <span class="cov0" title="0">if DebugOn </span><span class="cov0" title="0">{
                                                                        fmt.Printf("array %v\n", bfrange.dst)
                                                                }</span>
                                                        } else<span class="cov0" title="0"> {
                                                                if DebugOn </span><span class="cov0" title="0">{
                                                                        fmt.Printf("unknown dst %v\n", bfrange.dst)
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">r = append(r, noRune)
                                                        continue Parse</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if m.use != nil </span><span class="cov0" title="0">{
                                                if out := m.use.Decode(text); out != "" </span><span class="cov0" title="0">{
                                                        r = append(r, []rune(out)...)
                                                        continue Parse</span>
                                                }
                                        }
                                        <span class="cov0" title="0">r = append(r, noRune)
                                        continue Parse</span>
                                }
                        }
                }
                <span class="cov0" title="0">if DebugOn </span><span class="cov0" title="0">{
                        println("no code space found")
                }</span>
                <span class="cov0" title="0">r = append(r, noRune)
                raw = raw[1:]</span>
        }
        <span class="cov0" title="0">return string(r)</span>
}

func readCmap(toUnicode Value) *cmap <span class="cov0" title="0">{
        n := -1
        var m cmap
        ok := true
        var cmapName string
        Interpret(toUnicode, func(stk *Stack, op string) </span><span class="cov0" title="0">{
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">switch op </span>{
                case "findresource":<span class="cov0" title="0">
                        stk.Pop() // category
                        stk.Pop() // key
                        stk.Push(newDict())</span>
                case "begincmap":<span class="cov0" title="0">
                        stk.Push(newDict())</span>
                case "endcmap":<span class="cov0" title="0">
                        stk.Pop()</span>
                case "begincodespacerange":<span class="cov0" title="0">
                        n = int(stk.Pop().Int64())</span>
                case "endcodespacerange":<span class="cov0" title="0">
                        if n &lt; 0 </span><span class="cov0" title="0">{
                                if DebugOn </span><span class="cov0" title="0">{
                                        println("missing begincodespacerange")
                                }</span>
                                <span class="cov0" title="0">ok = false
                                return</span>
                        }
                        <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                hi, lo := stk.Pop().RawString(), stk.Pop().RawString()
                                if len(lo) == 0 || len(lo) != len(hi) </span><span class="cov0" title="0">{
                                        if DebugOn </span><span class="cov0" title="0">{
                                                println("bad codespace range")
                                        }</span>
                                        <span class="cov0" title="0">ok = false
                                        return</span>
                                }
                                <span class="cov0" title="0">m.space[len(lo)-1] = append(m.space[len(lo)-1], byteRange{lo, hi})</span>
                        }
                        <span class="cov0" title="0">n = -1</span>
                case "beginbfchar":<span class="cov0" title="0">
                        n = int(stk.Pop().Int64())</span>
                case "endbfchar":<span class="cov0" title="0">
                        if n &lt; 0 </span><span class="cov0" title="0">{
                                panic("missing beginbfchar")</span>
                        }
                        <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                repl, orig := stk.Pop().RawString(), stk.Pop().RawString()
                                m.bfchar = append(m.bfchar, bfchar{orig, repl})
                        }</span>
                case "beginbfrange":<span class="cov0" title="0">
                        n = int(stk.Pop().Int64())</span>
                case "endbfrange":<span class="cov0" title="0">
                        if n &lt; 0 </span><span class="cov0" title="0">{
                                panic("missing beginbfrange")</span>
                        }
                        <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                dst, srcHi, srcLo := stk.Pop(), stk.Pop().RawString(), stk.Pop().RawString()
                                m.bfrange = append(m.bfrange, bfrange{srcLo, srcHi, dst})
                        }</span>
                case "usecmap":<span class="cov0" title="0">
                        base := stk.Pop()
                        name := base.Name()
                        if name == "" </span><span class="cov0" title="0">{
                                name = base.Text()
                        }</span>
                        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if enc := builtinCMapEncoding(name); enc != nil </span><span class="cov0" title="0">{
                                m.use = enc
                        }</span> else<span class="cov0" title="0"> if enc := lookupCMap(name); enc != nil </span><span class="cov0" title="0">{
                                m.use = enc
                        }</span> else<span class="cov0" title="0"> if DebugOn </span><span class="cov0" title="0">{
                                fmt.Printf("unknown usecmap %s\n", name)
                        }</span>
                case "defineresource":<span class="cov0" title="0">
                        category := stk.Pop().Name()
                        value := stk.Pop()
                        key := stk.Pop().Name()
                        if category == "CMap" &amp;&amp; key != "" </span><span class="cov0" title="0">{
                                cmapName = key
                        }</span>
                        <span class="cov0" title="0">stk.Push(value)</span>
                default:<span class="cov0" title="0">
                        if DebugOn </span><span class="cov0" title="0">{
                                println("interp\t", op)
                        }</span>
                }
        })
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmapName != "" </span><span class="cov0" title="0">{
                registerCMap(cmapName, &amp;m)
        }</span>
        <span class="cov0" title="0">return &amp;m</span>
}

type matrix [3][3]float64

var ident = matrix{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}

func (x matrix) mul(y matrix) matrix <span class="cov0" title="0">{
        var z matrix
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; 3; j++ </span><span class="cov0" title="0">{
                        for k := 0; k &lt; 3; k++ </span><span class="cov0" title="0">{
                                z[i][j] += x[i][k] * y[k][j]
                        }</span>
                }
        }
        <span class="cov0" title="0">return z</span>
}

func matrixFromValue(v Value) (matrix, bool) <span class="cov0" title="0">{
        if v.Kind() != Array || v.Len() != 6 </span><span class="cov0" title="0">{
                return matrix{}, false
        }</span>
        <span class="cov0" title="0">var m matrix
        for i := 0; i &lt; 6; i++ </span><span class="cov0" title="0">{
                m[i/2][i%2] = v.Index(i).Float64()
        }</span>
        <span class="cov0" title="0">m[2][2] = 1
        return m, true</span>
}

func applyMatrixToPoint(m matrix, x, y float64) (float64, float64) <span class="cov0" title="0">{
        px := x*m[0][0] + y*m[1][0] + m[2][0]
        py := x*m[0][1] + y*m[1][1] + m[2][1]
        return px, py
}</span>

// A Text represents a single piece of text drawn on a page.
type Text struct {
        Font      string  // the font used
        FontSize  float64 // the font size, in points (1/72 of an inch)
        X         float64 // the X coordinate, in points, increasing left to right
        Y         float64 // the Y coordinate, in points, increasing bottom to top
        W         float64 // the width of the text, in points
        S         string  // the actual UTF-8 text
        Vertical  bool    // whether the text is drawn vertically
        Bold      bool    // whether the text is bold
        Italic    bool    // whether the text is italic
        Underline bool    // whether the text is underlined
}

// A Rect represents a rectangle.
type Rect struct {
        Min, Max Point
}

// A Point represents an X, Y pair.
type Point struct {
        X float64
        Y float64
}

// Content describes the basic content on a page: the text and any drawn rectangles.
type Content struct {
        Text []Text
        Rect []Rect
}

type gstate struct {
        Tc    float64
        Tw    float64
        Th    float64
        Tl    float64
        Tf    Font
        Tfs   float64
        Tmode int
        Trise float64
        Tm    matrix
        Tlm   matrix
        Trm   matrix
        CTM   matrix
}

// GetPlainText returns the page's all text without format.
// fonts can be passed in (to improve parsing performance) or left nil
func (p Page) GetPlainText(fonts map[string]*Font) (string, error) <span class="cov0" title="0">{
        // Handle in case the content page is empty
        if p.V.IsNull() || p.V.Key("Contents").Kind() == Null </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">content, err := p.contentWithFonts(fonts)
        if err != nil </span><span class="cov0" title="0">{
                return "", wrapError("extract page content", err)
        }</span>

        <span class="cov0" title="0">return textRunsToPlain(content.Text), nil</span>
}

// GetPlainTextWithSmartOrdering extracts plain text using an improved text ordering algorithm
// that handles multi-column layouts and complex reading orders.
func (p Page) GetPlainTextWithSmartOrdering(fonts map[string]*Font) (string, error) <span class="cov0" title="0">{
        // Handle in case the content page is empty
        if p.V.IsNull() || p.V.Key("Contents").Kind() == Null </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">content, err := p.contentWithFonts(fonts)
        if err != nil </span><span class="cov0" title="0">{
                return "", wrapError("extract page content", err)
        }</span>

        <span class="cov0" title="0">return SmartTextRunsToPlain(content.Text), nil</span>
}

// GetPlainTextConcurrent extracts all pages concurrently using the specified number of workers.
func (r *Reader) GetPlainTextConcurrent(workers int) (io.Reader, error) <span class="cov0" title="0">{
        pages := r.NumPage()
        if pages == 0 </span><span class="cov0" title="0">{
                return &amp;bytes.Buffer{}, nil
        }</span>
        <span class="cov0" title="0">if workers &lt;= 0 </span><span class="cov0" title="0">{
                workers = runtime.NumCPU()
        }</span>
        <span class="cov0" title="0">if workers &gt; pages </span><span class="cov0" title="0">{
                workers = pages
        }</span>
        <span class="cov0" title="0">results := make([]string, pages)
        jobs := make(chan int)
        errCh := make(chan error, 1)
        done := make(chan struct{})
        var once sync.Once
        cancel := func(err error) </span><span class="cov0" title="0">{
                once.Do(func() </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- err
                        }</span>
                        <span class="cov0" title="0">close(done)</span>
                })
        }

        <span class="cov0" title="0">var wg sync.WaitGroup
        worker := func() </span><span class="cov0" title="0">{
                defer wg.Done()
                for pageNum := range jobs </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">text, err := r.Page(pageNum).GetPlainText(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                cancel(err)
                                return
                        }</span>
                        <span class="cov0" title="0">results[pageNum-1] = text</span>
                }
        }

        <span class="cov0" title="0">wg.Add(workers)
        for i := 0; i &lt; workers; i++ </span><span class="cov0" title="0">{
                go worker()
        }</span>

<span class="cov0" title="0">pagesLoop:
        for i := 1; i &lt;= pages; i++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        break pagesLoop</span>
                case jobs &lt;- i:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov0" title="0">close(jobs)
        wg.Wait()

        select </span>{
        case err := &lt;-errCh:<span class="cov0" title="0">
                return nil, err</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">var buf bytes.Buffer
        for _, text := range results </span><span class="cov0" title="0">{
                buf.WriteString(text)
        }</span>
        <span class="cov0" title="0">return &amp;buf, nil</span>
}

func textRunsToPlain(texts []Text) string <span class="cov0" title="0">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // work on a copy so callers of Content() are not affected by ordering changes
        <span class="cov0" title="0">runs := append([]Text(nil), texts...)
        sort.Sort(TextVertical(runs))

        const lineTolerance = 2.0
        var lines [][]Text
        var currentLine []Text
        var currentCoord float64

        for i, t := range runs </span><span class="cov0" title="0">{
                lineCoord := effectiveLineCoord(t)
                if i == 0 || math.Abs(lineCoord-currentCoord) &lt;= lineTolerance </span><span class="cov0" title="0">{
                        currentLine = append(currentLine, t)
                        if len(currentLine) == 1 </span><span class="cov0" title="0">{
                                currentCoord = lineCoord
                        }</span> else<span class="cov0" title="0"> {
                                currentCoord = (currentCoord*float64(len(currentLine)-1) + lineCoord) / float64(len(currentLine))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if len(currentLine) &gt; 0 </span><span class="cov0" title="0">{
                        sort.Slice(currentLine, func(i, j int) bool </span><span class="cov0" title="0">{
                                return effectiveOrderCoord(currentLine[i]) &lt; effectiveOrderCoord(currentLine[j])
                        }</span>)
                        <span class="cov0" title="0">lines = append(lines, currentLine)</span>
                }
                <span class="cov0" title="0">currentLine = []Text{t}
                currentCoord = lineCoord</span>
        }

        <span class="cov0" title="0">if len(currentLine) &gt; 0 </span><span class="cov0" title="0">{
                sort.Slice(currentLine, func(i, j int) bool </span><span class="cov0" title="0">{
                        return effectiveOrderCoord(currentLine[i]) &lt; effectiveOrderCoord(currentLine[j])
                }</span>)
                <span class="cov0" title="0">lines = append(lines, currentLine)</span>
        }

        //  StringBuffer 
        <span class="cov0" title="0">totalLen := 0
        for _, line := range lines </span><span class="cov0" title="0">{
                for _, t := range line </span><span class="cov0" title="0">{
                        totalLen += len(t.S) + 1 // +1 for potential space
                }</span>
                <span class="cov0" title="0">totalLen++</span> // for newline
        }

        <span class="cov0" title="0">builder := NewStringBuffer(totalLen)
        for i, line := range lines </span><span class="cov0" title="0">{
                appendLineZC(builder, line)
                if i &lt; len(lines)-1 </span><span class="cov0" title="0">{
                        builder.WriteByte('\n')
                }</span>
        }
        <span class="cov0" title="0">result := builder.String()
        return TrimSpaceZeroCopy(result)</span>
}

// appendLineZC  appendLine
func appendLineZC(builder *StringBuffer, line []Text) <span class="cov0" title="0">{
        const minGap = 0.5
        var prevEnd float64
        hasPrev := false
        allVertical := true
        for _, t := range line </span><span class="cov0" title="0">{
                if !t.Vertical </span><span class="cov0" title="0">{
                        allVertical = false
                        break</span>
                }
        }

        <span class="cov0" title="0">for _, t := range line </span><span class="cov0" title="0">{
                if hasPrev </span><span class="cov0" title="0">{
                        var gap float64
                        if allVertical </span><span class="cov0" title="0">{
                                gap = math.Abs(t.Y - prevEnd)
                        }</span> else<span class="cov0" title="0"> {
                                gap = t.X - prevEnd
                        }</span>
                        <span class="cov0" title="0">spaceThreshold := math.Max(t.FontSize*0.2, minGap)
                        if gap &gt; spaceThreshold &amp;&amp; !allVertical </span><span class="cov0" title="0">{
                                builder.WriteByte(' ')
                        }</span>
                }
                <span class="cov0" title="0">builder.WriteString(t.S)
                if allVertical </span><span class="cov0" title="0">{
                        prevEnd = t.Y
                }</span> else<span class="cov0" title="0"> {
                        prevEnd = t.X + t.W
                }</span>
                <span class="cov0" title="0">hasPrev = true</span>
        }
}

func appendLine(builder *strings.Builder, line []Text) <span class="cov0" title="0">{
        const minGap = 0.5
        var prevEnd float64
        hasPrev := false
        allVertical := true
        for _, t := range line </span><span class="cov0" title="0">{
                if !t.Vertical </span><span class="cov0" title="0">{
                        allVertical = false
                        break</span>
                }
        }

        <span class="cov0" title="0">for _, t := range line </span><span class="cov0" title="0">{
                if hasPrev </span><span class="cov0" title="0">{
                        var gap float64
                        if allVertical </span><span class="cov0" title="0">{
                                gap = math.Abs(t.Y - prevEnd)
                        }</span> else<span class="cov0" title="0"> {
                                gap = t.X - prevEnd
                        }</span>
                        <span class="cov0" title="0">spaceThreshold := math.Max(t.FontSize*0.2, minGap)
                        if gap &gt; spaceThreshold &amp;&amp; !allVertical </span><span class="cov0" title="0">{
                                builder.WriteByte(' ')
                        }</span>
                }
                <span class="cov0" title="0">builder.WriteString(t.S)
                if allVertical </span><span class="cov0" title="0">{
                        prevEnd = t.Y
                }</span> else<span class="cov0" title="0"> {
                        prevEnd = t.X + t.W
                }</span>
                <span class="cov0" title="0">hasPrev = true</span>
        }
}

//go:inline
func effectiveLineCoord(t Text) float64 <span class="cov0" title="0">{
        if t.Vertical </span><span class="cov0" title="0">{
                return t.X
        }</span>
        <span class="cov0" title="0">return t.Y</span>
}

//go:inline
func effectiveOrderCoord(t Text) float64 <span class="cov0" title="0">{
        if t.Vertical </span><span class="cov0" title="0">{
                return -t.Y
        }</span>
        <span class="cov0" title="0">return t.X</span>
}

// Column represents the contents of a column
type Column struct {
        Position int64
        Content  TextVertical
}

// Columns is a list of column
type Columns []*Column

// GetTextByColumn returns the page's all text grouped by column
func (p Page) GetTextByColumn() (Columns, error) <span class="cov0" title="0">{
        var result Columns
        var err error

        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        result = Columns{}
                        err = wrapError("extract text by column", fmt.Errorf("%v", r))
                }</span>
        }()

        <span class="cov0" title="0">showText := func(enc TextEncoding, currentX, currentY float64, s string) </span><span class="cov0" title="0">{
                var textBuilder bytes.Buffer

                for _, ch := range enc.Decode(s) </span><span class="cov0" title="0">{
                        _, err := textBuilder.WriteRune(ch)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                }
                <span class="cov0" title="0">text := Text{
                        S: textBuilder.String(),
                        X: currentX,
                        Y: currentY,
                }

                var currentColumn *Column
                columnFound := false
                for _, column := range result </span><span class="cov0" title="0">{
                        if int64(currentX) == column.Position </span><span class="cov0" title="0">{
                                currentColumn = column
                                columnFound = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !columnFound </span><span class="cov0" title="0">{
                        currentColumn = &amp;Column{
                                Position: int64(currentX),
                                Content:  TextVertical{},
                        }
                        result = append(result, currentColumn)
                }</span>

                <span class="cov0" title="0">currentColumn.Content = append(currentColumn.Content, text)</span>
        }

        <span class="cov0" title="0">p.walkTextBlocks(showText)

        for _, column := range result </span><span class="cov0" title="0">{
                sort.Sort(column.Content)
        }</span>

        <span class="cov0" title="0">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                return result[i].Position &lt; result[j].Position
        }</span>)

        <span class="cov0" title="0">return result, err</span>
}

// Row represents the contents of a row
type Row struct {
        Position int64
        Content  TextHorizontal
}

// Rows is a list of rows
type Rows []*Row

// GetTextByRow returns the page's all text grouped by rows
func (p Page) GetTextByRow() (Rows, error) <span class="cov0" title="0">{
        var result Rows
        var err error

        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        result = Rows{}
                        err = wrapError("extract text by row", fmt.Errorf("%v", r))
                }</span>
        }()

        <span class="cov0" title="0">showText := func(enc TextEncoding, currentX, currentY float64, s string) </span><span class="cov0" title="0">{
                var textBuilder bytes.Buffer
                for _, ch := range enc.Decode(s) </span><span class="cov0" title="0">{
                        _, err := textBuilder.WriteRune(ch)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                }

                // if DebugOn {
                //         fmt.Println(textBuilder.String())
                // }

                <span class="cov0" title="0">text := Text{
                        S: textBuilder.String(),
                        X: currentX,
                        Y: currentY,
                }

                var currentRow *Row
                rowFound := false
                for _, row := range result </span><span class="cov0" title="0">{
                        if int64(currentY) == row.Position </span><span class="cov0" title="0">{
                                currentRow = row
                                rowFound = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !rowFound </span><span class="cov0" title="0">{
                        currentRow = &amp;Row{
                                Position: int64(currentY),
                                Content:  TextHorizontal{},
                        }
                        result = append(result, currentRow)
                }</span>

                <span class="cov0" title="0">currentRow.Content = append(currentRow.Content, text)</span>
        }

        <span class="cov0" title="0">p.walkTextBlocks(showText)

        for _, row := range result </span><span class="cov0" title="0">{
                sort.Sort(row.Content)
        }</span>

        <span class="cov0" title="0">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                return result[i].Position &gt; result[j].Position
        }</span>)

        <span class="cov0" title="0">return result, err</span>
}

func (p Page) walkTextBlocks(walker func(enc TextEncoding, x, y float64, s string)) <span class="cov0" title="0">{
        // Handle in case the content page is empty
        if p.V.IsNull() || p.V.Key("Contents").Kind() == Null </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">scope := p.buildFontScope(p.Resources(), nil, nil)
        processor := textProcessor{
                page:   p,
                walker: walker,
        }
        processor.process(p.V.Key("Contents"), p.Resources(), scope, ident)</span>
}

type textProcessor struct {
        page   Page
        walker func(enc TextEncoding, x, y float64, s string)
}

func (tp *textProcessor) process(strm Value, resources Value, scope *fontScope, ctm matrix) <span class="cov0" title="0">{
        if strm.Kind() == Null </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var enc TextEncoding = &amp;nopEncoder{}
        var currentX, currentY float64
        Interpret(strm, func(stk *Stack, op string) </span><span class="cov0" title="0">{
                n := stk.Len()
                args := make([]Value, n)
                for i := n - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        args[i] = stk.Pop()
                }</span>
                <span class="cov0" title="0">switch op </span>{
                default:<span class="cov0" title="0">
                        return</span>
                case "T*":<span class="cov0" title="0"></span> // move to start of next line
                case "Tf":<span class="cov0" title="0">
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                panic("bad Tf operator")</span>
                        }
                        <span class="cov0" title="0">if font := scope.Get(args[0].Name()); font != nil </span><span class="cov0" title="0">{
                                enc = font.Encoder()
                                if enc == nil </span><span class="cov0" title="0">{
                                        enc = &amp;nopEncoder{}
                                }</span>
                        } else<span class="cov0" title="0"> {
                                enc = &amp;nopEncoder{}
                        }</span>
                case "\"":<span class="cov0" title="0">
                        if len(args) != 3 </span><span class="cov0" title="0">{
                                panic("bad \\\" operator")</span>
                        }
                        <span class="cov0" title="0">fallthrough</span>
                case "'":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad ' operator")</span>
                        }
                        <span class="cov0" title="0">fallthrough</span>
                case "Tj":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad Tj operator")</span>
                        }
                        <span class="cov0" title="0">tp.emit(enc, currentX, currentY, args[0].RawString(), ctm)</span>
                case "TJ":<span class="cov0" title="0">
                        v := args[0]
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                                x := v.Index(i)
                                if x.Kind() == String </span><span class="cov0" title="0">{
                                        tp.emit(enc, currentX, currentY, x.RawString(), ctm)
                                }</span>
                        }
                case "Td":<span class="cov0" title="0">
                        tp.emit(enc, currentX, currentY, "", ctm)</span>
                case "Tm":<span class="cov0" title="0">
                        if len(args) != 6 </span><span class="cov0" title="0">{
                                panic("bad Tm operator")</span>
                        }
                        <span class="cov0" title="0">currentX = args[4].Float64()
                        currentY = args[5].Float64()</span>
                case "Do":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad Do operator")</span>
                        }
                        <span class="cov0" title="0">tp.handleDo(args[0], resources, scope, ctm)</span>
                }
        })
}

func (tp *textProcessor) emit(enc TextEncoding, x, y float64, raw string, ctm matrix) <span class="cov0" title="0">{
        if tp.walker == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">tx, ty := applyMatrixToPoint(ctm, x, y)
        tp.walker(enc, tx, ty, raw)</span>
}

func (tp *textProcessor) handleDo(arg Value, resources Value, scope *fontScope, ctm matrix) <span class="cov0" title="0">{
        name := arg.Name()
        if name == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">xobjects := resources.Key("XObject")
        if xobjects.Kind() != Dict </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">xobj := xobjects.Key(name)
        if xobj.Kind() != Stream || xobj.Key("Subtype").Name() != "Form" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">formRes := xobj.Key("Resources")
        if formRes.Kind() == Null </span><span class="cov0" title="0">{
                formRes = resources
        }</span>
        <span class="cov0" title="0">childScope := tp.page.buildFontScope(formRes, nil, scope)
        childCTM := ctm
        if m, ok := matrixFromValue(xobj.Key("Matrix")); ok </span><span class="cov0" title="0">{
                childCTM = m.mul(childCTM)
        }</span>
        <span class="cov0" title="0">tp.process(xobj, formRes, childScope, childCTM)</span>
}

// Content returns the page's content.
func (p Page) Content() Content <span class="cov0" title="0">{
        content, _ := p.contentWithFonts(nil)
        return content
}</span>

func (p Page) contentWithFonts(fonts map[string]*Font) (Content, error) <span class="cov0" title="0">{
        var content Content
        var err error

        // Recover from panics in content stream processing and convert to errors
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        content = Content{}
                        err = wrapError("process content stream", fmt.Errorf("%v", r))
                }</span>
        }()

        // Handle in case the content page is empty
        <span class="cov0" title="0">if p.V.IsNull() || p.V.Key("Contents").Kind() == Null </span><span class="cov0" title="0">{
                return Content{}, nil
        }</span>

        <span class="cov0" title="0">extractor := contentExtractor{page: p}
        scope := p.buildFontScope(p.Resources(), fonts, nil)
        initial := gstate{
                Th:  1,
                CTM: ident,
        }
        extractor.process(p.V.Key("Contents"), p.Resources(), scope, initial)
        content = Content{extractor.text, extractor.rect}
        return content, err</span>
}

type contentExtractor struct {
        page Page
        text []Text
        rect []Rect
}

func (ce *contentExtractor) process(strm Value, resources Value, scope *fontScope, initial gstate) <span class="cov0" title="0">{
        if strm.Kind() == Null </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">g := initial
        var enc TextEncoding = &amp;nopEncoder{}
        var gstack []gstate
        Interpret(strm, func(stk *Stack, op string) </span><span class="cov0" title="0">{
                n := stk.Len()
                args := make([]Value, n)
                for i := n - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        args[i] = stk.Pop()
                }</span>
                <span class="cov0" title="0">switch op </span>{
                default:<span class="cov0" title="0">
                        return</span>

                case "cm":<span class="cov0" title="0">
                        if len(args) != 6 </span><span class="cov0" title="0">{
                                panic("bad cm operator")</span>
                        }
                        <span class="cov0" title="0">var m matrix
                        for i := 0; i &lt; 6; i++ </span><span class="cov0" title="0">{
                                m[i/2][i%2] = args[i].Float64()
                        }</span>
                        <span class="cov0" title="0">m[2][2] = 1
                        g.CTM = m.mul(g.CTM)</span>

                case "re":<span class="cov0" title="0">
                        if len(args) != 4 </span><span class="cov0" title="0">{
                                panic("bad re")</span>
                        }
                        <span class="cov0" title="0">x, y, w, h := args[0].Float64(), args[1].Float64(), args[2].Float64(), args[3].Float64()
                        ce.rect = append(ce.rect, Rect{Point{x, y}, Point{x + w, y + h}})</span>

                case "q":<span class="cov0" title="0">
                        gstack = append(gstack, g)</span>

                case "Q":<span class="cov0" title="0">
                        if len(gstack) == 0 </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">g = gstack[len(gstack)-1]
                        gstack = gstack[:len(gstack)-1]</span>

                case "BT":<span class="cov0" title="0">
                        g.Tm = ident
                        g.Tlm = g.Tm</span>

                case "ET":<span class="cov0" title="0"></span>
                case "T*":<span class="cov0" title="0">
                        x := matrix{{1, 0, 0}, {0, 1, 0}, {0, -g.Tl, 1}}
                        g.Tlm = x.mul(g.Tlm)
                        g.Tm = g.Tlm</span>

                case "Tc":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad Tc")</span>
                        }
                        <span class="cov0" title="0">g.Tc = args[0].Float64()</span>

                case "TD":<span class="cov0" title="0">
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                panic("bad TD")</span>
                        }
                        <span class="cov0" title="0">g.Tl = -args[1].Float64()
                        fallthrough</span>
                case "Td":<span class="cov0" title="0">
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                panic("bad Td")</span>
                        }
                        <span class="cov0" title="0">tx := args[0].Float64()
                        ty := args[1].Float64()
                        x := matrix{{1, 0, 0}, {0, 1, 0}, {tx, ty, 1}}
                        g.Tlm = x.mul(g.Tlm)
                        g.Tm = g.Tlm</span>

                case "Tf":<span class="cov0" title="0">
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                panic("bad Tf")</span>
                        }
                        <span class="cov0" title="0">name := args[0].Name()
                        if font := scope.Get(name); font != nil </span><span class="cov0" title="0">{
                                g.Tf = *font
                                enc = g.Tf.Encoder()
                                if enc == nil </span><span class="cov0" title="0">{
                                        enc = &amp;nopEncoder{}
                                }</span>
                        } else<span class="cov0" title="0"> {
                                g.Tf = Font{}
                                enc = &amp;nopEncoder{}
                        }</span>
                        <span class="cov0" title="0">g.Tfs = args[1].Float64()</span>

                case "\"":<span class="cov0" title="0">
                        if len(args) != 3 </span><span class="cov0" title="0">{
                                panic("bad \\\" operator")</span>
                        }
                        <span class="cov0" title="0">g.Tw = args[0].Float64()
                        g.Tc = args[1].Float64()
                        args = args[2:]
                        fallthrough</span>
                case "'":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad ' operator")</span>
                        }
                        <span class="cov0" title="0">x := matrix{{1, 0, 0}, {0, 1, 0}, {0, -g.Tl, 1}}
                        g.Tlm = x.mul(g.Tlm)
                        g.Tm = g.Tlm
                        fallthrough</span>
                case "Tj":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad Tj operator")</span>
                        }
                        <span class="cov0" title="0">ce.appendText(&amp;g, enc, args[0].RawString())</span>

                case "TJ":<span class="cov0" title="0">
                        v := args[0]
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                                x := v.Index(i)
                                if x.Kind() == String </span><span class="cov0" title="0">{
                                        ce.appendText(&amp;g, enc, x.RawString())
                                }</span> else<span class="cov0" title="0"> {
                                        tx := -x.Float64() / 1000 * g.Tfs * g.Th
                                        g.Tm = matrix{{1, 0, 0}, {0, 1, 0}, {tx, 0, 1}}.mul(g.Tm)
                                }</span>
                        }
                        <span class="cov0" title="0">ce.appendText(&amp;g, enc, "\n")</span>

                case "TL":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad TL")</span>
                        }
                        <span class="cov0" title="0">g.Tl = args[0].Float64()</span>

                case "Tm":<span class="cov0" title="0">
                        if len(args) != 6 </span><span class="cov0" title="0">{
                                panic("bad Tm")</span>
                        }
                        <span class="cov0" title="0">var m matrix
                        for i := 0; i &lt; 6; i++ </span><span class="cov0" title="0">{
                                m[i/2][i%2] = args[i].Float64()
                        }</span>
                        <span class="cov0" title="0">m[2][2] = 1
                        g.Tm = m
                        g.Tlm = m</span>

                case "Tr":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad Tr")</span>
                        }
                        <span class="cov0" title="0">g.Tmode = int(args[0].Int64())</span>

                case "Ts":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad Ts")</span>
                        }
                        <span class="cov0" title="0">g.Trise = args[0].Float64()</span>

                case "Tw":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad Tw")</span>
                        }
                        <span class="cov0" title="0">g.Tw = args[0].Float64()</span>

                case "Tz":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad Tz")</span>
                        }
                        <span class="cov0" title="0">g.Th = args[0].Float64() / 100</span>

                case "Do":<span class="cov0" title="0">
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("bad Do")</span>
                        }
                        <span class="cov0" title="0">ce.handleDo(args[0], resources, scope, g)</span>
                }
        })
}

func (ce *contentExtractor) appendText(g *gstate, enc TextEncoding, s string) <span class="cov0" title="0">{
        if enc == nil </span><span class="cov0" title="0">{
                enc = &amp;nopEncoder{}
        }</span>
        <span class="cov0" title="0">n := 0
        decoded := enc.Decode(s)
        vertical := g.Tf.writingMode() == 1
        for _, ch := range decoded </span><span class="cov0" title="0">{
                var w0 float64
                if n &lt; len(s) </span><span class="cov0" title="0">{
                        w0 = g.Tf.Width(int(s[n]))
                }</span>
                <span class="cov0" title="0">n++

                f := g.Tf.BaseFont()
                if i := strings.Index(f, "+"); i &gt;= 0 </span><span class="cov0" title="0">{
                        f = f[i+1:]
                }</span>

                <span class="cov0" title="0">Trm := matrix{{g.Tfs * g.Th, 0, 0}, {0, g.Tfs, 0}, {0, g.Trise, 1}}.mul(g.Tm).mul(g.CTM)
                bold, italic, underline := parseFontStyles(f)
                ce.text = append(ce.text, Text{f, Trm[0][0], Trm[2][0], Trm[2][1], w0 / 1000 * Trm[0][0], string(ch), vertical, bold, italic, underline})

                tx := w0/1000*g.Tfs + g.Tc
                tx *= g.Th
                g.Tm = matrix{{1, 0, 0}, {0, 1, 0}, {tx, 0, 1}}.mul(g.Tm)</span>
        }
}

func (ce *contentExtractor) handleDo(arg Value, resources Value, scope *fontScope, g gstate) <span class="cov0" title="0">{
        name := arg.Name()
        if name == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">xobjects := resources.Key("XObject")
        if xobjects.Kind() != Dict </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">xobj := xobjects.Key(name)
        if xobj.Kind() != Stream || xobj.Key("Subtype").Name() != "Form" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">formRes := xobj.Key("Resources")
        if formRes.Kind() == Null </span><span class="cov0" title="0">{
                formRes = resources
        }</span>
        <span class="cov0" title="0">childScope := ce.page.buildFontScope(formRes, nil, scope)
        childState := g
        if m, ok := matrixFromValue(xobj.Key("Matrix")); ok </span><span class="cov0" title="0">{
                childState.CTM = m.mul(childState.CTM)
        }</span>
        <span class="cov0" title="0">ce.process(xobj, formRes, childScope, childState)</span>
}

// TextVertical implements sort.Interface for sorting
// a slice of Text values in vertical order, top to bottom,
// and then left to right within a line.
type TextVertical []Text

func (x TextVertical) Len() int      <span class="cov0" title="0">{ return len(x) }</span>
func (x TextVertical) Swap(i, j int) <span class="cov0" title="0">{ x[i], x[j] = x[j], x[i] }</span>
func (x TextVertical) Less(i, j int) bool <span class="cov0" title="0">{
        if x[i].Y != x[j].Y </span><span class="cov0" title="0">{
                return x[i].Y &gt; x[j].Y
        }</span>
        <span class="cov0" title="0">return x[i].X &lt; x[j].X</span>
}

// TextHorizontal implements sort.Interface for sorting
// a slice of Text values in horizontal order, left to right,
// and then top to bottom within a column.
type TextHorizontal []Text

func (x TextHorizontal) Len() int      <span class="cov0" title="0">{ return len(x) }</span>
func (x TextHorizontal) Swap(i, j int) <span class="cov0" title="0">{ x[i], x[j] = x[j], x[i] }</span>
func (x TextHorizontal) Less(i, j int) bool <span class="cov0" title="0">{
        if x[i].X != x[j].X </span><span class="cov0" title="0">{
                return x[i].X &lt; x[j].X
        }</span>
        <span class="cov0" title="0">return x[i].Y &gt; x[j].Y</span>
}

// An Outline is a tree describing the outline (also known as the table of contents)
// of a document.
type Outline struct {
        Title string    // title for this element
        Child []Outline // child elements
}

// Outline returns the document outline.
// The Outline returned is the root of the outline tree and typically has no Title itself.
// That is, the children of the returned root are the top-level entries in the outline.
func (r *Reader) Outline() Outline <span class="cov0" title="0">{
        return buildOutline(r.Trailer().Key("Root").Key("Outlines"))
}</span>

func buildOutline(entry Value) Outline <span class="cov0" title="0">{
        var x Outline
        x.Title = entry.Key("Title").Text()
        for child := entry.Key("First"); child.Kind() == Dict; child = child.Key("Next") </span><span class="cov0" title="0">{
                x.Child = append(x.Child, buildOutline(child))
        }</span>
        <span class="cov0" title="0">return x</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "context"
        "runtime"
        "sort"
        "sync"
)

// ParallelProcessor handles multi-level parallel processing for PDF text extraction
type ParallelProcessor struct {
        numWorkers int
}

// NewParallelProcessor creates a new parallel processor with the specified number of workers
func NewParallelProcessor(workers int) *ParallelProcessor <span class="cov8" title="1">{
        if workers &lt;= 0 </span><span class="cov8" title="1">{
                workers = runtime.NumCPU()
        }</span>
        <span class="cov8" title="1">return &amp;ParallelProcessor{numWorkers: workers}</span>
}

// ProcessPages processes multiple pages in parallel
func (pp *ParallelProcessor) ProcessPages(ctx context.Context, pages []Page, processorFunc func(Page) ([]Text, error)) ([][]Text, error) <span class="cov8" title="1">{
        if len(pages) == 0 </span><span class="cov0" title="0">{
                return [][]Text{}, nil
        }</span>

        <span class="cov8" title="1">numWorkers := pp.numWorkers
        if numWorkers &gt; len(pages) </span><span class="cov0" title="0">{
                numWorkers = len(pages)
        }</span>

        // Create channels for work distribution
        <span class="cov8" title="1">jobChan := make(chan struct {
                index int
                page  Page
        }, len(pages))
        resultChan := make(chan struct {
                index int
                texts []Text
                err   error
        }, len(pages))

        // Start workers
        var wg sync.WaitGroup
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for job := range jobChan </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov8" title="1">
                                        resultChan &lt;- struct {
                                                index int
                                                texts []Text
                                                err   error
                                        }{index: job.index, texts: nil, err: ctx.Err()}
                                        return</span>
                                default:<span class="cov8" title="1"></span>
                                }

                                <span class="cov8" title="1">texts, err := processorFunc(job.page)
                                resultChan &lt;- struct {
                                        index int
                                        texts []Text
                                        err   error
                                }{index: job.index, texts: texts, err: err}</span>
                        }
                }()
        }

        // Send jobs
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer close(jobChan)
                for i, page := range pages </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case jobChan &lt;- struct {
                                index int
                                page  Page
                        }{index: i, page: page}:<span class="cov8" title="1"></span>
                        }
                }
        }()

        // Collect results
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultChan)
        }</span>()

        <span class="cov8" title="1">results := make([][]Text, len(pages))
        for result := range resultChan </span><span class="cov8" title="1">{
                if result.err != nil </span><span class="cov8" title="1">{
                        return nil, result.err
                }</span>
                <span class="cov8" title="1">results[result.index] = result.texts</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// ProcessTextBlocks processes multiple text blocks in parallel
func (pp *ParallelProcessor) ProcessTextBlocks(ctx context.Context, blocks []*TextBlock, processorFunc func(*TextBlock) (*TextBlock, error)) ([]*TextBlock, error) <span class="cov8" title="1">{
        if len(blocks) == 0 </span><span class="cov0" title="0">{
                return []*TextBlock{}, nil
        }</span>

        <span class="cov8" title="1">numWorkers := pp.numWorkers
        if numWorkers &gt; len(blocks) </span><span class="cov0" title="0">{
                numWorkers = len(blocks)
        }</span>

        // Create channels for work distribution
        <span class="cov8" title="1">jobChan := make(chan struct {
                index int
                block *TextBlock
        }, len(blocks))
        resultChan := make(chan struct {
                index int
                block *TextBlock
                err   error
        }, len(blocks))

        // Start workers
        var wg sync.WaitGroup
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for job := range jobChan </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        resultChan &lt;- struct {
                                                index int
                                                block *TextBlock
                                                err   error
                                        }{index: job.index, block: nil, err: ctx.Err()}
                                        return</span>
                                default:<span class="cov8" title="1"></span>
                                }

                                <span class="cov8" title="1">processedBlock, err := processorFunc(job.block)
                                resultChan &lt;- struct {
                                        index int
                                        block *TextBlock
                                        err   error
                                }{index: job.index, block: processedBlock, err: err}</span>
                        }
                }()
        }

        // Send jobs
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer close(jobChan)
                for i, block := range blocks </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case jobChan &lt;- struct {
                                index int
                                block *TextBlock
                        }{index: i, block: cloneTextBlock(block)}:<span class="cov8" title="1"></span>
                        }
                }
        }()

        // Collect results
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultChan)
        }</span>()

        <span class="cov8" title="1">results := make([]*TextBlock, len(blocks))
        for result := range resultChan </span><span class="cov8" title="1">{
                if result.err != nil </span><span class="cov0" title="0">{
                        return nil, result.err
                }</span>
                <span class="cov8" title="1">results[result.index] = result.block</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// cloneTextBlock makes a shallow copy of the TextBlock and a deep copy of the Text slice
// so that processors don't mutate the caller's data.
func cloneTextBlock(block *TextBlock) *TextBlock <span class="cov8" title="1">{
        if block == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">copied := *block
        if len(block.Texts) &gt; 0 </span><span class="cov8" title="1">{
                copiedTexts := make([]Text, len(block.Texts))
                copy(copiedTexts, block.Texts)
                copied.Texts = copiedTexts
        }</span>
        <span class="cov8" title="1">return &amp;copied</span>
}

// ProcessTextInParallel processes individual text elements in parallel
func (pp *ParallelProcessor) ProcessTextInParallel(ctx context.Context, texts []Text, processorFunc func(Text) (Text, error)) ([]Text, error) <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return []Text{}, nil
        }</span>

        <span class="cov8" title="1">numWorkers := pp.numWorkers
        if numWorkers &gt; len(texts) </span><span class="cov0" title="0">{
                numWorkers = len(texts)
        }</span>

        // For character-level processing, we may want to use smaller batches
        // to avoid creating too many goroutines
        <span class="cov8" title="1">if len(texts) &lt; numWorkers </span><span class="cov0" title="0">{
                numWorkers = len(texts)
        }</span>

        // Create channels for work distribution
        <span class="cov8" title="1">jobChan := make(chan struct {
                index int
                text  Text
        }, len(texts))
        resultChan := make(chan struct {
                index int
                text  Text
                err   error
        }, len(texts))

        // Start workers
        var wg sync.WaitGroup
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for job := range jobChan </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        resultChan &lt;- struct {
                                                index int
                                                text  Text
                                                err   error
                                        }{index: job.index, text: Text{}, err: ctx.Err()}
                                        return</span>
                                default:<span class="cov8" title="1"></span>
                                }

                                <span class="cov8" title="1">processedText, err := processorFunc(job.text)
                                resultChan &lt;- struct {
                                        index int
                                        text  Text
                                        err   error
                                }{index: job.index, text: processedText, err: err}</span>
                        }
                }()
        }

        // Send jobs
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer close(jobChan)
                for i, text := range texts </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case jobChan &lt;- struct {
                                index int
                                text  Text
                        }{index: i, text: text}:<span class="cov8" title="1"></span>
                        }
                }
        }()

        // Collect results
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultChan)
        }</span>()

        <span class="cov8" title="1">results := make([]Text, len(texts))
        for result := range resultChan </span><span class="cov8" title="1">{
                if result.err != nil </span><span class="cov0" title="0">{
                        return nil, result.err
                }</span>
                <span class="cov8" title="1">results[result.index] = result.text</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// ParallelTextExtractor provides multi-level parallel extraction
type ParallelTextExtractor struct {
        processor *ParallelProcessor
}

// NewParallelTextExtractor creates a new parallel text extractor
func NewParallelTextExtractor(workers int) *ParallelTextExtractor <span class="cov8" title="1">{
        return &amp;ParallelTextExtractor{
                processor: NewParallelProcessor(workers),
        }
}</span>

// ExtractWithParallelProcessing extracts text using multi-level parallel processing
func (pte *ParallelTextExtractor) ExtractWithParallelProcessing(ctx context.Context, reader *Reader) ([]Text, error) <span class="cov0" title="0">{
        totalPages := reader.NumPage()
        if totalPages == 0 </span><span class="cov0" title="0">{
                return []Text{}, nil
        }</span>

        // Get all pages
        <span class="cov0" title="0">pages := make([]Page, totalPages)
        for i := 1; i &lt;= totalPages; i++ </span><span class="cov0" title="0">{
                pages[i-1] = reader.Page(i)
        }</span>

        // Process pages in parallel
        <span class="cov0" title="0">pageTexts, err := pte.processor.ProcessPages(ctx, pages, func(page Page) ([]Text, error) </span><span class="cov0" title="0">{
                return page.Content().Text, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Flatten results
        <span class="cov0" title="0">var allTexts []Text
        for _, texts := range pageTexts </span><span class="cov0" title="0">{
                allTexts = append(allTexts, texts...)
        }</span>

        // Process text blocks in parallel (for classification, ordering, etc.)
        <span class="cov0" title="0">textBlocks := clusterTextBlocks(allTexts)

        // Process blocks in parallel if we have many
        if len(textBlocks) &gt; 1 </span><span class="cov0" title="0">{
                processedBlocks, err := pte.processor.ProcessTextBlocks(ctx, textBlocks, func(block *TextBlock) (*TextBlock, error) </span><span class="cov0" title="0">{
                        // In a real implementation, this might perform classification or other processing
                        return block, nil
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Flatten processed blocks back to texts
                <span class="cov0" title="0">var resultTexts []Text
                for _, block := range processedBlocks </span><span class="cov0" title="0">{
                        resultTexts = append(resultTexts, block.Texts...)
                }</span>
                <span class="cov0" title="0">return resultTexts, nil</span>
        }

        // If we don't have many blocks, just return the original texts
        <span class="cov0" title="0">return allTexts, nil</span>
}

// ParallelSort provides parallel sorting for large text collections
func (pte *ParallelTextExtractor) ParallelSort(ctx context.Context, texts []Text, less func(i, j int) bool) error <span class="cov8" title="1">{
        if len(texts) &lt;= 1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // For smaller collections, use the standard library sort for better efficiency
        <span class="cov8" title="1">if len(texts) &lt; 10000 </span><span class="cov8" title="1">{
                sort.Slice(texts, less)
                return ctx.Err()
        }</span>

        <span class="cov8" title="1">workers := pte.processor.numWorkers
        if workers &lt; 2 </span><span class="cov0" title="0">{
                workers = 2
        }</span>

        <span class="cov8" title="1">chunkSize := (len(texts) + workers - 1) / workers
        if chunkSize &lt; 1000 </span><span class="cov0" title="0">{
                chunkSize = 1000
        }</span>
        <span class="cov8" title="1">if chunkSize &gt; len(texts) </span><span class="cov0" title="0">{
                chunkSize = len(texts)
        }</span>

        <span class="cov8" title="1">type job struct {
                start int
                end   int
        }

        jobs := make(chan job)
        errChan := make(chan error, 1)
        var wg sync.WaitGroup

        worker := func() </span><span class="cov8" title="1">{
                defer wg.Done()
                for job := range jobs </span><span class="cov8" title="1">{
                        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                                select </span>{
                                case errChan &lt;- err:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                }
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov8" title="1">sort.Slice(texts[job.start:job.end], func(i, j int) bool </span><span class="cov8" title="1">{
                                return less(job.start+i, job.start+j)
                        }</span>)
                }
        }

        <span class="cov8" title="1">for i := 0; i &lt; workers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go worker()
        }</span>

        <span class="cov8" title="1">for start := 0; start &lt; len(texts); start += chunkSize </span><span class="cov8" title="1">{
                end := start + chunkSize
                if end &gt; len(texts) </span><span class="cov0" title="0">{
                        end = len(texts)
                }</span>

                <span class="cov8" title="1">select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        close(jobs)
                        wg.Wait()
                        return ctx.Err()</span>
                case jobs &lt;- job{start: start, end: end}:<span class="cov8" title="1"></span>
                }
        }
        <span class="cov8" title="1">close(jobs)
        wg.Wait()

        select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">temp := make([]Text, len(texts))
        if err := mergeChunksWithContext(ctx, texts, temp, chunkSize, less); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return ctx.Err()</span>
}

// mergeChunksWithContext merges sorted chunks while honoring context cancellation.
func mergeChunksWithContext(ctx context.Context, texts, temp []Text, chunkSize int, less func(i, j int) bool) error <span class="cov8" title="1">{
        if chunkSize &lt;= 0 || chunkSize &gt;= len(texts) </span><span class="cov0" title="0">{
                return ctx.Err()
        }</span>

        <span class="cov8" title="1">for currentSize := chunkSize; currentSize &lt; len(texts); currentSize *= 2 </span><span class="cov8" title="1">{
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for start := 0; start &lt; len(texts); start += 2 * currentSize </span><span class="cov8" title="1">{
                        mid := start + currentSize
                        if mid &gt; len(texts) </span><span class="cov0" title="0">{
                                mid = len(texts)
                        }</span>
                        <span class="cov8" title="1">end := start + 2*currentSize
                        if end &gt; len(texts) </span><span class="cov0" title="0">{
                                end = len(texts)
                        }</span>

                        <span class="cov8" title="1">if mid &gt;= end </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">mergeRanges(texts, temp, start, mid, end, less)
                        copy(texts[start:end], temp[start:end])</span>
                }
        }

        <span class="cov8" title="1">return ctx.Err()</span>
}

// mergeRanges merges two sorted ranges [start,mid) and [mid,end) into temp.
func mergeRanges(texts, temp []Text, start, mid, end int, less func(i, j int) bool) <span class="cov8" title="1">{
        i, j, k := start, mid, start

        for i &lt; mid &amp;&amp; j &lt; end </span><span class="cov8" title="1">{
                if less(i, j) || !less(j, i) </span><span class="cov0" title="0">{
                        temp[k] = texts[i]
                        i++
                }</span> else<span class="cov8" title="1"> {
                        temp[k] = texts[j]
                        j++
                }</span>
                <span class="cov8" title="1">k++</span>
        }

        <span class="cov8" title="1">for i &lt; mid </span><span class="cov8" title="1">{
                temp[k] = texts[i]
                i++
                k++
        }</span>
        <span class="cov8" title="1">for j &lt; end </span><span class="cov0" title="0">{
                temp[k] = texts[j]
                j++
                k++
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "fmt"
        "io"
        "strings"
        "sync"
)

// Performance optimizations using object pools and efficient memory management

// Pool for small Text objects (short strings, &lt; 100 chars)
var smallTextPool = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{
                return &amp;Text{}
        }</span>,
}

// Pool for large Text objects (long strings, &gt;= 100 chars)
var largeTextPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;Text{}
        }</span>,
}

// Pool for Text objects (used in styled text extraction) - general pool
var textPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;Text{}
        }</span>,
}

// GetText retrieves a Text object from the appropriate pool based on content size
func GetText() *Text <span class="cov8" title="1">{
        return textPool.Get().(*Text)
}</span>

// GetTextBySize retrieves a Text object from the appropriate pool based on content size
func GetTextBySize(contentLength int) *Text <span class="cov8" title="1">{
        if contentLength &lt; 100 </span><span class="cov8" title="1">{
                return smallTextPool.Get().(*Text)
        }</span>
        <span class="cov8" title="1">return largeTextPool.Get().(*Text)</span>
}

// PutText returns a Text object to the appropriate pool
func PutText(t *Text) <span class="cov8" title="1">{
        // Determine pool based on content size before reset
        useSmallPool := len(t.S) &lt; 100

        // Reset the object before returning to pool
        *t = Text{}

        // Return to appropriate pool
        if useSmallPool </span><span class="cov8" title="1">{
                smallTextPool.Put(t)
        }</span> else<span class="cov0" title="0"> {
                largeTextPool.Put(t)
        }</span>
}

// Pool for strings.Builder (used for text accumulation)
var builderPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;strings.Builder{}
        }</span>,
}

// GetBuilder retrieves a strings.Builder from the pool
func GetBuilder() *strings.Builder <span class="cov8" title="1">{
        return builderPool.Get().(*strings.Builder)
}</span>

// PutBuilder returns a strings.Builder to the pool after resetting it
func PutBuilder(b *strings.Builder) <span class="cov8" title="1">{
        b.Reset()
        builderPool.Put(b)
}</span>

// Pool for ClassifiedBlock slices (used in text classification)
var blockSlicePool = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{
                // Pre-allocate with reasonable capacity
                s := make([]ClassifiedBlock, 0, 16)
                return &amp;s
        }</span>,
}

// GetBlockSlice retrieves a ClassifiedBlock slice from the pool
func GetBlockSlice() []ClassifiedBlock <span class="cov0" title="0">{
        return *blockSlicePool.Get().(*[]ClassifiedBlock)
}</span>

// PutBlockSlice returns a ClassifiedBlock slice to the pool
func PutBlockSlice(s []ClassifiedBlock) <span class="cov0" title="0">{
        // Clear the slice but keep the capacity
        s = s[:0]
        blockSlicePool.Put(&amp;s)
}</span>

// Pool for Text slices (used in text extraction)
var textSlicePool = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{
                s := make([]Text, 0, 32)
                return &amp;s
        }</span>,
}

// GetTextSlice retrieves a Text slice from the pool
func GetTextSlice() []Text <span class="cov0" title="0">{
        return *textSlicePool.Get().(*[]Text)
}</span>

// PutTextSlice returns a Text slice to the pool
func PutTextSlice(s []Text) <span class="cov0" title="0">{
        s = s[:0]
        textSlicePool.Put(&amp;s)
}</span>

// Pool for byte buffers (used in various operations)
var byteBufferPool = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{
                buf := make([]byte, 0, 4096) // 4KB initial capacity
                return &amp;buf
        }</span>,
}

// GetByteBuffer retrieves a byte buffer from the pool
func GetByteBuffer() *[]byte <span class="cov0" title="0">{
        return byteBufferPool.Get().(*[]byte)
}</span>

// PutByteBuffer returns a byte buffer to the pool
func PutByteBuffer(buf *[]byte) <span class="cov0" title="0">{
        *buf = (*buf)[:0]
        byteBufferPool.Put(buf)
}</span>

// Pool for PDF buffers (used in lexing and parsing)
var pdfBufferPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;buffer{
                        buf:         make([]byte, 0, 65536), // 64KB capacity
                        tmp:         make([]byte, 0, 256),   // 256B for tokens
                        unread:      make([]token, 0, 16),   // capacity for unread tokens
                        key:         make([]byte, 0, 64),    // capacity for keys
                        allowObjptr: true,
                        allowStream: true,
                }
        }</span>,
}

// GetPDFBuffer retrieves a PDF buffer from the pool
func GetPDFBuffer() *buffer <span class="cov8" title="1">{
        return pdfBufferPool.Get().(*buffer)
}</span>

// PutPDFBuffer returns a PDF buffer to the pool after resetting
func PutPDFBuffer(b *buffer) <span class="cov0" title="0">{
        // Reset all fields
        b.r = nil
        b.buf = b.buf[:0]
        b.pos = 0
        b.offset = 0
        b.tmp = b.tmp[:0]
        b.unread = b.unread[:0]
        b.allowEOF = false
        b.allowObjptr = true
        b.allowStream = true
        b.eof = false
        b.key = b.key[:0]
        b.useAES = false
        b.objptr = objptr{}
        pdfBufferPool.Put(b)
}</span>

// FastStringBuilder provides optimized string building with pre-allocation
type FastStringBuilder struct {
        buf []byte
}

// NewFastStringBuilder creates a builder with estimated capacity
func NewFastStringBuilder(estimatedSize int) *FastStringBuilder <span class="cov8" title="1">{
        return &amp;FastStringBuilder{
                buf: make([]byte, 0, EstimateCapacity(estimatedSize, 1.5)),
        }
}</span>

// WriteString appends a string
func (b *FastStringBuilder) WriteString(s string) <span class="cov8" title="1">{
        b.buf = append(b.buf, s...)
}</span>

// WriteByte appends a byte
func (b *FastStringBuilder) WriteByte(c byte) error <span class="cov0" title="0">{
        b.buf = append(b.buf, c)
        return nil
}</span>

// String returns the accumulated string
func (b *FastStringBuilder) String() string <span class="cov8" title="1">{
        return string(b.buf)
}</span>

// Len returns the current length
func (b *FastStringBuilder) Len() int <span class="cov8" title="1">{
        return len(b.buf)
}</span>

// Reset clears the builder
func (b *FastStringBuilder) Reset() <span class="cov8" title="1">{
        b.buf = b.buf[:0]
}</span>

// LazyPage provides lazy loading of page content to reduce memory usage
// for large PDFs where not all pages need to be processed
type LazyPage struct {
        reader  *Reader
        pageNum int
        content *Content // nil until loaded
        mu      sync.RWMutex
}

// NewLazyPage creates a lazy-loading page wrapper
func NewLazyPage(r *Reader, pageNum int) *LazyPage <span class="cov0" title="0">{
        return &amp;LazyPage{
                reader:  r,
                pageNum: pageNum,
        }
}</span>

// GetContent loads and returns the page content (cached after first call)
func (lp *LazyPage) GetContent() *Content <span class="cov0" title="0">{
        lp.mu.RLock()
        if lp.content != nil </span><span class="cov0" title="0">{
                content := lp.content
                lp.mu.RUnlock()
                return content
        }</span>
        <span class="cov0" title="0">lp.mu.RUnlock()

        lp.mu.Lock()
        defer lp.mu.Unlock()

        // Double-check after acquiring write lock
        if lp.content != nil </span><span class="cov0" title="0">{
                return lp.content
        }</span>

        // Load the content
        <span class="cov0" title="0">page := lp.reader.Page(lp.pageNum)
        content := page.Content()
        lp.content = &amp;content

        return lp.content</span>
}

// Release clears the cached content to free memory
func (lp *LazyPage) Release() <span class="cov0" title="0">{
        lp.mu.Lock()
        defer lp.mu.Unlock()
        lp.content = nil
}</span>

// IsLoaded returns whether the page content has been loaded
func (lp *LazyPage) IsLoaded() bool <span class="cov0" title="0">{
        lp.mu.RLock()
        defer lp.mu.RUnlock()
        return lp.content != nil
}</span>

// LazyPageManager manages lazy loading of multiple pages
type LazyPageManager struct {
        reader     *Reader
        pages      map[int]*LazyPage
        maxCached  int // Maximum number of pages to keep in memory
        mu         sync.RWMutex
        accessList []int // LRU tracking
}

// NewLazyPageManager creates a manager with LRU cache
func NewLazyPageManager(r *Reader, maxCached int) *LazyPageManager <span class="cov0" title="0">{
        if maxCached &lt;= 0 </span><span class="cov0" title="0">{
                maxCached = 10 // Default to 10 pages
        }</span>
        <span class="cov0" title="0">return &amp;LazyPageManager{
                reader:     r,
                pages:      make(map[int]*LazyPage),
                maxCached:  maxCached,
                accessList: make([]int, 0, maxCached),
        }</span>
}

// GetPage returns a lazy page, loading it if necessary
func (m *LazyPageManager) GetPage(pageNum int) *LazyPage <span class="cov0" title="0">{
        m.mu.RLock()
        if page, ok := m.pages[pageNum]; ok </span><span class="cov0" title="0">{
                m.mu.RUnlock()
                m.updateAccess(pageNum)
                return page
        }</span>
        <span class="cov0" title="0">m.mu.RUnlock()

        m.mu.Lock()
        defer m.mu.Unlock()

        // Double-check
        if page, ok := m.pages[pageNum]; ok </span><span class="cov0" title="0">{
                m.updateAccessLocked(pageNum)
                return page
        }</span>

        // Create new lazy page
        <span class="cov0" title="0">page := NewLazyPage(m.reader, pageNum)
        m.pages[pageNum] = page
        m.updateAccessLocked(pageNum)

        // Enforce cache limit
        if len(m.accessList) &gt; m.maxCached </span><span class="cov0" title="0">{
                oldest := m.accessList[0]
                if oldPage, ok := m.pages[oldest]; ok </span><span class="cov0" title="0">{
                        oldPage.Release()
                }</span>
                <span class="cov0" title="0">m.accessList = m.accessList[1:]</span>
        }

        <span class="cov0" title="0">return page</span>
}

// updateAccess updates the LRU access list (with lock)
func (m *LazyPageManager) updateAccess(pageNum int) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.updateAccessLocked(pageNum)
}</span>

// updateAccessLocked updates the LRU access list (caller must hold lock)
func (m *LazyPageManager) updateAccessLocked(pageNum int) <span class="cov0" title="0">{
        // Remove from current position
        for i, p := range m.accessList </span><span class="cov0" title="0">{
                if p == pageNum </span><span class="cov0" title="0">{
                        m.accessList = append(m.accessList[:i], m.accessList[i+1:]...)
                        break</span>
                }
        }
        // Add to end (most recently used)
        <span class="cov0" title="0">m.accessList = append(m.accessList, pageNum)</span>
}

// Clear releases all cached pages
func (m *LazyPageManager) Clear() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for _, page := range m.pages </span><span class="cov0" title="0">{
                page.Release()
        }</span>
        <span class="cov0" title="0">m.pages = make(map[int]*LazyPage)
        m.accessList = m.accessList[:0]</span>
}

// GetStats returns cache statistics
func (m *LazyPageManager) GetStats() (totalPages, loadedPages int) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        totalPages = len(m.pages)
        for _, page := range m.pages </span><span class="cov0" title="0">{
                if page.IsLoaded() </span><span class="cov0" title="0">{
                        loadedPages++
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// ResourceManager provides automatic resource cleanup
type ResourceManager struct {
        resources []io.Closer
        mu        sync.Mutex
}

// NewResourceManager creates a new resource manager
func NewResourceManager() *ResourceManager <span class="cov8" title="1">{
        return &amp;ResourceManager{
                resources: make([]io.Closer, 0, 8),
        }
}</span>

// Add adds a resource to be managed
func (rm *ResourceManager) Add(resource io.Closer) <span class="cov8" title="1">{
        rm.mu.Lock()
        defer rm.mu.Unlock()
        rm.resources = append(rm.resources, resource)
}</span>

// Close closes all managed resources
func (rm *ResourceManager) Close() error <span class="cov8" title="1">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        var errs []error
        for _, resource := range rm.resources </span><span class="cov8" title="1">{
                if err := resource.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov8" title="1">rm.resources = rm.resources[:0] // Clear the slice

        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("resource cleanup errors: %v", errs)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "math/bits"
        "sync"
)

// SizedBytePool implements a multi-level size-bucketed object pool
// for byte slices. It reduces memory allocation overhead by reusing
// buffers of appropriate sizes.
//
// Size buckets: 16B, 32B, 64B, 128B, 256B, 512B, 1KB, 4KB
type SizedBytePool struct {
        pools [8]*sync.Pool
        sizes [8]int
}

// Global sized byte pool instance
var globalSizedBytePool = NewSizedBytePool()

// NewSizedBytePool creates a new sized byte pool with 8 size buckets
func NewSizedBytePool() *SizedBytePool <span class="cov8" title="1">{
        sp := &amp;SizedBytePool{
                sizes: [8]int{16, 32, 64, 128, 256, 512, 1024, 4096},
        }

        // Initialize each pool with a factory function
        for i := 0; i &lt; 8; i++ </span><span class="cov8" title="1">{
                size := sp.sizes[i]
                sp.pools[i] = &amp;sync.Pool{
                        New: func() interface{} </span><span class="cov8" title="1">{
                                buf := make([]byte, 0, size)
                                return &amp;buf
                        }</span>,
                }
        }

        <span class="cov8" title="1">return sp</span>
}

// Get retrieves a byte slice from the appropriate size bucket
// Returns a buffer with at least the requested capacity
func (sp *SizedBytePool) Get(size int) []byte <span class="cov8" title="1">{
        if size &lt;= 0 </span><span class="cov0" title="0">{
                size = 16 // minimum size
        }</span>

        <span class="cov8" title="1">idx := sp.getBucketIndex(size)
        if idx &gt;= len(sp.pools) </span><span class="cov8" title="1">{
                // Size exceeds largest bucket, allocate directly
                return make([]byte, 0, size)
        }</span>

        <span class="cov8" title="1">bufPtr := sp.pools[idx].Get().(*[]byte)
        buf := *bufPtr

        // Ensure the buffer has the requested capacity
        if cap(buf) &lt; size </span><span class="cov0" title="0">{
                // This shouldn't happen, but handle it gracefully
                return make([]byte, 0, size)
        }</span>

        <span class="cov8" title="1">return buf[:0]</span> // Reset length to 0, keep capacity
}

// Put returns a byte slice to the appropriate pool
// The slice is cleared before being returned to the pool
func (sp *SizedBytePool) Put(buf []byte) <span class="cov8" title="1">{
        if buf == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">capacity := cap(buf)
        idx := sp.getBucketIndex(capacity)

        // Only pool if it fits in one of our buckets
        if idx &lt; len(sp.pools) &amp;&amp; capacity == sp.sizes[idx] </span><span class="cov8" title="1">{
                buf = buf[:0] // Clear the slice
                sp.pools[idx].Put(&amp;buf)
        }</span>
        // Otherwise, let GC handle it
}

// getBucketIndex returns the appropriate bucket index for a given size
// Uses bit manipulation for fast log2 calculation
func (sp *SizedBytePool) getBucketIndex(size int) int <span class="cov8" title="1">{
        if size &lt;= 16 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if size &gt; 4096 </span><span class="cov8" title="1">{
                return 8 // exceeds max bucket
        }</span>

        // Calculate log2 and adjust for our bucket sizes
        // sizes[i] = 16 * 2^i, so log2(size/16) gives us the index
        // For exact power of 2 sizes, we need to use the same bucket
        <span class="cov8" title="1">idx := bits.Len(uint(size-1)) - 4
        if idx &gt;= 8 </span><span class="cov8" title="1">{
                return 7 // clamp to max bucket index
        }</span>
        <span class="cov8" title="1">return idx</span>
}

// GetStats returns statistics about pool usage (for debugging/monitoring)
type PoolStats struct {
        BucketSize int
        InUse      int // approximation, not perfectly accurate
}

// GetSizedBuffer retrieves a byte buffer from the global sized pool
// This is a convenience function for common use cases
func GetSizedBuffer(size int) []byte <span class="cov8" title="1">{
        return globalSizedBytePool.Get(size)
}</span>

// PutSizedBuffer returns a byte buffer to the global sized pool
// This is a convenience function for common use cases
func PutSizedBuffer(buf []byte) <span class="cov8" title="1">{
        globalSizedBytePool.Put(buf)
}</span>

// SizedTextSlicePool implements a size-bucketed pool for Text slices
// Similar to SizedBytePool but for []Text instead of []byte
type SizedTextSlicePool struct {
        pools [6]*sync.Pool
        sizes [6]int
}

// Global sized text slice pool instance
var globalSizedTextSlicePool = NewSizedTextSlicePool()

// NewSizedTextSlicePool creates a new sized text slice pool
// Buckets: 8, 16, 32, 64, 128, 256 texts
func NewSizedTextSlicePool() *SizedTextSlicePool <span class="cov8" title="1">{
        sp := &amp;SizedTextSlicePool{
                sizes: [6]int{8, 16, 32, 64, 128, 256},
        }

        for i := 0; i &lt; 6; i++ </span><span class="cov8" title="1">{
                size := sp.sizes[i]
                sp.pools[i] = &amp;sync.Pool{
                        New: func() interface{} </span><span class="cov8" title="1">{
                                slice := make([]Text, 0, size)
                                return &amp;slice
                        }</span>,
                }
        }

        <span class="cov8" title="1">return sp</span>
}

// Get retrieves a Text slice from the appropriate size bucket
func (sp *SizedTextSlicePool) Get(size int) []Text <span class="cov8" title="1">{
        if size &lt;= 0 </span><span class="cov0" title="0">{
                size = 8
        }</span>

        <span class="cov8" title="1">idx := sp.getBucketIndex(size)
        if idx &gt;= len(sp.pools) </span><span class="cov0" title="0">{
                return make([]Text, 0, size)
        }</span>

        <span class="cov8" title="1">slicePtr := sp.pools[idx].Get().(*[]Text)
        slice := *slicePtr
        return slice[:0]</span>
}

// Put returns a Text slice to the appropriate pool
func (sp *SizedTextSlicePool) Put(slice []Text) <span class="cov8" title="1">{
        if slice == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">capacity := cap(slice)
        idx := sp.getBucketIndex(capacity)

        if idx &lt; len(sp.pools) &amp;&amp; capacity == sp.sizes[idx] </span><span class="cov8" title="1">{
                // Clear the slice elements to avoid memory leaks
                for i := range slice </span><span class="cov8" title="1">{
                        slice[i] = Text{}
                }</span>
                <span class="cov8" title="1">slice = slice[:0]
                sp.pools[idx].Put(&amp;slice)</span>
        }
}

// getBucketIndex returns the bucket index for Text slices
func (sp *SizedTextSlicePool) getBucketIndex(size int) int <span class="cov8" title="1">{
        if size &lt;= 8 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if size &gt; 256 </span><span class="cov0" title="0">{
                return 6
        }</span>

        // Find the smallest bucket that fits
        <span class="cov8" title="1">for i, bucketSize := range sp.sizes </span><span class="cov8" title="1">{
                if size &lt;= bucketSize </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return len(sp.sizes)</span>
}

// GetSizedTextSlice retrieves a Text slice from the global pool
func GetSizedTextSlice(size int) []Text <span class="cov8" title="1">{
        return globalSizedTextSlicePool.Get(size)
}</span>

// PutSizedTextSlice returns a Text slice to the global pool
func PutSizedTextSlice(slice []Text) <span class="cov8" title="1">{
        globalSizedTextSlicePool.Put(slice)
}</span>

// StringBuilderPool provides size-aware string builder pooling
type StringBuilderPool struct {
        small  sync.Pool // &lt; 1KB
        medium sync.Pool // 1KB - 16KB
        large  sync.Pool // &gt; 16KB
}

// Global string builder pool
var globalStringBuilderPool = &amp;StringBuilderPool{
        small: sync.Pool{
                New: func() interface{} <span class="cov8" title="1">{
                        sb := &amp;FastStringBuilder{buf: make([]byte, 0, 512)}
                        return sb
                }</span>,
        },
        medium: sync.Pool{
                New: func() interface{} <span class="cov8" title="1">{
                        sb := &amp;FastStringBuilder{buf: make([]byte, 0, 8192)}
                        return sb
                }</span>,
        },
        large: sync.Pool{
                New: func() interface{} <span class="cov8" title="1">{
                        sb := &amp;FastStringBuilder{buf: make([]byte, 0, 65536)}
                        return sb
                }</span>,
        },
}

// GetSizedStringBuilder retrieves a string builder from the appropriate pool
func GetSizedStringBuilder(estimatedSize int) *FastStringBuilder <span class="cov8" title="1">{
        var sb *FastStringBuilder

        switch </span>{
        case estimatedSize &lt; 1024:<span class="cov8" title="1">
                sb = globalStringBuilderPool.small.Get().(*FastStringBuilder)</span>
        case estimatedSize &lt; 16384:<span class="cov8" title="1">
                sb = globalStringBuilderPool.medium.Get().(*FastStringBuilder)</span>
        default:<span class="cov8" title="1">
                sb = globalStringBuilderPool.large.Get().(*FastStringBuilder)</span>
        }

        <span class="cov8" title="1">sb.Reset()
        return sb</span>
}

// PutSizedStringBuilder returns a string builder to the appropriate pool
func PutSizedStringBuilder(sb *FastStringBuilder, estimatedSize int) <span class="cov8" title="1">{
        if sb == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">sb.Reset()

        switch </span>{
        case estimatedSize &lt; 1024:<span class="cov8" title="1">
                globalStringBuilderPool.small.Put(sb)</span>
        case estimatedSize &lt; 16384:<span class="cov8" title="1">
                globalStringBuilderPool.medium.Put(sb)</span>
        default:<span class="cov8" title="1">
                globalStringBuilderPool.large.Put(sb)</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "runtime"
        "runtime/debug"
        "sync"
        "sync/atomic"
)

// PoolWarmer 
// 
type PoolWarmer struct {
        bytePool     *SizedBytePool
        textPool     *SizedTextSlicePool
        warmed       atomic.Value // bool
        warmingMutex sync.Mutex
}

// GlobalPoolWarmer 
var GlobalPoolWarmer = &amp;PoolWarmer{
        bytePool: globalSizedBytePool,
        textPool: globalSizedTextSlicePool,
}

func init() <span class="cov8" title="1">{
        GlobalPoolWarmer.warmed.Store(false)
}</span>

// WarmupConfig 
type WarmupConfig struct {
        // BytePoolWarmup 
        BytePoolWarmup map[int]int

        // TextPoolWarmup 
        TextPoolWarmup map[int]int

        // Concurrent 
        Concurrent bool

        // MaxGoroutines  goroutine 
        MaxGoroutines int
}

// DefaultWarmupConfig 
func DefaultWarmupConfig() *WarmupConfig <span class="cov8" title="1">{
        return &amp;WarmupConfig{
                BytePoolWarmup: map[int]int{
                        16:   100,
                        32:   100,
                        64:   80,
                        128:  60,
                        256:  40,
                        512:  30,
                        1024: 20,
                        4096: 10,
                },
                TextPoolWarmup: map[int]int{
                        8:   50,
                        16:  40,
                        32:  30,
                        64:  20,
                        128: 10,
                        256: 5,
                },
                Concurrent:    true,
                MaxGoroutines: runtime.NumCPU(),
        }
}</span>

// AggressiveWarmupConfig 
func AggressiveWarmupConfig() *WarmupConfig <span class="cov8" title="1">{
        return &amp;WarmupConfig{
                BytePoolWarmup: map[int]int{
                        16:   500,
                        32:   500,
                        64:   400,
                        128:  300,
                        256:  200,
                        512:  150,
                        1024: 100,
                        4096: 50,
                },
                TextPoolWarmup: map[int]int{
                        8:   200,
                        16:  150,
                        32:  100,
                        64:  75,
                        128: 50,
                        256: 25,
                },
                Concurrent:    true,
                MaxGoroutines: runtime.NumCPU() * 2,
        }
}</span>

// LightWarmupConfig 
func LightWarmupConfig() *WarmupConfig <span class="cov8" title="1">{
        return &amp;WarmupConfig{
                BytePoolWarmup: map[int]int{
                        16:   20,
                        32:   20,
                        64:   15,
                        128:  10,
                        256:  8,
                        512:  5,
                        1024: 3,
                        4096: 2,
                },
                TextPoolWarmup: map[int]int{
                        8:   10,
                        16:  8,
                        32:  6,
                        64:  4,
                        128: 2,
                        256: 1,
                },
                Concurrent:    false,
                MaxGoroutines: 1,
        }
}</span>

// Warmup 
func (pw *PoolWarmer) Warmup(config *WarmupConfig) error <span class="cov8" title="1">{
        pw.warmingMutex.Lock()
        defer pw.warmingMutex.Unlock()

        if pw.IsWarmed() </span><span class="cov8" title="1">{
                return nil // 
        }</span>

        <span class="cov8" title="1">if config == nil </span><span class="cov0" title="0">{
                config = DefaultWarmupConfig()
        }</span>

        <span class="cov8" title="1">if config.Concurrent </span><span class="cov8" title="1">{
                pw.warmupConcurrent(config)
        }</span> else<span class="cov8" title="1"> {
                pw.warmupSequential(config)
        }</span>

        <span class="cov8" title="1">pw.warmed.Store(true)
        return nil</span>
}

// warmupSequential 
func (pw *PoolWarmer) warmupSequential(config *WarmupConfig) <span class="cov8" title="1">{
        // 
        for size, count := range config.BytePoolWarmup </span><span class="cov8" title="1">{
                buffers := make([][]byte, count)
                for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                        buffers[i] = pw.bytePool.Get(size)
                }</span>
                // 
                <span class="cov8" title="1">for _, buf := range buffers </span><span class="cov8" title="1">{
                        pw.bytePool.Put(buf)
                }</span>
        }

        // 
        <span class="cov8" title="1">for size, count := range config.TextPoolWarmup </span><span class="cov8" title="1">{
                slices := make([][]Text, count)
                for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                        slices[i] = pw.textPool.Get(size)
                }</span>
                // 
                <span class="cov8" title="1">for _, slice := range slices </span><span class="cov8" title="1">{
                        pw.textPool.Put(slice)
                }</span>
        }
}

// warmupConcurrent 
func (pw *PoolWarmer) warmupConcurrent(config *WarmupConfig) <span class="cov8" title="1">{
        var wg sync.WaitGroup
        semaphore := make(chan struct{}, config.MaxGoroutines)

        // 
        for size, count := range config.BytePoolWarmup </span><span class="cov8" title="1">{
                wg.Add(1)
                semaphore &lt;- struct{}{}

                go func(sz, cnt int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        defer func() </span><span class="cov8" title="1">{ &lt;-semaphore }</span>()

                        <span class="cov8" title="1">buffers := make([][]byte, cnt)
                        for i := 0; i &lt; cnt; i++ </span><span class="cov8" title="1">{
                                buffers[i] = pw.bytePool.Get(sz)
                        }</span>
                        <span class="cov8" title="1">for _, buf := range buffers </span><span class="cov8" title="1">{
                                pw.bytePool.Put(buf)
                        }</span>
                }(size, count)
        }

        // 
        <span class="cov8" title="1">for size, count := range config.TextPoolWarmup </span><span class="cov8" title="1">{
                wg.Add(1)
                semaphore &lt;- struct{}{}

                go func(sz, cnt int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        defer func() </span><span class="cov8" title="1">{ &lt;-semaphore }</span>()

                        <span class="cov8" title="1">slices := make([][]Text, cnt)
                        for i := 0; i &lt; cnt; i++ </span><span class="cov8" title="1">{
                                slices[i] = pw.textPool.Get(sz)
                        }</span>
                        <span class="cov8" title="1">for _, slice := range slices </span><span class="cov8" title="1">{
                                pw.textPool.Put(slice)
                        }</span>
                }(size, count)
        }

        <span class="cov8" title="1">wg.Wait()</span>
}

// IsWarmed 
func (pw *PoolWarmer) IsWarmed() bool <span class="cov8" title="1">{
        warmed, ok := pw.warmed.Load().(bool)
        return ok &amp;&amp; warmed
}</span>

// Reset 
func (pw *PoolWarmer) Reset() <span class="cov8" title="1">{
        pw.warmingMutex.Lock()
        defer pw.warmingMutex.Unlock()
        pw.warmed.Store(false)
}</span>

// WarmupGlobal 
func WarmupGlobal(config *WarmupConfig) error <span class="cov0" title="0">{
        return GlobalPoolWarmer.Warmup(config)
}</span>

// AutoWarmup 
func AutoWarmup() error <span class="cov8" title="1">{
        var ms runtime.MemStats
        runtime.ReadMemStats(&amp;ms)

        // 
        var config *WarmupConfig
        if ms.Sys &gt; 1024*1024*1024 </span><span class="cov0" title="0">{ // &gt; 1GB
                config = AggressiveWarmupConfig()
        }</span> else<span class="cov8" title="1"> if ms.Sys &gt; 256*1024*1024 </span><span class="cov0" title="0">{ // &gt; 256MB
                config = DefaultWarmupConfig()
        }</span> else<span class="cov8" title="1"> {
                config = LightWarmupConfig()
        }</span>

        <span class="cov8" title="1">return GlobalPoolWarmer.Warmup(config)</span>
}

// PreallocateCache 
func PreallocateCache(fontCacheSize, resultCacheSize int) <span class="cov8" title="1">{
        if fontCacheSize &gt; 0 </span><span class="cov8" title="1">{
                _ = NewOptimizedFontCache(fontCacheSize)
        }</span>
        <span class="cov8" title="1">if resultCacheSize &gt; 0 </span><span class="cov8" title="1">{
                _ = NewShardedCache(resultCacheSize, 0)
        }</span>
}

// WarmupStats 
type WarmupStats struct {
        BytePoolSizes  map[int]int
        TextPoolSizes  map[int]int
        TotalAllocated int64
        IsWarmed       bool
}

// GetWarmupStats 
func (pw *PoolWarmer) GetWarmupStats() WarmupStats <span class="cov0" title="0">{
        return WarmupStats{
                IsWarmed: pw.IsWarmed(),
        }
}</span>

// OptimizedStartup 
// 
func OptimizedStartup(config *StartupConfig) error <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultStartupConfig()
        }</span>

        // 1. 
        <span class="cov8" title="1">if config.WarmupPools </span><span class="cov8" title="1">{
                if err := GlobalPoolWarmer.Warmup(config.WarmupConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 2. 
        <span class="cov8" title="1">if config.PreallocateCaches </span><span class="cov8" title="1">{
                PreallocateCache(config.FontCacheSize, config.ResultCacheSize)
        }</span>

        // 3.  GC 
        <span class="cov8" title="1">if config.TuneGC </span><span class="cov0" title="0">{
                //  GC  100
                //  GC 
                if config.GCPercent &gt; 0 </span><span class="cov0" title="0">{
                        debug.SetGCPercent(config.GCPercent)
                }</span>

                //  GC 
                <span class="cov0" title="0">if config.MemoryBallast &gt; 0 </span><span class="cov0" title="0">{
                        _ = make([]byte, config.MemoryBallast)
                }</span>
        }

        // 4.  GOMAXPROCS
        <span class="cov8" title="1">if config.SetMaxProcs </span><span class="cov0" title="0">{
                if config.MaxProcs &lt;= 0 </span><span class="cov0" title="0">{
                        config.MaxProcs = runtime.NumCPU()
                }</span>
                <span class="cov0" title="0">runtime.GOMAXPROCS(config.MaxProcs)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// StartupConfig 
type StartupConfig struct {
        WarmupPools       bool
        WarmupConfig      *WarmupConfig
        PreallocateCaches bool
        FontCacheSize     int
        ResultCacheSize   int
        TuneGC            bool
        GCPercent         int
        MemoryBallast     int64
        SetMaxProcs       bool
        MaxProcs          int
}

// DefaultStartupConfig 
func DefaultStartupConfig() *StartupConfig <span class="cov0" title="0">{
        return &amp;StartupConfig{
                WarmupPools:       true,
                WarmupConfig:      DefaultWarmupConfig(),
                PreallocateCaches: true,
                FontCacheSize:     1000,
                ResultCacheSize:   10000,
                TuneGC:            true,
                GCPercent:         200,              //  GC 
                MemoryBallast:     10 * 1024 * 1024, // 10MB ballast
                SetMaxProcs:       true,
                MaxProcs:          0, // 
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "io"
)

// A Stack represents a stack of values.
type Stack struct {
        stack []Value
}

func (stk *Stack) Len() int <span class="cov0" title="0">{
        return len(stk.stack)
}</span>

func (stk *Stack) Push(v Value) <span class="cov0" title="0">{
        stk.stack = append(stk.stack, v)
}</span>

func (stk *Stack) Pop() Value <span class="cov0" title="0">{
        n := len(stk.stack)
        if n == 0 </span><span class="cov0" title="0">{
                return Value{}
        }</span>
        <span class="cov0" title="0">v := stk.stack[n-1]
        stk.stack[n-1] = Value{}
        stk.stack = stk.stack[:n-1]
        return v</span>
}

func newDict() Value <span class="cov0" title="0">{
        return Value{nil, objptr{}, make(dict)}
}</span>

// Interpret interprets the content in a stream as a basic PostScript program,
// pushing values onto a stack and then calling the do function to execute
// operators. The do function may push or pop values from the stack as needed
// to implement op.
//
// Interpret handles the operators "dict", "currentdict", "begin", "end", "def", and "pop" itself.
//
// Interpret is not a full-blown PostScript interpreter. Its job is to handle the
// very limited PostScript found in certain supporting file formats embedded
// in PDF files, such as cmap files that describe the mapping from font code
// points to Unicode code points.
//
// A stream can also be represented by an array of streams that has to be handled as a single stream
// In the case of a simple stream read only once, otherwise get the length of the stream to handle it properly
//
// There is no support for executable blocks, among other limitations.
func Interpret(strm Value, do func(stk *Stack, op string)) <span class="cov0" title="0">{
        var stk Stack
        var dicts []dict
        s := strm
        strmlen := 1
        if strm.Kind() == Array </span><span class="cov0" title="0">{
                strmlen = strm.Len()
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; strmlen; i++ </span><span class="cov0" title="0">{
                if strm.Kind() == Array </span><span class="cov0" title="0">{
                        s = strm.Index(i)
                }</span>

                <span class="cov0" title="0">rd := s.Reader()

                b := newBuffer(rd, 0)
                b.allowEOF = true
                b.allowObjptr = false
                b.allowStream = false

        Reading:
                for </span><span class="cov0" title="0">{
                        tok := b.readToken()
                        if tok == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if kw, ok := tok.(keyword); ok </span><span class="cov0" title="0">{
                                switch kw </span>{
                                default:<span class="cov0" title="0">
                                        for i := len(dicts) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                                if v, ok := dicts[i][name(kw)]; ok </span><span class="cov0" title="0">{
                                                        stk.Push(Value{nil, objptr{}, v})
                                                        continue Reading</span>
                                                }
                                        }
                                        <span class="cov0" title="0">do(&amp;stk, string(kw))
                                        continue</span>
                                case "null", "[", "]", "&lt;&lt;", "&gt;&gt;":<span class="cov0" title="0">
                                        break</span>
                                case "dict":<span class="cov0" title="0">
                                        stk.Pop()
                                        stk.Push(Value{nil, objptr{}, make(dict)})
                                        continue</span>
                                case "currentdict":<span class="cov0" title="0">
                                        if len(dicts) == 0 </span><span class="cov0" title="0">{
                                                panic("no current dictionary")</span>
                                        }
                                        <span class="cov0" title="0">stk.Push(Value{nil, objptr{}, dicts[len(dicts)-1]})
                                        continue</span>
                                case "begin":<span class="cov0" title="0">
                                        d := stk.Pop()
                                        if d.Kind() != Dict </span><span class="cov0" title="0">{
                                                panic("cannot begin non-dict")</span>
                                        }
                                        <span class="cov0" title="0">dicts = append(dicts, d.data.(dict))
                                        continue</span>
                                case "end":<span class="cov0" title="0">
                                        if len(dicts) &lt;= 0 </span><span class="cov0" title="0">{
                                                panic("mismatched begin/end")</span>
                                        }
                                        <span class="cov0" title="0">dicts = dicts[:len(dicts)-1]
                                        continue</span>
                                case "def":<span class="cov0" title="0">
                                        if len(dicts) &lt;= 0 </span><span class="cov0" title="0">{
                                                panic("def without open dict")</span>
                                        }
                                        <span class="cov0" title="0">val := stk.Pop()
                                        key, ok := stk.Pop().data.(name)
                                        if !ok </span><span class="cov0" title="0">{
                                                // panic(fmt.Sprintf("def of non-name: %+v", stk.Pop().data))
                                                // Skip the value if it has key without value
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">dicts[len(dicts)-1][key] = val.data
                                        continue</span>
                                case "pop":<span class="cov0" title="0">
                                        stk.Pop()
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">b.unreadToken(tok)
                        obj := b.readObject()
                        stk.Push(Value{nil, objptr{}, obj})</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package pdf implements reading of PDF files.
//
// # Overview
//
// PDF is Adobe's Portable Document Format, ubiquitous on the internet.
// A PDF document is a complex data format built on a fairly simple structure.
// This package exposes the simple structure along with some wrappers to
// extract basic information. If more complex information is needed, it is
// possible to extract that information by interpreting the structure exposed
// by this package.
//
// Specifically, a PDF is a data structure built from Values, each of which has
// one of the following Kinds:
//
//        Null, for the null object.
//        Integer, for an integer.
//        Real, for a floating-point number.
//        Bool, for a boolean value.
//        Name, for a name constant (as in /Helvetica).
//        String, for a string constant.
//        Dict, for a dictionary of name-value pairs.
//        Array, for an array of values.
//        Stream, for an opaque data stream and associated header dictionary.
//
// The accessors on ValueInt64, Float64, Bool, Name, and so onreturn
// a view of the data as the given type. When there is no appropriate view,
// the accessor returns a zero result. For example, the Name accessor returns
// the empty string if called on a Value v for which v.Kind() != Name.
// Returning zero values this way, especially from the Dict and Array accessors,
// which themselves return Values, makes it possible to traverse a PDF quickly
// without writing any error checking. On the other hand, it means that mistakes
// can go unreported.
//
// The basic structure of the PDF file is exposed as the graph of Values.
//
// Most richer data structures in a PDF file are dictionaries with specific interpretations
// of the name-value pairs. The Font and Page wrappers make the interpretation
// of a specific Value as the corresponding type easier. They are only helpers, though:
// they are implemented only in terms of the Value API and could be moved outside
// the package. Equally important, traversal of other PDF data structures can be implemented
// in other packages as needed.
package pdf

// BUG(rsc): The package is incomplete, although it has been used successfully on some
// large real-world PDF files.

// BUG(rsc): The library makes no attempt at efficiency beyond the value cache and font cache.
// Further optimizations could improve performance for large files.

// BUG(rsc): The support for reading encrypted files is limited to basic RC4 and AES encryption.

import (
        "bufio"
        "bytes"
        "compress/lzw"
        "compress/zlib"
        "container/list"
        "context"
        "crypto/aes"
        "crypto/cipher"
        "crypto/md5"
        "crypto/rc4"
        "encoding/ascii85"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "runtime"
        "sort"
        "strconv"
        "strings"
        "sync"
)

// toLatin1 converts a UTF-8 string to Latin-1 (ISO-8859-1) encoding.
// Characters that cannot be represented in Latin-1 are replaced with '?'.
func toLatin1(s string) []byte <span class="cov0" title="0">{
        b := make([]byte, 0, len(s))
        for _, r := range s </span><span class="cov0" title="0">{
                if r &lt; 256 </span><span class="cov0" title="0">{
                        b = append(b, byte(r))
                }</span> else<span class="cov0" title="0"> {
                        b = append(b, '?')
                }</span>
        }
        <span class="cov0" title="0">return b</span>
}

// DebugOn is responsible for logging messages into stdout. If problems arise during reading, set it true.
var DebugOn = false

// FontCache stores parsed fonts to avoid re-parsing across pages
type FontCache struct {
        mu    sync.RWMutex
        fonts map[string]*Font
}

// NewFontCache creates a new font cache
func NewFontCache() *FontCache <span class="cov8" title="1">{
        return &amp;FontCache{
                fonts: make(map[string]*Font),
        }
}</span>

// Get retrieves a font from the cache
func (fc *FontCache) Get(key string) (*Font, bool) <span class="cov8" title="1">{
        fc.mu.RLock()
        defer fc.mu.RUnlock()
        font, ok := fc.fonts[key]
        return font, ok
}</span>

// Set stores a font in the cache
func (fc *FontCache) Set(key string, font *Font) <span class="cov8" title="1">{
        fc.mu.Lock()
        defer fc.mu.Unlock()
        fc.fonts[key] = font
}</span>

// P2: 
var (
        globalMultiLevelCache = NewMultiLevelCache()
        globalFontCache       = NewFontCache()
)

// A Reader is a single PDF file open for reading.
type Reader struct {
        f          io.ReaderAt
        closer     io.Closer // Optional closer for underlying resource
        end        int64
        xref       []xref
        trailer    dict
        trailerptr objptr
        key        []byte
        useAES     bool
        cacheMu    sync.RWMutex
        objCache   map[objptr]*list.Element
        cacheList  *list.List
        cacheCap   int
        fontCache  *FontCache
}

type xref struct {
        ptr      objptr
        inStream bool
        stream   objptr
        offset   int64
}

func (r *Reader) errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        panic(fmt.Errorf(format, args...))</span>
}

func (r *Reader) getCachedObject(ptr objptr) (object, bool) <span class="cov0" title="0">{
        r.cacheMu.Lock()
        defer r.cacheMu.Unlock()
        elem, ok := r.objCache[ptr]
        if !ok || elem == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">r.cacheList.MoveToFront(elem)
        if entry, ok := elem.Value.(cacheEntry); ok </span><span class="cov0" title="0">{
                return entry.value, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func (r *Reader) storeCachedObject(ptr objptr, obj object) <span class="cov0" title="0">{
        if ptr.id == 0 || obj == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">r.cacheMu.Lock()
        defer r.cacheMu.Unlock()
        if r.cacheList == nil </span><span class="cov0" title="0">{
                r.cacheList = list.New()
        }</span>
        <span class="cov0" title="0">if r.objCache == nil </span><span class="cov0" title="0">{
                r.objCache = make(map[objptr]*list.Element)
        }</span>
        <span class="cov0" title="0">if elem, ok := r.objCache[ptr]; ok </span><span class="cov0" title="0">{
                elem.Value = cacheEntry{key: ptr, value: obj}
                r.cacheList.MoveToFront(elem)
                return
        }</span>
        <span class="cov0" title="0">elem := r.cacheList.PushFront(cacheEntry{key: ptr, value: obj})
        r.objCache[ptr] = elem
        if r.cacheCap &gt; 0 &amp;&amp; r.cacheList.Len() &gt; r.cacheCap </span><span class="cov0" title="0">{
                r.evictOldest()
        }</span>
}

func (r *Reader) evictOldest() <span class="cov0" title="0">{
        back := r.cacheList.Back()
        if back == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">r.cacheList.Remove(back)
        if entry, ok := back.Value.(cacheEntry); ok </span><span class="cov0" title="0">{
                delete(r.objCache, entry.key)
        }</span>
}

func (r *Reader) SetCacheCapacity(n int) <span class="cov0" title="0">{
        r.cacheMu.Lock()
        defer r.cacheMu.Unlock()
        r.cacheCap = n
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for r.cacheList != nil &amp;&amp; r.cacheList.Len() &gt; r.cacheCap </span><span class="cov0" title="0">{
                r.evictOldest()
        }</span>
}

type cacheEntry struct {
        key   objptr
        value object
}

// Close closes the Reader and releases associated resources.
// If the underlying ReaderAt implements io.Closer, it will be closed.
func (r *Reader) Close() error <span class="cov0" title="0">{
        if r.closer != nil </span><span class="cov0" title="0">{
                return r.closer.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Open opens a file for reading.
func Open(file string) (*os.File, *Reader, error) <span class="cov8" title="1">{
        f, err := os.Open(file)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">fi, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                f.Close()
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">reader, err := NewReader(f, fi.Size())
        if err != nil </span><span class="cov0" title="0">{
                f.Close()
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return f, reader, err</span>
}

// NewReader opens a file for reading, using the data in f with the given total size.
func NewReader(f io.ReaderAt, size int64) (*Reader, error) <span class="cov0" title="0">{
        r, err := NewReaderEncrypted(f, size, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // If f implements io.Closer, store it for cleanup
        <span class="cov0" title="0">if closer, ok := f.(io.Closer); ok </span><span class="cov0" title="0">{
                r.closer = closer
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

// NewReaderEncrypted opens a file for reading, using the data in f with the given total size.
// If the PDF is encrypted, NewReaderEncrypted calls pw repeatedly to obtain passwords
// to try. If pw returns the empty string, NewReaderEncrypted stops trying to decrypt
// the file and returns an error.
func NewReaderEncrypted(f io.ReaderAt, size int64, pw func() string) (*Reader, error) <span class="cov0" title="0">{
        buf := make([]byte, 10)
        f.ReadAt(buf, 0)
        if !bytes.HasPrefix(buf, []byte("%PDF-1.")) || buf[7] &lt; '0' || buf[7] &gt; '7' || buf[8] != '\r' &amp;&amp; buf[8] != '\n' </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a PDF file: invalid header")
        }</span>
        <span class="cov0" title="0">end := size
        const endChunk = 100
        buf = make([]byte, endChunk)
        f.ReadAt(buf, end-endChunk)
        for len(buf) &gt; 0 &amp;&amp; buf[len(buf)-1] == '\n' || buf[len(buf)-1] == '\r' </span><span class="cov0" title="0">{
                buf = buf[:len(buf)-1]
        }</span>
        <span class="cov0" title="0">buf = bytes.TrimRight(buf, "\r\n\t ")
        if !bytes.HasSuffix(buf, []byte("%%EOF")) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a PDF file: missing %%%%EOF")
        }</span>
        <span class="cov0" title="0">i := findLastLine(buf, "startxref")
        if i &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("malformed PDF file: missing final startxref")
        }</span>

        <span class="cov0" title="0">r := &amp;Reader{
                f:         f,
                end:       end,
                fontCache: NewFontCache(),
        }
        pos := end - endChunk + int64(i)
        b := newBuffer(io.NewSectionReader(f, pos, end-pos), pos)
        if b.readToken() != keyword("startxref") </span><span class="cov0" title="0">{
                PutPDFBuffer(b)
                return nil, fmt.Errorf("malformed PDF file: missing startxref")
        }</span>
        <span class="cov0" title="0">startxref, ok := b.readToken().(int64)
        PutPDFBuffer(b)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("malformed PDF file: startxref not followed by integer")
        }</span>
        <span class="cov0" title="0">b = newBuffer(io.NewSectionReader(r.f, startxref, r.end-startxref), startxref)
        xref, trailerptr, trailer, err := readXref(r, b)
        if err != nil </span><span class="cov0" title="0">{
                if rebuildErr := r.rebuildXrefTable(); rebuildErr != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                r.xref = xref
                r.trailer = trailer
                r.trailerptr = trailerptr
        }</span>
        <span class="cov0" title="0">if trailer["Encrypt"] == nil </span><span class="cov0" title="0">{
                return r, nil
        }</span>
        <span class="cov0" title="0">err = r.initEncrypt("")
        if err == nil </span><span class="cov0" title="0">{
                return r, nil
        }</span>
        <span class="cov0" title="0">if pw == nil || err != ErrInvalidPassword </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                next := pw()
                if next == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if r.initEncrypt(next) == nil </span><span class="cov0" title="0">{
                        return r, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, err</span>
}

// NewReaderEncryptedWithMmap opens a file for reading with memory mapping for large files.
// If the file size exceeds 10MB, it uses memory mapping to reduce memory usage.
// This is a wrapper around NewReaderEncrypted that optimizes for large files.
func NewReaderEncryptedWithMmap(f io.ReaderAt, size int64, pw func() string) (*Reader, error) <span class="cov0" title="0">{
        const largeFileThreshold = 10 * 1024 * 1024 // 10MB
        if size &gt; largeFileThreshold </span>{<span class="cov0" title="0">
                // For large files, we could implement memory mapping here
                // For now, fall back to regular reader but log the opportunity
                // TODO: Implement actual memory mapping using syscall.Mmap or similar
        }</span>
        <span class="cov0" title="0">return NewReaderEncrypted(f, size, pw)</span>
}

// Trailer returns the file's Trailer value.
func (r *Reader) Trailer() Value <span class="cov8" title="1">{
        return Value{r, r.trailerptr, r.trailer}
}</span>

func readXref(r *Reader, b *buffer) ([]xref, objptr, dict, error) <span class="cov0" title="0">{
        defer PutPDFBuffer(b)
        tok := b.readToken()
        if tok == keyword("xref") </span><span class="cov0" title="0">{
                return readXrefTable(r, b)
        }</span>
        <span class="cov0" title="0">if _, ok := tok.(int64); ok </span><span class="cov0" title="0">{
                b.unreadToken(tok)
                return readXrefStream(r, b)
        }</span>
        <span class="cov0" title="0">return nil, objptr{}, nil, fmt.Errorf("malformed PDF: cross-reference table not found: %v", tok)</span>
}

func readXrefStream(r *Reader, b *buffer) ([]xref, objptr, dict, error) <span class="cov0" title="0">{
        obj1 := b.readObject()
        obj, ok := obj1.(objdef)
        if !ok </span><span class="cov0" title="0">{
                return nil, objptr{}, nil, fmt.Errorf("malformed PDF: cross-reference table not found: %v", objfmt(obj1))
        }</span>
        <span class="cov0" title="0">strmptr := obj.ptr
        strm, ok := obj.obj.(stream)
        if !ok </span><span class="cov0" title="0">{
                return nil, objptr{}, nil, fmt.Errorf("malformed PDF: cross-reference table not found: %v", objfmt(obj))
        }</span>
        <span class="cov0" title="0">if strm.hdr["Type"] != name("XRef") </span><span class="cov0" title="0">{
                return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref stream does not have type XRef")
        }</span>
        <span class="cov0" title="0">size, ok := strm.hdr["Size"].(int64)
        if !ok </span><span class="cov0" title="0">{
                return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref stream missing Size")
        }</span>
        <span class="cov0" title="0">table := make([]xref, size)

        table, err := readXrefStreamData(r, strm, table, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, objptr{}, nil, fmt.Errorf("malformed PDF: %v", err)
        }</span>

        <span class="cov0" title="0">for prevoff := strm.hdr["Prev"]; prevoff != nil; </span><span class="cov0" title="0">{
                off, ok := prevoff.(int64)
                if !ok </span><span class="cov0" title="0">{
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref Prev is not integer: %v", prevoff)
                }</span>
                <span class="cov0" title="0">b := newBuffer(io.NewSectionReader(r.f, off, r.end-off), off)
                obj1 := b.readObject()
                obj, ok := obj1.(objdef)
                PutPDFBuffer(b)
                if !ok </span><span class="cov0" title="0">{
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref prev stream not found: %v", objfmt(obj1))
                }</span>
                <span class="cov0" title="0">prevstrm, ok := obj.obj.(stream)
                if !ok </span><span class="cov0" title="0">{
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref prev stream not found: %v", objfmt(obj))
                }</span>
                <span class="cov0" title="0">prevoff = prevstrm.hdr["Prev"]
                prev := Value{r, objptr{}, prevstrm}
                if prev.Kind() != Stream </span><span class="cov0" title="0">{
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref prev stream is not stream: %v", prev)
                }</span>
                <span class="cov0" title="0">if prev.Key("Type").Name() != "XRef" </span><span class="cov0" title="0">{
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref prev stream does not have type XRef")
                }</span>
                <span class="cov0" title="0">psize := prev.Key("Size").Int64()
                if psize &gt; size </span><span class="cov0" title="0">{
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref prev stream larger than last stream")
                }</span>
                <span class="cov0" title="0">if table, err = readXrefStreamData(r, prev.data.(stream), table, psize); err != nil </span><span class="cov0" title="0">{
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: reading xref prev stream: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return table, strmptr, strm.hdr, nil</span>
}

func readXrefStreamData(r *Reader, strm stream, table []xref, size int64) ([]xref, error) <span class="cov0" title="0">{
        index, _ := strm.hdr["Index"].(array)
        if index == nil </span><span class="cov0" title="0">{
                index = array{int64(0), size}
        }</span>
        <span class="cov0" title="0">if len(index)%2 != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid Index array %v", objfmt(index))
        }</span>
        <span class="cov0" title="0">ww, ok := strm.hdr["W"].(array)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("xref stream missing W array")
        }</span>

        <span class="cov0" title="0">var w []int
        for _, x := range ww </span><span class="cov0" title="0">{
                i, ok := x.(int64)
                if !ok || int64(int(i)) != i </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid W array %v", objfmt(ww))
                }</span>
                <span class="cov0" title="0">w = append(w, int(i))</span>
        }
        <span class="cov0" title="0">if len(w) &lt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid W array %v", objfmt(ww))
        }</span>

        <span class="cov0" title="0">v := Value{r, objptr{}, strm}
        wtotal := 0
        for _, wid := range w </span><span class="cov0" title="0">{
                wtotal += wid
        }</span>
        <span class="cov0" title="0">buf := make([]byte, wtotal)
        data := v.Reader()
        for len(index) &gt; 0 </span><span class="cov0" title="0">{
                start, ok1 := index[0].(int64)
                n, ok2 := index[1].(int64)
                if !ok1 || !ok2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("malformed Index pair %v %v %T %T", objfmt(index[0]), objfmt(index[1]), index[0], index[1])
                }</span>
                <span class="cov0" title="0">index = index[2:]
                for i := 0; i &lt; int(n); i++ </span><span class="cov0" title="0">{
                        _, err := io.ReadFull(data, buf)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error reading xref stream: %v", err)
                        }</span>
                        <span class="cov0" title="0">v1 := decodeInt(buf[0:w[0]])
                        if w[0] == 0 </span><span class="cov0" title="0">{
                                v1 = 1
                        }</span>
                        <span class="cov0" title="0">v2 := decodeInt(buf[w[0] : w[0]+w[1]])
                        v3 := decodeInt(buf[w[0]+w[1] : w[0]+w[1]+w[2]])
                        x := int(start) + i
                        for cap(table) &lt;= x </span><span class="cov0" title="0">{
                                table = append(table[:cap(table)], xref{})
                        }</span>
                        <span class="cov0" title="0">if table[x].ptr != (objptr{}) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">switch v1 </span>{
                        case 0:<span class="cov0" title="0">
                                table[x] = xref{ptr: objptr{0, 65535}}</span>
                        case 1:<span class="cov0" title="0">
                                table[x] = xref{ptr: objptr{uint32(x), uint16(v3)}, offset: int64(v2)}</span>
                        case 2:<span class="cov0" title="0">
                                table[x] = xref{ptr: objptr{uint32(x), 0}, inStream: true, stream: objptr{uint32(v2), 0}, offset: int64(v3)}</span>
                        default:<span class="cov0" title="0">
                                if DebugOn </span><span class="cov0" title="0">{
                                        fmt.Printf("invalid xref stream type %d: %x\n", v1, buf)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return table, nil</span>
}

func decodeInt(b []byte) int <span class="cov0" title="0">{
        x := 0
        for _, c := range b </span><span class="cov0" title="0">{
                x = x&lt;&lt;8 | int(c)
        }</span>
        <span class="cov0" title="0">return x</span>
}

func readXrefTable(r *Reader, b *buffer) ([]xref, objptr, dict, error) <span class="cov0" title="0">{
        var table []xref

        table, err := readXrefTableData(b, table)
        if err != nil </span><span class="cov0" title="0">{
                return nil, objptr{}, nil, fmt.Errorf("malformed PDF: %v", err)
        }</span>

        <span class="cov0" title="0">trailer, ok := b.readObject().(dict)
        if !ok </span><span class="cov0" title="0">{
                return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref table not followed by trailer dictionary")
        }</span>

        <span class="cov0" title="0">for prevoff := trailer["Prev"]; prevoff != nil; </span><span class="cov0" title="0">{
                off, ok := prevoff.(int64)
                if !ok </span><span class="cov0" title="0">{
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref Prev is not integer: %v", prevoff)
                }</span>
                <span class="cov0" title="0">b := newBuffer(io.NewSectionReader(r.f, off, r.end-off), off)
                tok := b.readToken()
                if tok != keyword("xref") </span><span class="cov0" title="0">{
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref Prev does not point to xref")
                }</span>
                <span class="cov0" title="0">table, err = readXrefTableData(b, table)
                if err != nil </span><span class="cov0" title="0">{
                        PutPDFBuffer(b)
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: %v", err)
                }</span>

                <span class="cov0" title="0">trailer, ok := b.readObject().(dict)
                PutPDFBuffer(b)
                if !ok </span><span class="cov0" title="0">{
                        return nil, objptr{}, nil, fmt.Errorf("malformed PDF: xref Prev table not followed by trailer dictionary")
                }</span>
                <span class="cov0" title="0">prevoff = trailer["Prev"]</span>
        }

        <span class="cov0" title="0">size, ok := trailer[name("Size")].(int64)
        if !ok </span><span class="cov0" title="0">{
                return nil, objptr{}, nil, fmt.Errorf("malformed PDF: trailer missing /Size entry")
        }</span>

        <span class="cov0" title="0">if size &lt; int64(len(table)) </span><span class="cov0" title="0">{
                table = table[:size]
        }</span>

        <span class="cov0" title="0">return table, objptr{}, trailer, nil</span>
}

func (r *Reader) rebuildXrefTable() error <span class="cov0" title="0">{
        if r.end &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("cannot rebuild xref: empty file")
        }</span>
        <span class="cov0" title="0">if r.end &gt; 200&lt;&lt;20 </span><span class="cov0" title="0">{
                return errors.New("pdf: file too large to rebuild xref")
        }</span>
        <span class="cov0" title="0">data := make([]byte, int(r.end))
        sr := io.NewSectionReader(r.f, 0, r.end)
        if _, err := io.ReadFull(sr, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">entries := make(map[uint32]xref)
        search := 0
        for </span><span class="cov0" title="0">{
                idx := bytes.Index(data[search:], []byte(" obj"))
                if idx &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">pos := search + idx
                lineStart := pos
                for lineStart &gt; 0 &amp;&amp; data[lineStart-1] != '\n' &amp;&amp; data[lineStart-1] != '\r' </span><span class="cov0" title="0">{
                        lineStart--
                }</span>
                <span class="cov0" title="0">line := strings.Fields(string(data[lineStart:pos]))
                if len(line) &gt;= 2 </span><span class="cov0" title="0">{
                        if id64, err1 := strconv.ParseUint(line[0], 10, 32); err1 == nil </span><span class="cov0" title="0">{
                                if gen64, err2 := strconv.ParseUint(line[1], 10, 16); err2 == nil </span><span class="cov0" title="0">{
                                        ptr := objptr{uint32(id64), uint16(gen64)}
                                        if _, ok := entries[ptr.id]; !ok </span><span class="cov0" title="0">{
                                                entries[ptr.id] = xref{ptr: ptr, offset: int64(lineStart)}
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">search = pos + len(" obj")</span>
        }
        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                return errors.New("pdf: unable to rebuild xref")
        }</span>
        <span class="cov0" title="0">var maxID uint32
        for id := range entries </span><span class="cov0" title="0">{
                if id &gt; maxID </span><span class="cov0" title="0">{
                        maxID = id
                }</span>
        }
        <span class="cov0" title="0">table := make([]xref, maxID+1)
        for id, entry := range entries </span><span class="cov0" title="0">{
                table[id] = entry
        }</span>
        <span class="cov0" title="0">r.xref = table
        if err := r.recoverTrailer(data); err != nil </span><span class="cov0" title="0">{
                r.trailer = make(dict)
                r.trailerptr = objptr{}
                return nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *Reader) recoverTrailer(data []byte) error <span class="cov0" title="0">{
        idx := bytes.LastIndex(data, []byte("trailer"))
        if idx &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("trailer not found")
        }</span>
        <span class="cov0" title="0">buf := newBuffer(bytes.NewReader(data[idx:]), int64(idx))
        defer PutPDFBuffer(buf)
        buf.allowEOF = true
        if tok := buf.readToken(); tok != keyword("trailer") </span><span class="cov0" title="0">{
                return errors.New("malformed recovered trailer")
        }</span>
        <span class="cov0" title="0">obj := buf.readObject()
        d, ok := obj.(dict)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("recovered trailer is not dict")
        }</span>
        <span class="cov0" title="0">r.trailer = d
        r.trailerptr = objptr{}
        return nil</span>
}

func readXrefTableData(b *buffer, table []xref) ([]xref, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                tok := b.readToken()
                if tok == keyword("trailer") </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">start, ok1 := tok.(int64)
                n, ok2 := b.readToken().(int64)
                if !ok1 || !ok2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("malformed xref table")
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; int(n); i++ </span><span class="cov0" title="0">{
                        off, ok1 := b.readToken().(int64)
                        gen, ok2 := b.readToken().(int64)
                        alloc, ok3 := b.readToken().(keyword)
                        if !ok1 || !ok2 || !ok3 || alloc != keyword("f") &amp;&amp; alloc != keyword("n") </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("malformed xref table")
                        }</span>
                        <span class="cov0" title="0">x := int(start) + i
                        for cap(table) &lt;= x </span><span class="cov0" title="0">{
                                table = append(table[:cap(table)], xref{})
                        }</span>
                        <span class="cov0" title="0">if len(table) &lt;= x </span><span class="cov0" title="0">{
                                table = table[:x+1]
                        }</span>
                        <span class="cov0" title="0">if alloc == "n" &amp;&amp; table[x].offset == 0 </span><span class="cov0" title="0">{
                                table[x] = xref{ptr: objptr{uint32(x), uint16(gen)}, offset: int64(off)}
                        }</span>
                }
        }
        <span class="cov0" title="0">return table, nil</span>
}

func findLastLine(buf []byte, s string) int <span class="cov0" title="0">{
        bs := []byte(s)
        max := len(buf)
        for </span><span class="cov0" title="0">{
                i := bytes.LastIndex(buf[:max], bs)
                if i &lt;= 0 || i+len(bs) &gt;= len(buf) </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">if (buf[i-1] == '\n' || buf[i-1] == '\r') &amp;&amp; (buf[i+len(bs)] == '\n' || buf[i+len(bs)] == '\r') </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov0" title="0">max = i</span>
        }
}

// A Value is a single PDF value, such as an integer, dictionary, or array.
// The zero Value is a PDF null (Kind() == Null, IsNull() = true).
type Value struct {
        r    *Reader
        ptr  objptr
        data interface{}
}

// IsNull reports whether the value is a null. It is equivalent to Kind() == Null.
func (v Value) IsNull() bool <span class="cov8" title="1">{
        return v.data == nil
}</span>

// A ValueKind specifies the kind of data underlying a Value.
type ValueKind int

// The PDF value kinds.
const (
        Null ValueKind = iota
        Bool
        Integer
        Real
        String
        Name
        Dict
        Array
        Stream
)

// Kind reports the kind of value underlying v.
func (v Value) Kind() ValueKind <span class="cov8" title="1">{
        switch v.data.(type) </span>{
        default:<span class="cov8" title="1">
                return Null</span>
        case bool:<span class="cov0" title="0">
                return Bool</span>
        case int64:<span class="cov0" title="0">
                return Integer</span>
        case float64:<span class="cov0" title="0">
                return Real</span>
        case string:<span class="cov8" title="1">
                return String</span>
        case name:<span class="cov0" title="0">
                return Name</span>
        case dict:<span class="cov0" title="0">
                return Dict</span>
        case array:<span class="cov0" title="0">
                return Array</span>
        case stream:<span class="cov0" title="0">
                return Stream</span>
        }
}

// String returns a textual representation of the value v.
// Note that String is not the accessor for values with Kind() == String.
// To access such values, see RawString, Text, and TextFromUTF16.
func (v Value) String() string <span class="cov8" title="1">{
        return objfmt(v.data)
}</span>

func objfmt(x interface{}) string <span class="cov8" title="1">{
        switch x := x.(type) </span>{
        default:<span class="cov8" title="1">
                return fmt.Sprint(x)</span>
        case string:<span class="cov0" title="0">
                if isPDFDocEncoded(x) </span><span class="cov0" title="0">{
                        return strconv.Quote(pdfDocDecode(x))
                }</span>
                <span class="cov0" title="0">if isUTF16(x) </span><span class="cov0" title="0">{
                        return strconv.Quote(utf16Decode(x[2:]))
                }</span>
                <span class="cov0" title="0">return strconv.Quote(x)</span>
        case name:<span class="cov0" title="0">
                return "/" + string(x)</span>
        case dict:<span class="cov0" title="0">
                var keys []string
                for k := range x </span><span class="cov0" title="0">{
                        keys = append(keys, string(k))
                }</span>
                <span class="cov0" title="0">sort.Strings(keys)
                var buf bytes.Buffer
                buf.WriteString("&lt;&lt;")
                for i, k := range keys </span><span class="cov0" title="0">{
                        elem := x[name(k)]
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                buf.WriteString(" ")
                        }</span>
                        <span class="cov0" title="0">buf.WriteString("/")
                        buf.WriteString(k)
                        buf.WriteString(" ")
                        buf.WriteString(objfmt(elem))</span>
                }
                <span class="cov0" title="0">buf.WriteString("&gt;&gt;")
                return buf.String()</span>

        case array:<span class="cov0" title="0">
                var buf bytes.Buffer
                buf.WriteString("[")
                for i, elem := range x </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                buf.WriteString(" ")
                        }</span>
                        <span class="cov0" title="0">buf.WriteString(objfmt(elem))</span>
                }
                <span class="cov0" title="0">buf.WriteString("]")
                return buf.String()</span>

        case stream:<span class="cov0" title="0">
                return fmt.Sprintf("%v@%d", objfmt(x.hdr), x.offset)</span>

        case objptr:<span class="cov0" title="0">
                return fmt.Sprintf("%d %d R", x.id, x.gen)</span>

        case objdef:<span class="cov0" title="0">
                return fmt.Sprintf("{%d %d obj}%v", x.ptr.id, x.ptr.gen, objfmt(x.obj))</span>
        }
}

// Bool returns v's boolean value.
// If v.Kind() != Bool, Bool returns false.
func (v Value) Bool() bool <span class="cov0" title="0">{
        x, ok := v.data.(bool)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x</span>
}

// Int64 returns v's int64 value.
// If v.Kind() != Int64, Int64 returns 0.
func (v Value) Int64() int64 <span class="cov8" title="1">{
        x, ok := v.data.(int64)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov0" title="0">return x</span>
}

// Float64 returns v's float64 value, converting from integer if necessary.
// If v.Kind() != Float64 and v.Kind() != Int64, Float64 returns 0.
func (v Value) Float64() float64 <span class="cov0" title="0">{
        x, ok := v.data.(float64)
        if !ok </span><span class="cov0" title="0">{
                x, ok := v.data.(int64)
                if ok </span><span class="cov0" title="0">{
                        return float64(x)
                }</span>
                <span class="cov0" title="0">return 0</span>
        }
        <span class="cov0" title="0">return x</span>
}

// RawString returns v's string value.
// If v.Kind() != String, RawString returns the empty string.
func (v Value) RawString() string <span class="cov8" title="1">{
        x, ok := v.data.(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return x</span>
}

// Text returns v's string value interpreted as a text string (defined in the PDF spec)
// and converted to UTF-8.
// If v.Kind() != String, Text returns the empty string.
func (v Value) Text() string <span class="cov0" title="0">{
        x, ok := v.data.(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if isPDFDocEncoded(x) </span><span class="cov0" title="0">{
                return pdfDocDecode(x)
        }</span>
        <span class="cov0" title="0">if isUTF16(x) </span><span class="cov0" title="0">{
                return utf16Decode(x[2:])
        }</span>
        <span class="cov0" title="0">return x</span>
}

// TextFromUTF16 returns v's string value interpreted as big-endian UTF-16
// and then converted to UTF-8.
// If v.Kind() != String or if the data is not valid UTF-16, TextFromUTF16 returns
// the empty string.
func (v Value) TextFromUTF16() string <span class="cov0" title="0">{
        x, ok := v.data.(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if len(x)%2 == 1 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if x == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return utf16Decode(x)</span>
}

// Name returns v's name value.
// If v.Kind() != Name, Name returns the empty string.
// The returned name does not include the leading slash:
// if v corresponds to the name written using the syntax /Helvetica,
// Name() == "Helvetica".
func (v Value) Name() string <span class="cov8" title="1">{
        x, ok := v.data.(name)
        if !ok </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">return string(x)</span>
}

// Key returns the value associated with the given name key in the dictionary v.
// Like the result of the Name method, the key should not include a leading slash.
// If v is a stream, Key applies to the stream's header dictionary.
// If v.Kind() != Dict and v.Kind() != Stream, Key returns a null Value.
func (v Value) Key(key string) Value <span class="cov8" title="1">{
        x, ok := v.data.(dict)
        if !ok </span><span class="cov8" title="1">{
                strm, ok := v.data.(stream)
                if !ok </span><span class="cov8" title="1">{
                        return Value{}
                }</span>
                <span class="cov0" title="0">x = strm.hdr</span>
        }
        <span class="cov8" title="1">return v.r.resolve(v.ptr, x[name(key)])</span>
}

// Keys returns a sorted list of the keys in the dictionary v.
// If v is a stream, Keys applies to the stream's header dictionary.
// If v.Kind() != Dict and v.Kind() != Stream, Keys returns nil.
func (v Value) Keys() []string <span class="cov0" title="0">{
        x, ok := v.data.(dict)
        if !ok </span><span class="cov0" title="0">{
                strm, ok := v.data.(stream)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">x = strm.hdr</span>
        }
        <span class="cov0" title="0">keys := []string{} // not nil
        for k := range x </span><span class="cov0" title="0">{
                keys = append(keys, string(k))
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        return keys</span>
}

// Index returns the i'th element in the array v.
// If v.Kind() != Array or if i is outside the array bounds,
// Index returns a null Value.
func (v Value) Index(i int) Value <span class="cov0" title="0">{
        x, ok := v.data.(array)
        if !ok || i &lt; 0 || i &gt;= len(x) </span><span class="cov0" title="0">{
                return Value{}
        }</span>
        <span class="cov0" title="0">return v.r.resolve(v.ptr, x[i])</span>
}

// Len returns the length of the array v.
// If v.Kind() != Array, Len returns 0.
func (v Value) Len() int <span class="cov8" title="1">{
        x, ok := v.data.(array)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov0" title="0">return len(x)</span>
}

func (r *Reader) resolve(parent objptr, x interface{}) Value <span class="cov8" title="1">{
        if ptr, ok := x.(objptr); ok </span><span class="cov0" title="0">{
                if obj, ok := r.getCachedObject(ptr); ok </span><span class="cov0" title="0">{
                        return Value{r, parent, obj}
                }</span>
                <span class="cov0" title="0">if ptr.id &gt;= uint32(len(r.xref)) </span><span class="cov0" title="0">{
                        return Value{}
                }</span>
                <span class="cov0" title="0">xref := r.xref[ptr.id]
                if xref.ptr != ptr || !xref.inStream &amp;&amp; xref.offset == 0 </span><span class="cov0" title="0">{
                        return Value{}
                }</span>
                <span class="cov0" title="0">var obj object
                if xref.inStream </span><span class="cov0" title="0">{
                        strm := r.resolve(parent, xref.stream)
                Search:
                        for </span><span class="cov0" title="0">{
                                if strm.Kind() != Stream </span><span class="cov0" title="0">{
                                        panic("not a stream")</span>
                                }
                                <span class="cov0" title="0">if strm.Key("Type").Name() != "ObjStm" </span><span class="cov0" title="0">{
                                        panic("not an object stream")</span>
                                }
                                <span class="cov0" title="0">n := int(strm.Key("N").Int64())
                                first := strm.Key("First").Int64()
                                if first == 0 </span><span class="cov0" title="0">{
                                        panic("missing First")</span>
                                }
                                <span class="cov0" title="0">b := newBuffer(strm.Reader(), 0)
                                b.allowEOF = true
                                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                        id, _ := b.readToken().(int64)
                                        off, _ := b.readToken().(int64)
                                        if uint32(id) == ptr.id </span><span class="cov0" title="0">{
                                                b.seekForward(first + off)
                                                x = b.readObject()
                                                r.storeCachedObject(ptr, x)
                                                PutPDFBuffer(b)
                                                break Search</span>
                                        }
                                }
                                <span class="cov0" title="0">ext := strm.Key("Extends")
                                if ext.Kind() != Stream </span><span class="cov0" title="0">{
                                        panic("cannot find object in stream")</span>
                                }
                                <span class="cov0" title="0">strm = ext</span>
                        }
                } else<span class="cov0" title="0"> {
                        b := newBuffer(io.NewSectionReader(r.f, xref.offset, r.end-xref.offset), xref.offset)
                        b.key = r.key
                        b.useAES = r.useAES
                        obj = b.readObject()
                        def, ok := obj.(objdef)
                        if !ok </span><span class="cov0" title="0">{
                                panic(fmt.Errorf("loading %v: found %T instead of objdef", ptr, obj))</span>
                                //return Value{}
                        }
                        <span class="cov0" title="0">if def.ptr != ptr </span><span class="cov0" title="0">{
                                panic(fmt.Errorf("loading %v: found %v", ptr, def.ptr))</span>
                        }
                        <span class="cov0" title="0">x = def.obj
                        r.storeCachedObject(ptr, x)
                        PutPDFBuffer(b)</span>
                }
                <span class="cov0" title="0">parent = ptr</span>
        }

        <span class="cov8" title="1">switch x := x.(type) </span>{
        case nil, bool, int64, float64, name, dict, array, stream:<span class="cov8" title="1">
                return Value{r, parent, x}</span>
        case string:<span class="cov0" title="0">
                return Value{r, parent, x}</span>
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("unexpected value type %T in resolve", x))</span>
        }
}

type errorReadCloser struct {
        err error
}

func (e *errorReadCloser) Read([]byte) (int, error) <span class="cov8" title="1">{
        return 0, e.err
}</span>

func (e *errorReadCloser) Close() error <span class="cov8" title="1">{
        return e.err
}</span>

// Reader returns the data contained in the stream v.
// If v.Kind() != Stream, Reader returns a ReadCloser that
// responds to all reads with a stream not present error.
func (v Value) Reader() io.ReadCloser <span class="cov8" title="1">{
        x, ok := v.data.(stream)
        if !ok </span><span class="cov8" title="1">{
                return &amp;errorReadCloser{fmt.Errorf("stream not present")}
        }</span>
        <span class="cov0" title="0">var rd io.Reader
        rd = io.NewSectionReader(v.r.f, x.offset, v.Key("Length").Int64())
        if v.r.key != nil </span><span class="cov0" title="0">{
                rd = decryptStream(v.r.key, v.r.useAES, x.ptr, rd)
        }</span>
        <span class="cov0" title="0">filter := v.Key("Filter")
        param := v.Key("DecodeParms")
        switch filter.Kind() </span>{
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("unsupported filter %v", filter))</span>
        case Null:<span class="cov0" title="0"></span>
                // ok
        case Name:<span class="cov0" title="0">
                rd = applyFilter(rd, filter.Name(), param)</span>
        case Array:<span class="cov0" title="0">
                for i := 0; i &lt; filter.Len(); i++ </span><span class="cov0" title="0">{
                        rd = applyFilter(rd, filter.Index(i).Name(), param.Index(i))
                }</span>
        }

        <span class="cov0" title="0">return ioutil.NopCloser(rd)</span>
}

func applyFilter(rd io.Reader, name string, param Value) io.Reader <span class="cov8" title="1">{
        switch name </span>{
        default:<span class="cov0" title="0">
                panic("unknown filter " + name)</span>
        case "FlateDecode":<span class="cov0" title="0">
                zr, err := zlib.NewReader(rd)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">return applyPredictor(zr, param)</span>
        case "LZWDecode":<span class="cov8" title="1">
                early := param.Key("EarlyChange")
                if early.Kind() != Null &amp;&amp; early.Int64() != 1 </span><span class="cov0" title="0">{
                        panic("LZW EarlyChange != 1 not supported")</span>
                }
                <span class="cov8" title="1">lr := lzw.NewReader(rd, lzw.MSB, 8)
                return applyPredictor(lr, param)</span>
        case "ASCII85Decode":<span class="cov0" title="0">
                cleanASCII85 := newAlphaReader(rd)
                decoder := ascii85.NewDecoder(cleanASCII85)

                switch param.Keys() </span>{
                default:<span class="cov0" title="0">
                        if DebugOn </span><span class="cov0" title="0">{
                                fmt.Println("param=", param)
                        }</span>
                        <span class="cov0" title="0">panic("not expected DecodeParms for ascii85")</span>
                case nil:<span class="cov0" title="0">
                        return decoder</span>
                }
        case "DCTDecode":<span class="cov8" title="1">
                // JPEG-compressed data is already suitable for consumers; leave as-is.
                return rd</span>
        case "JPXDecode":<span class="cov8" title="1">
                // JPEG2000-compressed data; passthrough for now.
                return rd</span>
        case "CCITTFaxDecode":<span class="cov8" title="1">
                // CCITT Group 3/4 data is left as-is for callers that understand the encoding.
                return rd</span>
        case "RunLengthDecode":<span class="cov8" title="1">
                return newRunLengthReader(rd)</span>
        }
}

func applyPredictor(rd io.Reader, param Value) io.Reader <span class="cov8" title="1">{
        if param.Kind() != Dict </span><span class="cov8" title="1">{
                return rd
        }</span>
        <span class="cov0" title="0">pred := param.Key("Predictor")
        if pred.Kind() == Null </span><span class="cov0" title="0">{
                return rd
        }</span>
        <span class="cov0" title="0">switch pred.Int64() </span>{
        case 1, 2:<span class="cov0" title="0">
                return rd</span>
        case 12:<span class="cov0" title="0">
                columns := param.Key("Columns").Int64()
                if columns &lt;= 0 </span><span class="cov0" title="0">{
                        columns = 1
                }</span>
                <span class="cov0" title="0">return &amp;pngUpReader{r: rd, hist: make([]byte, 1+columns), tmp: make([]byte, 1+columns)}</span>
        default:<span class="cov0" title="0">
                if DebugOn </span><span class="cov0" title="0">{
                        fmt.Println("unknown predictor", pred)
                }</span>
                <span class="cov0" title="0">panic("pred")</span>
        }
}

type pngUpReader struct {
        r    io.Reader
        hist []byte
        tmp  []byte
        pend []byte
}

func (r *pngUpReader) Read(b []byte) (int, error) <span class="cov0" title="0">{
        n := 0
        for len(b) &gt; 0 </span><span class="cov0" title="0">{
                if len(r.pend) &gt; 0 </span><span class="cov0" title="0">{
                        m := copy(b, r.pend)
                        n += m
                        b = b[m:]
                        r.pend = r.pend[m:]
                        continue</span>
                }
                <span class="cov0" title="0">_, err := io.ReadFull(r.r, r.tmp)
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
                <span class="cov0" title="0">if r.tmp[0] != 2 </span><span class="cov0" title="0">{
                        return n, fmt.Errorf("malformed PNG-Up encoding")
                }</span>
                <span class="cov0" title="0">for i, b := range r.tmp </span><span class="cov0" title="0">{
                        r.hist[i] += b
                }</span>
                <span class="cov0" title="0">r.pend = r.hist[1:]</span>
        }
        <span class="cov0" title="0">return n, nil</span>
}

type runLengthReader struct {
        r   *bufio.Reader
        buf []byte
        eod bool
}

func newRunLengthReader(rd io.Reader) io.Reader <span class="cov8" title="1">{
        return &amp;runLengthReader{r: bufio.NewReader(rd)}
}</span>

func (r *runLengthReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">n := 0
        for len(p) &gt; 0 </span><span class="cov8" title="1">{
                if len(r.buf) == 0 </span><span class="cov8" title="1">{
                        if r.eod </span><span class="cov8" title="1">{
                                if n == 0 </span><span class="cov8" title="1">{
                                        return 0, io.EOF
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                        <span class="cov8" title="1">if err := r.fill(); err != nil </span><span class="cov8" title="1">{
                                if err == io.EOF </span><span class="cov8" title="1">{
                                        if n == 0 </span><span class="cov0" title="0">{
                                                return 0, io.EOF
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                                <span class="cov0" title="0">return n, err</span>
                        }
                }
                <span class="cov8" title="1">m := copy(p, r.buf)
                n += m
                p = p[m:]
                r.buf = r.buf[m:]</span>
        }
        <span class="cov8" title="1">return n, nil</span>
}

func (r *runLengthReader) fill() error <span class="cov8" title="1">{
        b, err := r.r.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if b == 128 </span><span class="cov8" title="1">{
                r.eod = true
                return io.EOF
        }</span>
        <span class="cov8" title="1">if b &lt;= 127 </span><span class="cov8" title="1">{
                count := int(b) + 1
                r.buf = make([]byte, count)
                if _, err := io.ReadFull(r.r, r.buf); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        // 129..255 repeat
        <span class="cov8" title="1">count := 257 - int(b)
        val, err := r.r.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.buf = bytes.Repeat([]byte{val}, count)
        return nil</span>
}

var passwordPad = []byte{
        0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41, 0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08,
        0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80, 0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A,
}

func (r *Reader) initEncrypt(password string) error <span class="cov0" title="0">{
        // See PDF 32000-1:2008, 7.6.
        encrypt, _ := r.resolve(objptr{}, r.trailer["Encrypt"]).data.(dict)
        if encrypt["Filter"] != name("Standard") </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported PDF: encryption filter %v", objfmt(encrypt["Filter"]))
        }</span>
        <span class="cov0" title="0">n, _ := encrypt["Length"].(int64)
        if n == 0 </span><span class="cov0" title="0">{
                n = 40
        }</span>
        <span class="cov0" title="0">if n%8 != 0 || n &gt; 128 || n &lt; 40 </span><span class="cov0" title="0">{
                return fmt.Errorf("malformed PDF: %d-bit encryption key", n)
        }</span>
        <span class="cov0" title="0">V, _ := encrypt["V"].(int64)
        if V != 1 &amp;&amp; V != 2 &amp;&amp; (V != 4 || !okayV4(encrypt)) </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported PDF: encryption version V=%d; %v", V, objfmt(encrypt))
        }</span>

        <span class="cov0" title="0">ids, ok := r.trailer["ID"].(array)
        if !ok || len(ids) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("malformed PDF: missing ID in trailer")
        }</span>
        <span class="cov0" title="0">idstr, ok := ids[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("malformed PDF: missing ID in trailer")
        }</span>
        <span class="cov0" title="0">ID := []byte(idstr)

        R, _ := encrypt["R"].(int64)
        if R &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("malformed PDF: encryption revision R=%d", R)
        }</span>
        <span class="cov0" title="0">if R &gt; 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported PDF: encryption revision R=%d", R)
        }</span>
        <span class="cov0" title="0">O, _ := encrypt["O"].(string)
        U, _ := encrypt["U"].(string)
        if len(O) != 32 || len(U) != 32 </span><span class="cov0" title="0">{
                return fmt.Errorf("malformed PDF: missing O= or U= encryption parameters")
        }</span>
        <span class="cov0" title="0">p, _ := encrypt["P"].(int64)
        P := uint32(p)

        // TODO: Password should be converted to Latin-1.
        pw := toLatin1(password)
        h := md5.New()
        if len(pw) &gt;= 32 </span><span class="cov0" title="0">{
                h.Write(pw[:32])
        }</span> else<span class="cov0" title="0"> {
                h.Write(pw)
                h.Write(passwordPad[:32-len(pw)])
        }</span>
        <span class="cov0" title="0">h.Write([]byte(O))
        h.Write([]byte{byte(P), byte(P &gt;&gt; 8), byte(P &gt;&gt; 16), byte(P &gt;&gt; 24)})
        h.Write([]byte(ID))
        key := h.Sum(nil)

        if R &gt;= 3 </span><span class="cov0" title="0">{
                for i := 0; i &lt; 50; i++ </span><span class="cov0" title="0">{
                        h.Reset()
                        h.Write(key[:n/8])
                        key = h.Sum(key[:0])
                }</span>
                <span class="cov0" title="0">key = key[:n/8]</span>
        } else<span class="cov0" title="0"> {
                key = key[:40/8]
        }</span>

        <span class="cov0" title="0">c, err := rc4.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("malformed PDF: invalid RC4 key: %v", err)
        }</span>

        <span class="cov0" title="0">var u []byte
        if R == 2 </span><span class="cov0" title="0">{
                u = make([]byte, 32)
                copy(u, passwordPad)
                c.XORKeyStream(u, u)
        }</span> else<span class="cov0" title="0"> {
                h.Reset()
                h.Write(passwordPad)
                h.Write([]byte(ID))
                u = h.Sum(nil)
                c.XORKeyStream(u, u)

                for i := 1; i &lt;= 19; i++ </span><span class="cov0" title="0">{
                        key1 := make([]byte, len(key))
                        copy(key1, key)
                        for j := range key1 </span><span class="cov0" title="0">{
                                key1[j] ^= byte(i)
                        }</span>
                        <span class="cov0" title="0">c, _ = rc4.NewCipher(key1)
                        c.XORKeyStream(u, u)</span>
                }
        }

        <span class="cov0" title="0">if !bytes.HasPrefix([]byte(U), u) </span><span class="cov0" title="0">{
                return ErrInvalidPassword
        }</span>

        <span class="cov0" title="0">r.key = key
        r.useAES = V == 4

        return nil</span>
}

var ErrInvalidPassword = fmt.Errorf("encrypted PDF: invalid password")

func okayV4(encrypt dict) bool <span class="cov0" title="0">{
        cf, ok := encrypt["CF"].(dict)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">stmf, ok := encrypt["StmF"].(name)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">strf, ok := encrypt["StrF"].(name)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if stmf != strf </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">cfparam, ok := cf[stmf].(dict)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if cfparam["AuthEvent"] != nil &amp;&amp; cfparam["AuthEvent"] != name("DocOpen") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if cfparam["Length"] != nil &amp;&amp; cfparam["Length"] != int64(16) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if cfparam["CFM"] != name("AESV2") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func cryptKey(key []byte, useAES bool, ptr objptr) []byte <span class="cov0" title="0">{
        h := md5.New()
        h.Write(key)
        h.Write([]byte{byte(ptr.id), byte(ptr.id &gt;&gt; 8), byte(ptr.id &gt;&gt; 16), byte(ptr.gen), byte(ptr.gen &gt;&gt; 8)})
        if useAES </span><span class="cov0" title="0">{
                h.Write([]byte("sAlT"))
        }</span>
        <span class="cov0" title="0">return h.Sum(nil)</span>
}

func decryptString(key []byte, useAES bool, ptr objptr, x string) string <span class="cov0" title="0">{
        key = cryptKey(key, useAES, ptr)
        if useAES </span><span class="cov0" title="0">{
                s := []byte(x)
                if len(s) &lt; aes.BlockSize </span><span class="cov0" title="0">{
                        panic("Encrypted text shorter that AES block size")</span>
                }

                <span class="cov0" title="0">block, _ := aes.NewCipher(key)
                iv := s[:aes.BlockSize]
                s = s[aes.BlockSize:]

                stream := cipher.NewCBCDecrypter(block, iv)
                stream.CryptBlocks(s, s)
                x = string(s)</span>
        } else<span class="cov0" title="0"> {
                c, _ := rc4.NewCipher(key)
                data := []byte(x)
                c.XORKeyStream(data, data)
                x = string(data)
        }</span>
        <span class="cov0" title="0">return x</span>
}

func decryptStream(key []byte, useAES bool, ptr objptr, rd io.Reader) io.Reader <span class="cov0" title="0">{
        key = cryptKey(key, useAES, ptr)
        if useAES </span><span class="cov0" title="0">{
                cb, err := aes.NewCipher(key)
                if err != nil </span><span class="cov0" title="0">{
                        panic("AES: " + err.Error())</span>
                }
                <span class="cov0" title="0">iv := make([]byte, 16)
                io.ReadFull(rd, iv)
                cbc := cipher.NewCBCDecrypter(cb, iv)
                rd = &amp;cbcReader{cbc: cbc, rd: rd, buf: make([]byte, 16)}</span>
        } else<span class="cov0" title="0"> {
                c, _ := rc4.NewCipher(key)
                rd = &amp;cipher.StreamReader{S: c, R: rd}
        }</span>
        <span class="cov0" title="0">return rd</span>
}

type cbcReader struct {
        cbc  cipher.BlockMode
        rd   io.Reader
        buf  []byte
        pend []byte
}

func (r *cbcReader) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        if len(r.pend) == 0 </span><span class="cov0" title="0">{
                _, err = io.ReadFull(r.rd, r.buf)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">r.cbc.CryptBlocks(r.buf, r.buf)
                r.pend = r.buf</span>
        }
        <span class="cov0" title="0">n = copy(b, r.pend)
        r.pend = r.pend[n:]
        return n, nil</span>
}

// ExtractAllPagesParallel 
// 
func (r *Reader) ExtractAllPagesParallel(ctx context.Context, workers int) ([]string, error) <span class="cov0" title="0">{
        if workers &lt;= 0 </span><span class="cov0" title="0">{
                workers = runtime.NumCPU()
        }</span>

        // 
        <span class="cov0" title="0">extractor := NewParallelExtractor(workers)
        defer extractor.Close()

        // 
        numPages := r.NumPage()
        pages := make([]Page, numPages)
        for i := 0; i &lt; numPages; i++ </span><span class="cov0" title="0">{
                pages[i] = r.Page(i + 1)
                // 
                pages[i].SetFontCacheInterface(extractor.prefetcher.cache)
        }</span>

        // 
        <span class="cov0" title="0">textsPerPage, err := extractor.ExtractAllPages(ctx, pages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 
        <span class="cov0" title="0">results := make([]string, len(textsPerPage))
        for i, texts := range textsPerPage </span><span class="cov0" title="0">{
                if len(texts) == 0 </span><span class="cov0" title="0">{
                        results[i] = ""
                        continue</span>
                }

                // 
                <span class="cov0" title="0">totalLen := 0
                for _, t := range texts </span><span class="cov0" title="0">{
                        totalLen += len(t.S) + 1 // +1 for space
                }</span>

                // 
                <span class="cov0" title="0">builder := NewStringBuffer(totalLen)
                for j, t := range texts </span><span class="cov0" title="0">{
                        builder.WriteString(t.S)
                        if j &lt; len(texts)-1 </span><span class="cov0" title="0">{
                                builder.WriteByte(' ')
                        }</span>
                }
                <span class="cov0" title="0">results[i] = builder.StringCopy()</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "hash/fnv"
        "sync"
        "sync/atomic"
        "time"
)

// ShardedCache 
// - 256 
// -  LRU 
// - 
// - 
type ShardedCache struct {
        shards    [256]*CacheShard
        shardMask uint64
        maxSize   int
        ttl       time.Duration
}

// CacheShard 
type CacheShard struct {
        mu      sync.RWMutex
        items   map[string]*ShardedCacheEntry
        head    *ShardedCacheEntry // LRU 
        tail    *ShardedCacheEntry // LRU 
        maxSize int

        // 
        hits      uint64
        misses    uint64
        evictions uint64
        size      int64
}

// ShardedCacheEntry 
type ShardedCacheEntry struct {
        key        string
        value      interface{}
        expiration time.Time
        size       int64

        // LRU 
        prev *ShardedCacheEntry
        next *ShardedCacheEntry

        // 
        accessCount uint64
        lastAccess  int64 // Unix nano
}

// NewShardedCache 
func NewShardedCache(maxSize int, ttl time.Duration) *ShardedCache <span class="cov8" title="1">{
        if maxSize &lt;= 0 </span><span class="cov0" title="0">{
                maxSize = 10000
        }</span>

        <span class="cov8" title="1">sc := &amp;ShardedCache{
                shardMask: 255, // 256 
                maxSize:   maxSize,
                ttl:       ttl,
        }

        // 
        sizePerShard := maxSize / 256
        if sizePerShard &lt; 1 </span><span class="cov8" title="1">{
                sizePerShard = 1
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; 256; i++ </span><span class="cov8" title="1">{
                sc.shards[i] = &amp;CacheShard{
                        items:   make(map[string]*ShardedCacheEntry, sizePerShard),
                        maxSize: sizePerShard,
                }
        }</span>

        <span class="cov8" title="1">return sc</span>
}

// getShard 
func (sc *ShardedCache) getShard(key string) *CacheShard <span class="cov8" title="1">{
        h := fnv.New64a()
        h.Write([]byte(key))
        hash := h.Sum64()
        return sc.shards[hash&amp;sc.shardMask]
}</span>

// Get 
func (sc *ShardedCache) Get(key string) (interface{}, bool) <span class="cov8" title="1">{
        shard := sc.getShard(key)
        shard.mu.RLock()

        entry, ok := shard.items[key]
        if !ok </span><span class="cov8" title="1">{
                shard.mu.RUnlock()
                atomic.AddUint64(&amp;shard.misses, 1)
                return nil, false
        }</span>

        // 
        <span class="cov8" title="1">if !entry.expiration.IsZero() &amp;&amp; time.Now().After(entry.expiration) </span><span class="cov8" title="1">{
                shard.mu.RUnlock()
                atomic.AddUint64(&amp;shard.misses, 1)
                return nil, false
        }</span>

        <span class="cov8" title="1">value := entry.value
        shard.mu.RUnlock()

        // 
        atomic.AddUint64(&amp;entry.accessCount, 1)
        atomic.StoreInt64(&amp;entry.lastAccess, time.Now().UnixNano())
        atomic.AddUint64(&amp;shard.hits, 1)

        //  LRU 
        shard.mu.Lock()
        shard.moveToFront(entry)
        shard.mu.Unlock()

        return value, true</span>
}

// Set 
func (sc *ShardedCache) Set(key string, value interface{}, size int64) <span class="cov8" title="1">{
        shard := sc.getShard(key)
        shard.mu.Lock()
        defer shard.mu.Unlock()

        now := time.Now()
        expiration := time.Time{}
        if sc.ttl &gt; 0 </span><span class="cov8" title="1">{
                expiration = now.Add(sc.ttl)
        }</span>

        // 
        <span class="cov8" title="1">if entry, ok := shard.items[key]; ok </span><span class="cov0" title="0">{
                // 
                oldSize := entry.size
                entry.value = value
                entry.size = size
                entry.expiration = expiration
                atomic.StoreInt64(&amp;entry.lastAccess, now.UnixNano())
                atomic.AddUint64(&amp;entry.accessCount, 1)

                // 
                atomic.AddInt64(&amp;shard.size, size-oldSize)

                // 
                shard.moveToFront(entry)
                return
        }</span>

        // 
        <span class="cov8" title="1">for len(shard.items) &gt;= shard.maxSize &amp;&amp; shard.tail != nil </span><span class="cov8" title="1">{
                shard.evictLRU()
        }</span>

        // 
        <span class="cov8" title="1">entry := &amp;ShardedCacheEntry{
                key:        key,
                value:      value,
                size:       size,
                expiration: expiration,
        }
        atomic.StoreInt64(&amp;entry.lastAccess, now.UnixNano())
        atomic.StoreUint64(&amp;entry.accessCount, 1)

        shard.items[key] = entry
        shard.addToFront(entry)
        atomic.AddInt64(&amp;shard.size, size)</span>
}

// Delete 
func (sc *ShardedCache) Delete(key string) <span class="cov8" title="1">{
        shard := sc.getShard(key)
        shard.mu.Lock()
        defer shard.mu.Unlock()

        entry, ok := shard.items[key]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">delete(shard.items, key)
        shard.removeFromList(entry)
        atomic.AddInt64(&amp;shard.size, -entry.size)</span>
}

// moveToFront  LRU 
// 
func (shard *CacheShard) moveToFront(entry *ShardedCacheEntry) <span class="cov8" title="1">{
        if entry == shard.head </span><span class="cov8" title="1">{
                return
        }</span>

        // 
        <span class="cov8" title="1">if entry.prev != nil </span><span class="cov8" title="1">{
                entry.prev.next = entry.next
        }</span>
        <span class="cov8" title="1">if entry.next != nil </span><span class="cov8" title="1">{
                entry.next.prev = entry.prev
        }</span>
        <span class="cov8" title="1">if entry == shard.tail </span><span class="cov8" title="1">{
                shard.tail = entry.prev
        }</span>

        // 
        <span class="cov8" title="1">entry.prev = nil
        entry.next = shard.head
        if shard.head != nil </span><span class="cov8" title="1">{
                shard.head.prev = entry
        }</span>
        <span class="cov8" title="1">shard.head = entry

        if shard.tail == nil </span><span class="cov0" title="0">{
                shard.tail = entry
        }</span>
}

// addToFront  LRU 
// 
func (shard *CacheShard) addToFront(entry *ShardedCacheEntry) <span class="cov8" title="1">{
        entry.prev = nil
        entry.next = shard.head

        if shard.head != nil </span><span class="cov8" title="1">{
                shard.head.prev = entry
        }</span>
        <span class="cov8" title="1">shard.head = entry

        if shard.tail == nil </span><span class="cov8" title="1">{
                shard.tail = entry
        }</span>
}

// removeFromList  LRU 
// 
func (shard *CacheShard) removeFromList(entry *ShardedCacheEntry) <span class="cov8" title="1">{
        if entry.prev != nil </span><span class="cov8" title="1">{
                entry.prev.next = entry.next
        }</span>
        <span class="cov8" title="1">if entry.next != nil </span><span class="cov0" title="0">{
                entry.next.prev = entry.prev
        }</span>
        <span class="cov8" title="1">if entry == shard.head </span><span class="cov8" title="1">{
                shard.head = entry.next
        }</span>
        <span class="cov8" title="1">if entry == shard.tail </span><span class="cov8" title="1">{
                shard.tail = entry.prev
        }</span>

        <span class="cov8" title="1">entry.prev = nil
        entry.next = nil</span>
}

// evictLRU 
// 
func (shard *CacheShard) evictLRU() <span class="cov8" title="1">{
        if shard.tail == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">entry := shard.tail
        delete(shard.items, entry.key)
        shard.removeFromList(entry)
        atomic.AddInt64(&amp;shard.size, -entry.size)
        atomic.AddUint64(&amp;shard.evictions, 1)</span>
}

// GetStats 
func (sc *ShardedCache) GetStats() ShardedCacheStats <span class="cov8" title="1">{
        var stats ShardedCacheStats

        for i := 0; i &lt; 256; i++ </span><span class="cov8" title="1">{
                shard := sc.shards[i]
                stats.Hits += atomic.LoadUint64(&amp;shard.hits)
                stats.Misses += atomic.LoadUint64(&amp;shard.misses)
                stats.Evictions += atomic.LoadUint64(&amp;shard.evictions)
                stats.Size += atomic.LoadInt64(&amp;shard.size)

                shard.mu.RLock()
                stats.Entries += int64(len(shard.items))
                shard.mu.RUnlock()
        }</span>

        <span class="cov8" title="1">return stats</span>
}

// ShardedCacheStats 
type ShardedCacheStats struct {
        Hits      uint64
        Misses    uint64
        Evictions uint64
        Entries   int64
        Size      int64
}

// Clear 
func (sc *ShardedCache) Clear() <span class="cov8" title="1">{
        for i := 0; i &lt; 256; i++ </span><span class="cov8" title="1">{
                shard := sc.shards[i]
                shard.mu.Lock()
                shard.items = make(map[string]*ShardedCacheEntry)
                shard.head = nil
                shard.tail = nil
                atomic.StoreInt64(&amp;shard.size, 0)
                shard.mu.Unlock()
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "sync"
        "unsafe"
)

// SIMD-optimized string operations for better performance
// These functions use unsafe operations to achieve zero-copy optimizations
// and SIMD-like processing where possible

// FastStringSearch performs optimized string search using SIMD-like operations
// This is a simplified implementation that can be extended with actual SIMD instructions
func FastStringSearch(haystack, needle string) int <span class="cov0" title="0">{
        if len(needle) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if len(haystack) &lt; len(needle) </span><span class="cov0" title="0">{
                return -1
        }</span>

        // Use Go's built-in Index for small needles (optimized by compiler)
        <span class="cov0" title="0">if len(needle) &lt;= 8 </span><span class="cov0" title="0">{
                return indexByte(haystack, needle)
        }</span>

        // For longer needles, use optimized search
        <span class="cov0" title="0">return optimizedIndex(haystack, needle)</span>
}

// indexByte is a fast byte-by-byte search for small needles
func indexByte(s, substr string) int <span class="cov0" title="0">{
        if len(substr) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if len(s) &lt; len(substr) </span><span class="cov0" title="0">{
                return -1
        }</span>

        // Convert to byte slices for faster access
        <span class="cov0" title="0">sBytes := unsafe.Slice(unsafe.StringData(s), len(s))
        substrBytes := unsafe.Slice(unsafe.StringData(substr), len(substr))

        for i := 0; i &lt;= len(sBytes)-len(substrBytes); i++ </span><span class="cov0" title="0">{
                if sBytes[i] == substrBytes[0] </span><span class="cov0" title="0">{
                        // Check remaining bytes
                        match := true
                        for j := 1; j &lt; len(substrBytes); j++ </span><span class="cov0" title="0">{
                                if sBytes[i+j] != substrBytes[j] </span><span class="cov0" title="0">{
                                        match = false
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                                return i
                        }</span>
                }
        }
        <span class="cov0" title="0">return -1</span>
}

// optimizedIndex uses a more efficient search algorithm for longer strings
func optimizedIndex(s, substr string) int <span class="cov0" title="0">{
        if len(substr) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if len(s) &lt; len(substr) </span><span class="cov0" title="0">{
                return -1
        }</span>

        // Use Boyer-Moore-like algorithm for better performance
        <span class="cov0" title="0">return boyerMooreSearch(s, substr)</span>
}

// boyerMooreSearch implements a simplified Boyer-Moore string search
func boyerMooreSearch(text, pattern string) int <span class="cov0" title="0">{
        if len(pattern) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if len(text) &lt; len(pattern) </span><span class="cov0" title="0">{
                return -1
        }</span>

        // Build bad character table
        <span class="cov0" title="0">badChar := make([]int, 256)
        for i := range badChar </span><span class="cov0" title="0">{
                badChar[i] = len(pattern)
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; len(pattern)-1; i++ </span><span class="cov0" title="0">{
                badChar[pattern[i]] = len(pattern) - 1 - i
        }</span>

        // Search
        <span class="cov0" title="0">i := 0
        for i &lt;= len(text)-len(pattern) </span><span class="cov0" title="0">{
                j := len(pattern) - 1
                for j &gt;= 0 &amp;&amp; pattern[j] == text[i+j] </span><span class="cov0" title="0">{
                        j--
                }</span>
                <span class="cov0" title="0">if j &lt; 0 </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov0" title="0">i += badChar[text[i+len(pattern)-1]]</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// FastStringConcat concatenates strings with optimized memory allocation
func FastStringConcat(strings ...string) string <span class="cov0" title="0">{
        if len(strings) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if len(strings) == 1 </span><span class="cov0" title="0">{
                return strings[0]
        }</span>

        // Calculate total length
        <span class="cov0" title="0">totalLen := 0
        for _, s := range strings </span><span class="cov0" title="0">{
                totalLen += len(s)
        }</span>

        // Pre-allocate result slice
        <span class="cov0" title="0">result := make([]byte, 0, totalLen)

        // Copy strings without intermediate allocations
        for _, s := range strings </span><span class="cov0" title="0">{
                result = append(result, s...)
        }</span>

        <span class="cov0" title="0">return unsafe.String(unsafe.SliceData(result), len(result))</span>
}

// ZeroCopyStringSlice creates a string slice without copying data
// WARNING: This is unsafe and the returned strings share memory with the input
func ZeroCopyStringSlice(data []byte, separators []byte) []string <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var result []string
        start := 0

        for i, b := range data </span><span class="cov0" title="0">{
                for _, sep := range separators </span><span class="cov0" title="0">{
                        if b == sep </span><span class="cov0" title="0">{
                                if start &lt; i </span><span class="cov0" title="0">{
                                        // Create string without copying
                                        str := unsafe.String(unsafe.SliceData(data[start:i]), i-start)
                                        result = append(result, str)
                                }</span>
                                <span class="cov0" title="0">start = i + 1
                                break</span>
                        }
                }
        }

        // Add remaining part
        <span class="cov0" title="0">if start &lt; len(data) </span><span class="cov0" title="0">{
                str := unsafe.String(unsafe.SliceData(data[start:]), len(data)-start)
                result = append(result, str)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// OptimizedMemoryPool provides better memory pool management
type OptimizedMemoryPool struct {
        pool sync.Pool
        size int
}

// NewOptimizedMemoryPool creates a pool with size tracking
func NewOptimizedMemoryPool(size int) *OptimizedMemoryPool <span class="cov0" title="0">{
        return &amp;OptimizedMemoryPool{
                size: size,
                pool: sync.Pool{
                        New: func() interface{} </span><span class="cov0" title="0">{
                                return make([]byte, 0, size)
                        }</span>,
                },
        }
}

// Get retrieves a buffer from the pool
func (omp *OptimizedMemoryPool) Get() []byte <span class="cov0" title="0">{
        return omp.pool.Get().([]byte)
}</span>

// Put returns a buffer to the pool, resetting it
func (omp *OptimizedMemoryPool) Put(bufPtr *[]byte) <span class="cov0" title="0">{
        // Reset to zero length
        *bufPtr = (*bufPtr)[:0]
        omp.pool.Put(bufPtr)
}</span>

// EstimateCapacity provides better capacity estimation for slices
func EstimateCapacity(currentLen int, growthFactor float64) int <span class="cov8" title="1">{
        if currentLen == 0 </span><span class="cov0" title="0">{
                return 16
        }</span>
        <span class="cov8" title="1">estimated := int(float64(currentLen) * growthFactor)
        if estimated &lt; currentLen </span><span class="cov0" title="0">{
                return currentLen * 2
        }</span>
        <span class="cov8" title="1">return estimated</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "math"
)

// SpatialIndex provides spatial indexing for efficient text location queries
// This is a simple implementation using a grid-based approach; for production use,
// consider a more sophisticated structure like R-tree
type SpatialIndex struct {
        grid     map[GridKey][]Text
        cellSize float64
        bounds   Rect
        texts    []Text
}

// GridKey represents a grid cell identifier
type GridKey struct {
        X, Y int
}

// NewSpatialIndex creates a new spatial index from text elements
func NewSpatialIndex(texts []Text) *SpatialIndex <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov8" title="1">{
                return &amp;SpatialIndex{
                        grid:  make(map[GridKey][]Text),
                        texts: texts,
                }
        }</span>

        // Calculate bounds of all text elements
        <span class="cov8" title="1">var minX, minY, maxX, maxY float64
        for i, t := range texts </span><span class="cov8" title="1">{
                x := t.X
                y := t.Y
                w := t.W

                if i == 0 </span><span class="cov8" title="1">{
                        minX, minY = x, y
                        maxX, maxY = x+w, y+t.FontSize
                }</span> else<span class="cov8" title="1"> {
                        minX = math.Min(minX, x)
                        minY = math.Min(minY, y)
                        maxX = math.Max(maxX, x+w)
                        maxY = math.Max(maxY, y+t.FontSize)
                }</span>
        }

        <span class="cov8" title="1">bounds := Rect{Min: Point{X: minX, Y: minY}, Max: Point{X: maxX, Y: maxY}}

        // Use average font size as cell size for reasonable granularity
        totalSize := 0.0
        for _, t := range texts </span><span class="cov8" title="1">{
                totalSize += t.FontSize
        }</span>
        <span class="cov8" title="1">avgFontSize := totalSize / float64(len(texts))
        cellSize := avgFontSize * 2.0 // Make cells slightly larger than average font size

        si := &amp;SpatialIndex{
                grid:     make(map[GridKey][]Text),
                cellSize: cellSize,
                bounds:   bounds,
                texts:    texts,
        }

        // Insert all text elements into grid
        for _, t := range texts </span><span class="cov8" title="1">{
                si.insert(t)
        }</span>

        <span class="cov8" title="1">return si</span>
}

// insert adds a text element to the spatial index
func (si *SpatialIndex) insert(t Text) <span class="cov8" title="1">{
        // Calculate which grid cells this text element overlaps
        minX, minY := si.worldToGrid(t.X, t.Y)
        maxX, maxY := si.worldToGrid(t.X+t.W, t.Y+t.FontSize)

        for x := minX; x &lt;= maxX; x++ </span><span class="cov8" title="1">{
                for y := minY; y &lt;= maxY; y++ </span><span class="cov8" title="1">{
                        key := GridKey{X: x, Y: y}
                        si.grid[key] = append(si.grid[key], t)
                }</span>
        }
}

// worldToGrid converts world coordinates to grid coordinates
func (si *SpatialIndex) worldToGrid(x, y float64) (int, int) <span class="cov8" title="1">{
        gridX := int((x - si.bounds.Min.X) / si.cellSize)
        gridY := int((y - si.bounds.Min.Y) / si.cellSize)
        return gridX, gridY
}</span>

// Query returns all text elements that potentially intersect with the given bounds
func (si *SpatialIndex) Query(bounds Rect) []Text <span class="cov8" title="1">{
        minX, minY := si.worldToGrid(bounds.Min.X, bounds.Min.Y)
        maxX, maxY := si.worldToGrid(bounds.Max.X, bounds.Max.Y)

        // Use a map to avoid duplicate results
        uniqueResults := make(map[string]Text)

        for x := minX; x &lt;= maxX; x++ </span><span class="cov8" title="1">{
                for y := minY; y &lt;= maxY; y++ </span><span class="cov8" title="1">{
                        key := GridKey{X: x, Y: y}
                        if cellTexts, exists := si.grid[key]; exists </span><span class="cov8" title="1">{
                                for _, t := range cellTexts </span><span class="cov8" title="1">{
                                        // Additional check to ensure actual intersection
                                        if si.intersects(bounds, t) </span><span class="cov8" title="1">{
                                                // Use text content and position as unique identifier
                                                key := t.S + string(rune(int(t.X*100))) + string(rune(int(t.Y*100)))
                                                uniqueResults[key] = t
                                        }</span>
                                }
                        }
                }
        }

        // Convert map back to slice
        <span class="cov8" title="1">results := make([]Text, 0, len(uniqueResults))
        for _, t := range uniqueResults </span><span class="cov8" title="1">{
                results = append(results, t)
        }</span>

        <span class="cov8" title="1">return results</span>
}

// intersects checks if a text element intersects with the given bounds
func (si *SpatialIndex) intersects(bounds Rect, t Text) bool <span class="cov8" title="1">{
        textBounds := Rect{
                Min: Point{X: t.X, Y: t.Y},
                Max: Point{X: t.X + t.W, Y: t.Y + t.FontSize},
        }

        return !(textBounds.Max.X &lt; bounds.Min.X ||
                textBounds.Min.X &gt; bounds.Max.X ||
                textBounds.Max.Y &lt; bounds.Min.Y ||
                textBounds.Min.Y &gt; bounds.Max.Y)
}</span>

// RTreeSpatialIndex provides a more sophisticated spatial index using a proper R-tree implementation
type RTreeSpatialIndex struct {
        root       *RTreeNode
        texts      []Text
        maxEntries int // Max entries per node
        minEntries int // Min entries per node (for rebalancing)
}

// RTreeNode represents a node in the R-tree
type RTreeNode struct {
        bounds   Rect
        children []*RTreeNode
        leaf     bool
        texts    []Text // Only used in leaf nodes
        level    int    // Level in the tree (0 for leaves)
}

// NewRTreeSpatialIndex creates a new R-tree based spatial index
func NewRTreeSpatialIndex(texts []Text) *RTreeSpatialIndex <span class="cov8" title="1">{
        rt := &amp;RTreeSpatialIndex{
                maxEntries: 10, // Default max entries per node
                minEntries: 4,  // Default min entries per node
        }

        if len(texts) == 0 </span><span class="cov8" title="1">{
                rt.root = nil
                rt.texts = texts
                return rt
        }</span>

        <span class="cov8" title="1">rt.texts = texts
        rt.root = rt.buildTree(texts)

        return rt</span>
}

// buildTree builds the R-tree from a set of text elements
func (rt *RTreeSpatialIndex) buildTree(texts []Text) *RTreeNode <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If the number of texts is less than or equal to maxEntries, create a leaf node
        <span class="cov8" title="1">if len(texts) &lt;= rt.maxEntries </span><span class="cov8" title="1">{
                leaf := &amp;RTreeNode{
                        leaf:  true,
                        texts: texts,
                        level: 0,
                }
                leaf.bounds = rt.calculateBounds(texts)
                return leaf
        }</span>

        // Otherwise, subdivide the texts into groups and create internal nodes
        // For this implementation, we'll use a simple approach by grouping by spatial proximity

        // Create root node
        <span class="cov0" title="0">root := &amp;RTreeNode{
                leaf:  false,
                level: 1,
        }

        // Partition texts into groups and build child nodes
        groups := rt.partitionTexts(texts, rt.maxEntries)

        for _, group := range groups </span><span class="cov0" title="0">{
                child := rt.buildTree(group)
                if child != nil </span><span class="cov0" title="0">{
                        root.children = append(root.children, child)
                }</span>
        }

        <span class="cov0" title="0">root.bounds = rt.calculateNodeBounds(root)

        return root</span>
}

// partitionTexts divides texts into groups based on spatial proximity
func (rt *RTreeSpatialIndex) partitionTexts(texts []Text, maxGroupSize int) [][]Text <span class="cov0" title="0">{
        if len(texts) &lt;= maxGroupSize </span><span class="cov0" title="0">{
                return [][]Text{texts}
        }</span>

        <span class="cov0" title="0">var groups [][]Text

        // For this simple implementation, we'll sort by X coordinate and group sequentially
        sorted := make([]Text, len(texts))
        copy(sorted, texts)

        // Sort by X position (left to right)
        for i := 0; i &lt; len(sorted); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(sorted); j++ </span><span class="cov0" title="0">{
                        if sorted[i].X &gt; sorted[j].X </span><span class="cov0" title="0">{
                                sorted[i], sorted[j] = sorted[j], sorted[i]
                        }</span>
                }
        }

        // Group texts sequentially
        <span class="cov0" title="0">for i := 0; i &lt; len(sorted); i += maxGroupSize </span><span class="cov0" title="0">{
                end := i + maxGroupSize
                if end &gt; len(sorted) </span><span class="cov0" title="0">{
                        end = len(sorted)
                }</span>
                <span class="cov0" title="0">groups = append(groups, sorted[i:end])</span>
        }

        <span class="cov0" title="0">return groups</span>
}

// calculateBounds calculates the bounding box for a slice of texts
func (rt *RTreeSpatialIndex) calculateBounds(texts []Text) Rect <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov8" title="1">{
                return Rect{}
        }</span>

        <span class="cov8" title="1">minX, minY := texts[0].X, texts[0].Y
        maxX, maxY := texts[0].X+texts[0].W, texts[0].Y+texts[0].FontSize

        for _, t := range texts[1:] </span><span class="cov8" title="1">{
                x, y := t.X, t.Y
                w, h := t.W, t.FontSize

                minX = math.Min(minX, x)
                minY = math.Min(minY, y)
                maxX = math.Max(maxX, x+w)
                maxY = math.Max(maxY, y+h)
        }</span>

        <span class="cov8" title="1">return Rect{
                Min: Point{X: minX, Y: minY},
                Max: Point{X: maxX, Y: maxY},
        }</span>
}

// calculateNodeBounds calculates the bounding box for a node
func (rt *RTreeSpatialIndex) calculateNodeBounds(node *RTreeNode) Rect <span class="cov0" title="0">{
        if node.leaf </span><span class="cov0" title="0">{
                return rt.calculateBounds(node.texts)
        }</span>

        <span class="cov0" title="0">if len(node.children) == 0 </span><span class="cov0" title="0">{
                return Rect{}
        }</span>

        <span class="cov0" title="0">bounds := node.children[0].bounds
        for _, child := range node.children[1:] </span><span class="cov0" title="0">{
                bounds = rt.expandBounds(bounds, child.bounds)
        }</span>

        <span class="cov0" title="0">return bounds</span>
}

// expandBounds expands the first rectangle to include the second
func (rt *RTreeSpatialIndex) expandBounds(r1, r2 Rect) Rect <span class="cov8" title="1">{
        return Rect{
                Min: Point{
                        X: math.Min(r1.Min.X, r2.Min.X),
                        Y: math.Min(r1.Min.Y, r2.Min.Y),
                },
                Max: Point{
                        X: math.Max(r1.Max.X, r2.Max.X),
                        Y: math.Max(r1.Max.Y, r2.Max.Y),
                },
        }
}</span>

// Insert adds a text element to the R-tree
func (rt *RTreeSpatialIndex) Insert(text Text) <span class="cov8" title="1">{
        if rt.root == nil </span><span class="cov8" title="1">{
                rt.root = &amp;RTreeNode{
                        leaf:  true,
                        texts: []Text{text},
                        level: 0,
                        bounds: Rect{
                                Min: Point{X: text.X, Y: text.Y},
                                Max: Point{X: text.X + text.W, Y: text.Y + text.FontSize},
                        },
                }
                rt.texts = append(rt.texts, text)
                return
        }</span>

        // Insert and potentially split nodes if they become overfull
        <span class="cov8" title="1">splitRoot, newRoot := rt.insertNode(rt.root, text, 0)

        if splitRoot != nil </span><span class="cov0" title="0">{
                // Create a new root node
                rt.root = &amp;RTreeNode{
                        bounds:   rt.expandBounds(splitRoot.bounds, newRoot.bounds),
                        children: []*RTreeNode{splitRoot, newRoot},
                        leaf:     false,
                        level:    splitRoot.level + 1,
                }
        }</span>

        <span class="cov8" title="1">rt.texts = append(rt.texts, text)</span>
}

// insertNode inserts a text into a node and returns any split nodes
func (rt *RTreeSpatialIndex) insertNode(node *RTreeNode, text Text, level int) (splitNode, newNode *RTreeNode) <span class="cov8" title="1">{
        textBounds := Rect{
                Min: Point{X: text.X, Y: text.Y},
                Max: Point{X: text.X + text.W, Y: text.Y + text.FontSize},
        }

        if node.level == level </span><span class="cov8" title="1">{
                if node.leaf </span><span class="cov8" title="1">{
                        // Add text to leaf node
                        node.texts = append(node.texts, text)
                        node.bounds = rt.expandBounds(node.bounds, textBounds)

                        // Check if node needs to be split
                        if len(node.texts) &gt; rt.maxEntries </span><span class="cov0" title="0">{
                                return rt.splitNode(node)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Add to internal node - find the best child
                        bestChild := rt.chooseBestSubtree(node, textBounds)
                        splitChild, newChild := rt.insertNode(bestChild, text, level)

                        if newChild != nil </span><span class="cov0" title="0">{
                                // Child was split, update parent
                                node.children = append(node.children[:0], node.children[0:]...) // copy
                                // Replace the split child with the new children
                                newChildren := make([]*RTreeNode, 0, len(node.children))
                                for _, child := range node.children </span><span class="cov0" title="0">{
                                        if child == bestChild </span><span class="cov0" title="0">{
                                                newChildren = append(newChildren, splitChild, newChild)
                                        }</span> else<span class="cov0" title="0"> {
                                                newChildren = append(newChildren, child)
                                        }</span>
                                }
                                <span class="cov0" title="0">node.children = newChildren

                                // Update node bounds
                                node.bounds = rt.calculateNodeBounds(node)

                                // Check if parent needs to be split
                                if len(node.children) &gt; rt.maxEntries </span><span class="cov0" title="0">{
                                        return rt.splitNode(node)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Update node bounds to include the new text
                                node.bounds = rt.expandBounds(node.bounds, textBounds)
                        }</span>
                }
                <span class="cov8" title="1">return nil, nil</span>
        }

        // Go deeper into the tree
        <span class="cov0" title="0">return node, nil</span>
}

// chooseBestSubtree finds the best child node for a given text
func (rt *RTreeSpatialIndex) chooseBestSubtree(node *RTreeNode, bounds Rect) *RTreeNode <span class="cov0" title="0">{
        var bestChild *RTreeNode
        minIncrease := math.MaxFloat64

        for _, child := range node.children </span><span class="cov0" title="0">{
                // Calculate the area increase if we add the bounds to this child
                currentArea := rt.rectangleArea(child.bounds)
                unionBounds := rt.expandBounds(child.bounds, bounds)
                unionArea := rt.rectangleArea(unionBounds)
                increase := unionArea - currentArea

                if increase &lt; minIncrease || (increase == minIncrease &amp;&amp; rt.rectangleArea(child.bounds) &lt; rt.rectangleArea(bestChild.bounds)) </span><span class="cov0" title="0">{
                        minIncrease = increase
                        bestChild = child
                }</span>
        }

        <span class="cov0" title="0">return bestChild</span>
}

// rectangleArea calculates the area of a rectangle
func (rt *RTreeSpatialIndex) rectangleArea(r Rect) float64 <span class="cov8" title="1">{
        width := r.Max.X - r.Min.X
        height := r.Max.Y - r.Min.Y
        if width &lt;= 0 || height &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return width * height</span>
}

// splitNode splits an overfull node
func (rt *RTreeSpatialIndex) splitNode(node *RTreeNode) (*RTreeNode, *RTreeNode) <span class="cov0" title="0">{
        // Use a simple quadratic split algorithm
        if node.leaf </span><span class="cov0" title="0">{
                // Split leaf node's texts
                group1, group2 := rt.quadraticSplitTexts(node.texts)

                newNode1 := &amp;RTreeNode{
                        leaf:  true,
                        texts: group1,
                        level: node.level,
                }
                newNode1.bounds = rt.calculateBounds(group1)

                newNode2 := &amp;RTreeNode{
                        leaf:  true,
                        texts: group2,
                        level: node.level,
                }
                newNode2.bounds = rt.calculateBounds(group2)

                return newNode1, newNode2
        }</span> else<span class="cov0" title="0"> {
                // Split internal node's children
                group1, group2 := rt.quadraticSplitNodes(node.children)

                newNode1 := &amp;RTreeNode{
                        children: group1,
                        leaf:     false,
                        level:    node.level,
                }
                newNode1.bounds = rt.calculateNodeBounds(newNode1)

                newNode2 := &amp;RTreeNode{
                        children: group2,
                        leaf:     false,
                        level:    node.level,
                }
                newNode2.bounds = rt.calculateNodeBounds(newNode2)

                return newNode1, newNode2
        }</span>
}

// quadraticSplitTexts performs a quadratic split of text elements
func (rt *RTreeSpatialIndex) quadraticSplitTexts(texts []Text) ([]Text, []Text) <span class="cov8" title="1">{
        if len(texts) &lt;= 1 </span><span class="cov0" title="0">{
                return texts, []Text{}
        }</span>

        // Find the two most distant texts
        <span class="cov8" title="1">maxDistance := -1.0
        var idx1, idx2 int

        for i := 0; i &lt; len(texts); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(texts); j++ </span><span class="cov8" title="1">{
                        dist := rt.textDistance(texts[i], texts[j])
                        if dist &gt; maxDistance </span><span class="cov8" title="1">{
                                maxDistance = dist
                                idx1, idx2 = i, j
                        }</span>
                }
        }

        // Distribute the remaining texts to the closest group
        <span class="cov8" title="1">group1 := []Text{texts[idx1]}
        group2 := []Text{texts[idx2]}

        for i, text := range texts </span><span class="cov8" title="1">{
                if i == idx1 || i == idx2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">dist1 := rt.textDistance(text, texts[idx1])
                dist2 := rt.textDistance(text, texts[idx2])

                if dist1 &lt; dist2 </span><span class="cov8" title="1">{
                        group1 = append(group1, text)
                }</span> else<span class="cov8" title="1"> {
                        group2 = append(group2, text)
                }</span>
        }

        <span class="cov8" title="1">return group1, group2</span>
}

// quadraticSplitNodes performs a quadratic split of child nodes
func (rt *RTreeSpatialIndex) quadraticSplitNodes(nodes []*RTreeNode) ([]*RTreeNode, []*RTreeNode) <span class="cov0" title="0">{
        if len(nodes) &lt;= 1 </span><span class="cov0" title="0">{
                return nodes, []*RTreeNode{}
        }</span>

        // Find the two nodes with the greatest distance
        <span class="cov0" title="0">maxDistance := -1.0
        var idx1, idx2 int

        for i := 0; i &lt; len(nodes); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(nodes); j++ </span><span class="cov0" title="0">{
                        dist := rt.nodeDistance(nodes[i], nodes[j])
                        if dist &gt; maxDistance </span><span class="cov0" title="0">{
                                maxDistance = dist
                                idx1, idx2 = i, j
                        }</span>
                }
        }

        // Distribute remaining nodes to the closest group
        <span class="cov0" title="0">group1 := []*RTreeNode{nodes[idx1]}
        group2 := []*RTreeNode{nodes[idx2]}

        for i, node := range nodes </span><span class="cov0" title="0">{
                if i == idx1 || i == idx2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">dist1 := rt.nodeDistance(node, nodes[idx1])
                dist2 := rt.nodeDistance(node, nodes[idx2])

                if dist1 &lt; dist2 </span><span class="cov0" title="0">{
                        group1 = append(group1, node)
                }</span> else<span class="cov0" title="0"> {
                        group2 = append(group2, node)
                }</span>
        }

        <span class="cov0" title="0">return group1, group2</span>
}

// textDistance calculates distance between text elements
func (rt *RTreeSpatialIndex) textDistance(t1, t2 Text) float64 <span class="cov8" title="1">{
        center1 := Point{X: t1.X + t1.W/2, Y: t1.Y + t1.FontSize/2}
        center2 := Point{X: t2.X + t2.W/2, Y: t2.Y + t2.FontSize/2}

        dx := center1.X - center2.X
        dy := center1.Y - center2.Y
        return math.Sqrt(dx*dx + dy*dy)
}</span>

// nodeDistance calculates distance between nodes
func (rt *RTreeSpatialIndex) nodeDistance(n1, n2 *RTreeNode) float64 <span class="cov8" title="1">{
        center1 := Point{
                X: (n1.bounds.Min.X + n1.bounds.Max.X) / 2,
                Y: (n1.bounds.Min.Y + n1.bounds.Max.Y) / 2,
        }
        center2 := Point{
                X: (n2.bounds.Min.X + n2.bounds.Max.X) / 2,
                Y: (n2.bounds.Min.Y + n2.bounds.Max.Y) / 2,
        }

        dx := center1.X - center2.X
        dy := center1.Y - center2.Y
        return math.Sqrt(dx*dx + dy*dy)
}</span>

// Query returns all text elements that intersect with the given bounds
func (rt *RTreeSpatialIndex) Query(bounds Rect) []Text <span class="cov8" title="1">{
        if rt.root == nil </span><span class="cov0" title="0">{
                return []Text{}
        }</span>

        <span class="cov8" title="1">return rt.queryNode(rt.root, bounds)</span>
}

// queryNode recursively queries nodes in the R-tree
func (rt *RTreeSpatialIndex) queryNode(node *RTreeNode, bounds Rect) []Text <span class="cov8" title="1">{
        // Check if bounds intersect
        if !rt.intersects(node.bounds, bounds) </span><span class="cov0" title="0">{
                return []Text{}
        }</span>

        <span class="cov8" title="1">if node.leaf </span><span class="cov8" title="1">{
                // For leaf nodes, check each text element
                var results []Text
                for _, t := range node.texts </span><span class="cov8" title="1">{
                        textBounds := Rect{
                                Min: Point{X: t.X, Y: t.Y},
                                Max: Point{X: t.X + t.W, Y: t.Y + t.FontSize},
                        }
                        if rt.intersects(textBounds, bounds) </span><span class="cov8" title="1">{
                                results = append(results, t)
                        }</span>
                }
                <span class="cov8" title="1">return results</span>
        }

        // For internal nodes, query children
        <span class="cov0" title="0">var results []Text
        for _, child := range node.children </span><span class="cov0" title="0">{
                childResults := rt.queryNode(child, bounds)
                results = append(results, childResults...)
        }</span>
        <span class="cov0" title="0">return results</span>
}

// intersects checks if two rectangles intersect
func (rt *RTreeSpatialIndex) intersects(rect1, rect2 Rect) bool <span class="cov8" title="1">{
        return !(rect1.Max.X &lt; rect2.Min.X ||
                rect1.Min.X &gt; rect2.Max.X ||
                rect1.Max.Y &lt; rect2.Min.Y ||
                rect1.Min.Y &gt; rect2.Max.Y)
}</span>

// SpatialIndex interface to allow using either grid or R-tree implementation
type SpatialIndexInterface interface {
        Query(bounds Rect) []Text
        Insert(text Text)
}

// NewSpatialIndexInterface creates a spatial index interface (can be switched between implementations)
func NewSpatialIndexInterface(texts []Text) SpatialIndexInterface <span class="cov8" title="1">{
        // For now, return the R-tree implementation
        return NewRTreeSpatialIndex(texts)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "bufio"
        "context"
        "errors"
        "io"
        "strings"
        "sync"
)

// StreamProcessor handles streaming processing of PDF content to minimize memory usage
type StreamProcessor struct {
        chunkSize    int        // Size of processing chunks
        bufferSize   int        // Size of internal buffers
        maxMemory    int64      // Maximum memory to use
        currentUsage int64      // Current memory usage
        mu           sync.Mutex // Mutex for memory tracking
        ctx          context.Context
        cancel       context.CancelFunc
}

var ErrMemoryLimitExceeded = errors.New("pdf: stream processor memory limit exceeded")

// NewStreamProcessor creates a new streaming processor
func NewStreamProcessor(chunkSize, bufferSize int, maxMemory int64) *StreamProcessor <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;StreamProcessor{
                chunkSize:  chunkSize,
                bufferSize: bufferSize,
                maxMemory:  maxMemory,
                ctx:        ctx,
                cancel:     cancel,
        }
}</span>

func (sp *StreamProcessor) tryReserveMemory(n int64) bool <span class="cov0" title="0">{
        if sp == nil || sp.maxMemory &lt;= 0 || n &lt;= 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">sp.mu.Lock()
        defer sp.mu.Unlock()
        if sp.currentUsage+n &gt; sp.maxMemory </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">sp.currentUsage += n
        return true</span>
}

func (sp *StreamProcessor) releaseMemory(n int64) <span class="cov0" title="0">{
        if sp == nil || sp.maxMemory &lt;= 0 || n &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">sp.mu.Lock()
        sp.currentUsage -= n
        if sp.currentUsage &lt; 0 </span><span class="cov0" title="0">{
                sp.currentUsage = 0
        }</span>
        <span class="cov0" title="0">sp.mu.Unlock()</span>
}

// Close releases resources used by the stream processor
func (sp *StreamProcessor) Close() <span class="cov8" title="1">{
        sp.cancel()
        sp.mu.Lock()
        sp.currentUsage = 0
        sp.mu.Unlock()
}</span>

// TextStream represents a stream of text with metadata
type TextStream struct {
        Text       string
        PageNum    int
        Font       string
        FontSize   float64
        X, Y       float64
        W          float64
        Vertical   bool
        Confidence float64 // Confidence in the text recognition (0-1)
}

// ProcessTextStream processes text in a streaming fashion
func (sp *StreamProcessor) ProcessTextStream(reader *Reader, handler func(TextStream) error) error <span class="cov8" title="1">{
        totalPages := reader.NumPage()

        for pageNum := 1; pageNum &lt;= totalPages; pageNum++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sp.ctx.Done():<span class="cov0" title="0">
                        return sp.ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">page := reader.Page(pageNum)
                content := page.Content()

                for _, text := range content.Text </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-sp.ctx.Done():<span class="cov0" title="0">
                                return sp.ctx.Err()</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">memCost := estimateTextMemory(text)
                        if !sp.tryReserveMemory(memCost) </span><span class="cov0" title="0">{
                                return ErrMemoryLimitExceeded
                        }</span>

                        <span class="cov0" title="0">textStream := TextStream{
                                Text:       text.S,
                                PageNum:    pageNum,
                                Font:       text.Font,
                                FontSize:   text.FontSize,
                                X:          text.X,
                                Y:          text.Y,
                                W:          text.W,
                                Vertical:   text.Vertical,
                                Confidence: 1.0, // Default confidence
                        }

                        if err := handler(textStream); err != nil </span><span class="cov0" title="0">{
                                sp.releaseMemory(memCost)
                                return err
                        }</span>
                        <span class="cov0" title="0">sp.releaseMemory(memCost)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// TextBlockStream represents a stream of text blocks
type TextBlockStream struct {
        Block   *TextBlock
        PageNum int
        Type    BlockType
        Level   int
        Text    string
}

// ProcessTextBlockStream processes text blocks in a streaming fashion
func (sp *StreamProcessor) ProcessTextBlockStream(reader *Reader, handler func(TextBlockStream) error) error <span class="cov8" title="1">{
        totalPages := reader.NumPage()

        for pageNum := 1; pageNum &lt;= totalPages; pageNum++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sp.ctx.Done():<span class="cov0" title="0">
                        return sp.ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">page := reader.Page(pageNum)
                blocks, err := page.ClassifyTextBlocks()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, block := range blocks </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-sp.ctx.Done():<span class="cov0" title="0">
                                return sp.ctx.Err()</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">blockCopy := &amp;TextBlock{
                                Texts:       block.Content,
                                MinX:        block.Bounds.Min.X,
                                MaxX:        block.Bounds.Max.X,
                                MinY:        block.Bounds.Min.Y,
                                MaxY:        block.Bounds.Max.Y,
                                AvgFontSize: calculateAvgFontSize(block.Content),
                        }
                        blockStream := TextBlockStream{
                                Block:   blockCopy,
                                PageNum: pageNum,
                                Type:    block.Type,
                                Level:   block.Level,
                                Text:    block.Text,
                        }

                        memCost := estimateBlockMemory(blockCopy)
                        if !sp.tryReserveMemory(memCost) </span><span class="cov0" title="0">{
                                return ErrMemoryLimitExceeded
                        }</span>

                        <span class="cov0" title="0">if err := handler(blockStream); err != nil </span><span class="cov0" title="0">{
                                sp.releaseMemory(memCost)
                                return err
                        }</span>
                        <span class="cov0" title="0">sp.releaseMemory(memCost)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// calculateAvgFontSize calculates the average font size of a text slice
func calculateAvgFontSize(texts []Text) float64 <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">var total float64
        for _, t := range texts </span><span class="cov8" title="1">{
                total += t.FontSize
        }</span>
        <span class="cov8" title="1">return total / float64(len(texts))</span>
}

// PageStream represents a stream of pages
type PageStream struct {
        Page      Page
        PageNum   int
        HasText   bool
        TextCount int
}

// ProcessPageStream processes pages in a streaming fashion
func (sp *StreamProcessor) ProcessPageStream(reader *Reader, handler func(PageStream) error) error <span class="cov8" title="1">{
        totalPages := reader.NumPage()

        for pageNum := 1; pageNum &lt;= totalPages; pageNum++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sp.ctx.Done():<span class="cov0" title="0">
                        return sp.ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">page := reader.Page(pageNum)
                content := page.Content()

                pageStream := PageStream{
                        Page:      page,
                        PageNum:   pageNum,
                        HasText:   len(content.Text) &gt; 0,
                        TextCount: len(content.Text),
                }

                memCost := estimatePageMemory(len(content.Text))
                if !sp.tryReserveMemory(memCost) </span><span class="cov0" title="0">{
                        return ErrMemoryLimitExceeded
                }</span>

                <span class="cov0" title="0">if err := handler(pageStream); err != nil </span><span class="cov0" title="0">{
                        sp.releaseMemory(memCost)
                        return err
                }</span>
                <span class="cov0" title="0">sp.releaseMemory(memCost)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// MemoryEfficientExtractor provides memory-efficient extraction using streaming
type MemoryEfficientExtractor struct {
        processor *StreamProcessor
}

// NewMemoryEfficientExtractor creates a new memory-efficient extractor
func NewMemoryEfficientExtractor(chunkSize, bufferSize int, maxMemory int64) *MemoryEfficientExtractor <span class="cov8" title="1">{
        return &amp;MemoryEfficientExtractor{
                processor: NewStreamProcessor(chunkSize, bufferSize, maxMemory),
        }
}</span>

// ExtractTextStream extracts text in a memory-efficient streaming way
func (mee *MemoryEfficientExtractor) ExtractTextStream(reader *Reader) (&lt;-chan TextStream, &lt;-chan error) <span class="cov8" title="1">{
        textChan := make(chan TextStream, 10)
        errChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(textChan)
                defer close(errChan)

                err := mee.processor.ProcessTextStream(reader, func(ts TextStream) error </span><span class="cov0" title="0">{
                        select </span>{
                        case textChan &lt;- ts:<span class="cov0" title="0">
                                return nil</span>
                        case &lt;-mee.processor.ctx.Done():<span class="cov0" title="0">
                                return mee.processor.ctx.Err()</span>
                        }
                })

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                }</span> else<span class="cov8" title="1"> {
                        errChan &lt;- nil
                }</span>
        }()

        <span class="cov8" title="1">return textChan, errChan</span>
}

// ExtractTextToWriter extracts text directly to an io.Writer to minimize memory usage
func (mee *MemoryEfficientExtractor) ExtractTextToWriter(reader *Reader, writer io.Writer) (err error) <span class="cov8" title="1">{
        bufWriter := bufio.NewWriterSize(writer, mee.processor.bufferSize)

        chunkThreshold := mee.processor.chunkSize
        if chunkThreshold &lt;= 0 </span><span class="cov0" title="0">{
                chunkThreshold = mee.processor.bufferSize
        }</span>
        <span class="cov8" title="1">if chunkThreshold &lt;= 0 </span><span class="cov0" title="0">{
                chunkThreshold = 4096
        }</span>
        <span class="cov8" title="1">if mee.processor.maxMemory &gt; 0 &amp;&amp; int64(chunkThreshold) &gt; mee.processor.maxMemory </span><span class="cov0" title="0">{
                chunkThreshold = int(mee.processor.maxMemory)
        }</span>

        <span class="cov8" title="1">var chunkBuilder strings.Builder
        var chunkReserved int64

        growReservation := func() error </span><span class="cov0" title="0">{
                additional := int64(chunkBuilder.Len()) - chunkReserved
                if additional &lt;= 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if !mee.processor.tryReserveMemory(additional) </span><span class="cov0" title="0">{
                        return ErrMemoryLimitExceeded
                }</span>
                <span class="cov0" title="0">chunkReserved += additional
                return nil</span>
        }

        <span class="cov8" title="1">flushChunk := func() error </span><span class="cov8" title="1">{
                if chunkBuilder.Len() == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">if _, err := bufWriter.WriteString(chunkBuilder.String()); err != nil </span><span class="cov0" title="0">{
                        chunkBuilder.Reset()
                        if chunkReserved &gt; 0 </span><span class="cov0" title="0">{
                                mee.processor.releaseMemory(chunkReserved)
                                chunkReserved = 0
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">chunkBuilder.Reset()
                if chunkReserved &gt; 0 </span><span class="cov0" title="0">{
                        mee.processor.releaseMemory(chunkReserved)
                        chunkReserved = 0
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if flushErr := flushChunk(); err == nil </span><span class="cov8" title="1">{
                        err = flushErr
                }</span>
                <span class="cov8" title="1">if chunkReserved &gt; 0 </span><span class="cov0" title="0">{
                        mee.processor.releaseMemory(chunkReserved)
                        chunkReserved = 0
                }</span>
                <span class="cov8" title="1">if flushErr := bufWriter.Flush(); err == nil </span><span class="cov8" title="1">{
                        err = flushErr
                }</span> else<span class="cov0" title="0"> {
                        // Ensure buffer is flushed even if error is already set
                        bufWriter.Flush()
                }</span>
        }()

        <span class="cov8" title="1">totalPages := reader.NumPage()
        for pageNum := 1; pageNum &lt;= totalPages; pageNum++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-mee.processor.ctx.Done():<span class="cov0" title="0">
                        return mee.processor.ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">page := reader.Page(pageNum)
                content := page.Content()
                lines := groupTextsByLines(content.Text)

                for _, line := range lines </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-mee.processor.ctx.Done():<span class="cov0" title="0">
                                return mee.processor.ctx.Err()</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">lineText := buildLineText(line)
                        if lineText == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">chunkBuilder.WriteString(lineText)
                        chunkBuilder.WriteByte('\n')

                        if err := growReservation(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if chunkThreshold &gt; 0 &amp;&amp; chunkBuilder.Len() &gt;= chunkThreshold </span><span class="cov0" title="0">{
                                if err := flushChunk(); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// groupTextsByLines groups texts into lines based on Y position
func groupTextsByLines(texts []Text) [][]Text <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov8" title="1">{
                return [][]Text{}
        }</span>

        // Sort texts by Y position (top to bottom)
        <span class="cov8" title="1">sortedTexts := make([]Text, len(texts))
        copy(sortedTexts, texts)

        // Use a simple sorting algorithm - for very large arrays,
        // a more efficient algorithm may be needed
        for i := 0; i &lt; len(sortedTexts); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(sortedTexts); j++ </span><span class="cov8" title="1">{
                        if sortedTexts[i].Y &lt; sortedTexts[j].Y </span><span class="cov0" title="0">{
                                sortedTexts[i], sortedTexts[j] = sortedTexts[j], sortedTexts[i]
                        }</span>
                }
        }

        // Group by lines with tolerance
        <span class="cov8" title="1">const lineTolerance = 2.0
        var lines [][]Text
        var currentLine []Text
        var currentY float64

        for i, t := range sortedTexts </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        currentLine = []Text{t}
                        currentY = t.Y
                        continue</span>
                }

                <span class="cov8" title="1">if abs(t.Y-currentY) &lt;= lineTolerance </span><span class="cov8" title="1">{
                        currentLine = append(currentLine, t)
                }</span> else<span class="cov8" title="1"> {
                        if len(currentLine) &gt; 0 </span><span class="cov8" title="1">{
                                lines = append(lines, currentLine)
                        }</span>
                        <span class="cov8" title="1">currentLine = []Text{t}
                        currentY = t.Y</span>
                }
        }
        <span class="cov8" title="1">if len(currentLine) &gt; 0 </span><span class="cov8" title="1">{
                lines = append(lines, currentLine)
        }</span>

        <span class="cov8" title="1">return lines</span>
}

// buildLineText constructs a line of text from multiple text elements
func buildLineText(texts []Text) string <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Sort texts by X position (left to right) within the line
        <span class="cov8" title="1">sortedTexts := make([]Text, len(texts))
        copy(sortedTexts, texts)

        for i := 0; i &lt; len(sortedTexts); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(sortedTexts); j++ </span><span class="cov8" title="1">{
                        if sortedTexts[i].X &gt; sortedTexts[j].X </span><span class="cov0" title="0">{
                                sortedTexts[i], sortedTexts[j] = sortedTexts[j], sortedTexts[i]
                        }</span>
                }
        }

        // P0: strings.Builder
        <span class="cov8" title="1">builder := GetBuilder()
        defer PutBuilder(builder)

        // 
        totalLen := 0
        for _, t := range sortedTexts </span><span class="cov8" title="1">{
                totalLen += len(t.S)
        }</span>
        <span class="cov8" title="1">builder.Grow(totalLen + len(sortedTexts))

        var lastX float64
        for i, t := range sortedTexts </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        // Add space if there's a significant gap
                        gap := t.X - lastX
                        if gap &gt; 5.0 </span><span class="cov8" title="1">{ // Threshold for adding space
                                builder.WriteByte(' ')
                        }</span>
                }
                <span class="cov8" title="1">builder.WriteString(t.S)
                lastX = t.X + t.W</span>
        }

        <span class="cov8" title="1">return builder.String()</span>
}

// abs returns the absolute value of a float64
func abs(x float64) float64 <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov8" title="1">{
                return -x
        }</span>
        <span class="cov8" title="1">return x</span>
}

// StreamingTextClassifier classifies text in a streaming fashion to minimize memory usage
type StreamingTextClassifier struct {
        processor *StreamProcessor
}

// NewStreamingTextClassifier creates a new streaming text classifier
func NewStreamingTextClassifier(chunkSize, bufferSize int, maxMemory int64) *StreamingTextClassifier <span class="cov8" title="1">{
        return &amp;StreamingTextClassifier{
                processor: NewStreamProcessor(chunkSize, bufferSize, maxMemory),
        }
}</span>

// ClassifyTextStream classifies text in a streaming way
func (stc *StreamingTextClassifier) ClassifyTextStream(reader *Reader) (&lt;-chan ClassifiedBlock, &lt;-chan error) <span class="cov8" title="1">{
        blockChan := make(chan ClassifiedBlock, 5) // Smaller buffer for memory efficiency
        errChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(blockChan)
                defer close(errChan)

                err := stc.processor.ProcessTextBlockStream(reader, func(tbs TextBlockStream) error </span><span class="cov0" title="0">{
                        select </span>{
                        case blockChan &lt;- ClassifiedBlock{
                                Type:    tbs.Type,
                                Level:   tbs.Level,
                                Content: tbs.Block.Texts,
                                Bounds:  tbs.Block.Bounds(),
                                Text:    tbs.Text,
                        }:<span class="cov0" title="0">
                                return nil</span>
                        case &lt;-stc.processor.ctx.Done():<span class="cov0" title="0">
                                return stc.processor.ctx.Err()</span>
                        }
                })

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                }</span> else<span class="cov8" title="1"> {
                        errChan &lt;- nil
                }</span>
        }()

        <span class="cov8" title="1">return blockChan, errChan</span>
}

// ProcessLargePDF handles very large PDFs with streaming
func ProcessLargePDF(reader *Reader, chunkSize, bufferSize int, maxMemory int64,
        handler func(PageStream) error) error <span class="cov8" title="1">{

        extractor := NewMemoryEfficientExtractor(chunkSize, bufferSize, maxMemory)
        defer extractor.processor.Close()

        return extractor.processor.ProcessPageStream(reader, handler)
}</span>

// StreamingMetadataExtractor extracts metadata in a streaming fashion
type StreamingMetadataExtractor struct {
        processor *StreamProcessor
}

// NewStreamingMetadataExtractor creates a new streaming metadata extractor
func NewStreamingMetadataExtractor(chunkSize, bufferSize int, maxMemory int64) *StreamingMetadataExtractor <span class="cov8" title="1">{
        return &amp;StreamingMetadataExtractor{
                processor: NewStreamProcessor(chunkSize, bufferSize, maxMemory),
        }
}</span>

// ExtractMetadataStream extracts metadata in a streaming way
func (sme *StreamingMetadataExtractor) ExtractMetadataStream(reader *Reader) (&lt;-chan Metadata, &lt;-chan error) <span class="cov8" title="1">{
        metaChan := make(chan Metadata, 1)
        errChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(metaChan)
                defer close(errChan)

                metadata, err := reader.GetMetadata()
                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov8" title="1">select </span>{
                case metaChan &lt;- metadata:<span class="cov8" title="1"></span>
                case &lt;-sme.processor.ctx.Done():<span class="cov0" title="0">
                        errChan &lt;- sme.processor.ctx.Err()</span>
                }

                <span class="cov8" title="1">errChan &lt;- nil</span>
        }()

        <span class="cov8" title="1">return metaChan, errChan</span>
}

func estimateTextMemory(text Text) int64 <span class="cov0" title="0">{
        return int64(len(text.S)) + 128
}</span>

func estimateBlockMemory(block *TextBlock) int64 <span class="cov0" title="0">{
        if block == nil </span><span class="cov0" title="0">{
                return 128
        }</span>
        <span class="cov0" title="0">size := int64(128)
        for _, t := range block.Texts </span><span class="cov0" title="0">{
                size += int64(len(t.S)) + 64
        }</span>
        <span class="cov0" title="0">return size</span>
}

func estimatePageMemory(textCount int) int64 <span class="cov0" title="0">{
        if textCount &lt;= 0 </span><span class="cov0" title="0">{
                return 64
        }</span>
        <span class="cov0" title="0">return int64(textCount)*128 + 64</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "math"
        "unicode"
        "unicode/utf16"
)

const noRune = unicode.ReplacementChar

func isPDFDocEncoded(s string) bool <span class="cov0" title="0">{
        if isUTF16(s) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                if pdfDocEncoding[s[i]] == noRune </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func pdfDocDecode(s string) string <span class="cov0" title="0">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                if s[i] &gt;= 0x80 || pdfDocEncoding[s[i]] != rune(s[i]) </span><span class="cov0" title="0">{
                        goto Decode</span>
                }
        }
        <span class="cov0" title="0">return s

</span>Decode:
        <span class="cov0" title="0">r := make([]rune, len(s))
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                r[i] = pdfDocEncoding[s[i]]
        }</span>
        <span class="cov0" title="0">return string(r)</span>
}

func isUTF16(s string) bool <span class="cov0" title="0">{
        return len(s) &gt;= 2 &amp;&amp; s[0] == 0xfe &amp;&amp; s[1] == 0xff &amp;&amp; len(s)%2 == 0
}</span>

func utf16Decode(s string) string <span class="cov0" title="0">{
        var u []uint16
        for i := 0; i &lt; len(s); i += 2 </span><span class="cov0" title="0">{
                u = append(u, uint16(s[i])&lt;&lt;8|uint16(s[i+1]))
        }</span>
        <span class="cov0" title="0">return string(utf16.Decode(u))</span>
}

// See PDF 32000-1:2008, Table D.2
var pdfDocEncoding = [256]rune{
        noRune, noRune, noRune, noRune, noRune, noRune, noRune, noRune,
        noRune, 0x0009, 0x000a, noRune, noRune, 0x000d, noRune, noRune,
        noRune, noRune, noRune, noRune, noRune, noRune, noRune, noRune,
        0x02d8, 0x02c7, 0x02c6, 0x02d9, 0x02dd, 0x02db, 0x02da, 0x02dc,
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
        0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
        0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
        0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
        0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
        0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
        0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, noRune,
        0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x0192, 0x2044,
        0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018,
        0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x0141, 0x0152, 0x0160,
        0x0178, 0x017d, 0x0131, 0x0142, 0x0153, 0x0161, 0x017e, noRune,
        0x20ac, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
        0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, noRune, 0x00ae, 0x00af,
        0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
        0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
        0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
        0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
        0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
        0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
        0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
        0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
        0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
        0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,
}

var winAnsiEncoding = [256]rune{
        0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
        0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
        0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
        0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
        0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
        0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
        0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
        0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
        0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
        0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
        0x20ac, noRune, 0x201a, 0x0192, 0x201e, 0x2026, 0x2020, 0x2021,
        0x02c6, 0x2030, 0x0160, 0x2039, 0x0152, noRune, 0x017d, noRune,
        noRune, 0x2018, 0x2019, 0x201c, 0x201d, 0x2022, 0x2013, 0x2014,
        0x02dc, 0x2122, 0x0161, 0x203a, 0x0153, noRune, 0x017e, 0x0178,
        0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
        0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
        0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
        0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
        0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
        0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
        0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
        0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
        0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
        0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
        0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
        0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,
}

var macRomanEncoding = [256]rune{
        0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
        0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
        0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
        0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
        0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
        0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
        0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
        0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
        0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
        0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
        0x00c4, 0x00c5, 0x00c7, 0x00c9, 0x00d1, 0x00d6, 0x00dc, 0x00e1,
        0x00e0, 0x00e2, 0x00e4, 0x00e3, 0x00e5, 0x00e7, 0x00e9, 0x00e8,
        0x00ea, 0x00eb, 0x00ed, 0x00ec, 0x00ee, 0x00ef, 0x00f1, 0x00f3,
        0x00f2, 0x00f4, 0x00f6, 0x00f5, 0x00fa, 0x00f9, 0x00fb, 0x00fc,
        0x2020, 0x00b0, 0x00a2, 0x00a3, 0x00a7, 0x2022, 0x00b6, 0x00df,
        0x00ae, 0x00a9, 0x2122, 0x00b4, 0x00a8, 0x2260, 0x00c6, 0x00d8,
        0x221e, 0x00b1, 0x2264, 0x2265, 0x00a5, 0x00b5, 0x2202, 0x2211,
        0x220f, 0x03c0, 0x222b, 0x00aa, 0x00ba, 0x03a9, 0x00e6, 0x00f8,
        0x00bf, 0x00a1, 0x00ac, 0x221a, 0x0192, 0x2248, 0x2206, 0x00ab,
        0x00bb, 0x2026, 0x00a0, 0x00c0, 0x00c3, 0x00d5, 0x0152, 0x0153,
        0x2013, 0x2014, 0x201c, 0x201d, 0x2018, 0x2019, 0x00f7, 0x25ca,
        0x00ff, 0x0178, 0x2044, 0x20ac, 0x2039, 0x203a, 0xfb01, 0xfb02,
        0x2021, 0x00b7, 0x201a, 0x201e, 0x2030, 0x00c2, 0x00ca, 0x00c1,
        0x00cb, 0x00c8, 0x00cd, 0x00ce, 0x00cf, 0x00cc, 0x00d3, 0x00d4,
        0xf8ff, 0x00d2, 0x00da, 0x00db, 0x00d9, 0x0131, 0x02c6, 0x02dc,
        0x00af, 0x02d8, 0x02d9, 0x02da, 0x00b8, 0x02dd, 0x02db, 0x02c7,
}

type identityCMap struct {
        width int
}

func (m *identityCMap) Decode(raw string) (text string) <span class="cov8" title="1">{
        if m.width &lt;= 0 </span><span class="cov0" title="0">{
                return raw
        }</span>
        <span class="cov8" title="1">b := []byte(raw)
        r := make([]rune, 0, len(b)/m.width+1)
        for len(b) &gt;= m.width </span><span class="cov8" title="1">{
                val := 0
                for i := 0; i &lt; m.width; i++ </span><span class="cov8" title="1">{
                        val = (val &lt;&lt; 8) | int(b[i])
                }</span>
                <span class="cov8" title="1">r = append(r, rune(val))
                b = b[m.width:]</span>
        }
        <span class="cov8" title="1">return string(r)</span>
}

var predefinedCMaps = map[string]TextEncoding{
        "Identity-H": &amp;identityCMap{width: 2},
        "Identity-V": &amp;identityCMap{width: 2},
}

func builtinCMapEncoding(name string) TextEncoding <span class="cov0" title="0">{
        if enc, ok := predefinedCMaps[name]; ok </span><span class="cov0" title="0">{
                return enc
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// isSameSentence checks if the current text segment likely belongs to the same sentence
// as the last text segment based on font, size, vertical position, and lack of
// sentence-ending punctuation in the last segment.
func IsSameSentence(last, current Text) bool <span class="cov0" title="0">{
        return last.Font == current.Font &amp;&amp;
                math.Abs(last.FontSize-current.FontSize) &lt; 0.1 &amp;&amp;
                math.Abs(last.Y-current.Y) &lt; 5 &amp;&amp;
                last.S != ""
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "math"
        "regexp"
        "strings"
        "unicode"
)

// BlockType represents the semantic type of a text block
type BlockType int

const (
        BlockUnknown   BlockType = iota
        BlockTitle               // Title or heading
        BlockParagraph           // Regular paragraph
        BlockList                // List item (numbered or bulleted)
        BlockCaption             // Image or table caption
        BlockFootnote            // Footnote or endnote
        BlockHeader              // Page header
        BlockFooter              // Page footer
)

// String returns the string representation of BlockType
func (bt BlockType) String() string <span class="cov8" title="1">{
        switch bt </span>{
        case BlockTitle:<span class="cov0" title="0">
                return "Title"</span>
        case BlockParagraph:<span class="cov8" title="1">
                return "Paragraph"</span>
        case BlockList:<span class="cov8" title="1">
                return "List"</span>
        case BlockCaption:<span class="cov8" title="1">
                return "Caption"</span>
        case BlockFootnote:<span class="cov0" title="0">
                return "Footnote"</span>
        case BlockHeader:<span class="cov8" title="1">
                return "Header"</span>
        case BlockFooter:<span class="cov8" title="1">
                return "Footer"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// ClassifiedBlock represents a classified block of text with semantic information
type ClassifiedBlock struct {
        Type    BlockType // Semantic type of the block
        Level   int       // Hierarchy level (for titles: 1=h1, 2=h2, etc.)
        Content []Text    // Text runs in this block
        Bounds  Rect      // Bounding box
        Text    string    // Concatenated text content
}

// TextClassifier classifies text runs into semantic blocks
type TextClassifier struct {
        texts          []Text
        avgFontSize    float64
        maxFontSize    float64
        minFontSize    float64
        pageHeight     float64
        pageWidth      float64
        listPattern    *regexp.Regexp
        captionPattern *regexp.Regexp
        spatialIndex   SpatialIndexInterface // Spatial index for context-aware classification
}

// NewTextClassifier creates a new text classifier
func NewTextClassifier(texts []Text, pageWidth, pageHeight float64) *TextClassifier <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov8" title="1">{
                return &amp;TextClassifier{
                        texts:          texts,
                        pageWidth:      pageWidth,
                        pageHeight:     pageHeight,
                        listPattern:    regexp.MustCompile(`^(\d+\.|[\-\*]|\([a-z]\)|\([0-9]+\))\s`),
                        captionPattern: regexp.MustCompile(`^(Figure|Table|Fig\.|Tab\.)\s+\d+`),
                }
        }</span>

        <span class="cov8" title="1">tc := &amp;TextClassifier{
                texts:          texts,
                pageWidth:      pageWidth,
                pageHeight:     pageHeight,
                listPattern:    regexp.MustCompile(`^(\d+\.|[\-\*]|\([a-z]\)|\([0-9]+\))\s`),
                captionPattern: regexp.MustCompile(`^(Figure|Table|Fig\.|Tab\.)\s+\d+`),
        }

        // Calculate font statistics
        var totalSize float64
        tc.maxFontSize = 0
        tc.minFontSize = math.MaxFloat64

        for _, t := range texts </span><span class="cov8" title="1">{
                totalSize += t.FontSize
                if t.FontSize &gt; tc.maxFontSize </span><span class="cov8" title="1">{
                        tc.maxFontSize = t.FontSize
                }</span>
                <span class="cov8" title="1">if t.FontSize &lt; tc.minFontSize </span><span class="cov8" title="1">{
                        tc.minFontSize = t.FontSize
                }</span>
        }

        <span class="cov8" title="1">tc.avgFontSize = totalSize / float64(len(texts))

        // Create spatial index for context-aware classification
        tc.spatialIndex = NewSpatialIndexInterface(texts)

        return tc</span>
}

// ClassifyBlocks classifies text runs into semantic blocks
func (tc *TextClassifier) ClassifyBlocks() []ClassifiedBlock <span class="cov8" title="1">{
        if len(tc.texts) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // First, cluster texts into logical blocks using smart ordering
        <span class="cov8" title="1">clusters := clusterTextBlocks(tc.texts)

        // Then classify each cluster
        var blocks []ClassifiedBlock
        for _, cluster := range clusters </span><span class="cov8" title="1">{
                block := tc.classifyCluster(cluster)
                blocks = append(blocks, block)
        }</span>

        <span class="cov8" title="1">return blocks</span>
}

// classifyCluster determines the type of a text cluster
func (tc *TextClassifier) classifyCluster(cluster *TextBlock) ClassifiedBlock <span class="cov8" title="1">{
        // Concatenate text content
        var textContent strings.Builder
        for _, t := range cluster.Texts </span><span class="cov8" title="1">{
                textContent.WriteString(t.S)
        }</span>
        <span class="cov8" title="1">text := strings.TrimSpace(textContent.String())

        center := cluster.Center()
        block := ClassifiedBlock{
                Content: cluster.Texts,
                Bounds:  cluster.Bounds(),
                Text:    text,
                Type:    BlockUnknown,
                Level:   0,
        }

        if text == "" </span><span class="cov0" title="0">{
                return block
        }</span>

        // Get context from nearby text
        <span class="cov8" title="1">context := tc.getContext(cluster)

        // Check for header/footer based on position and context
        if tc.isHeaderPosition(center.Y) </span><span class="cov8" title="1">{
                block.Type = BlockHeader
                return block
        }</span>
        <span class="cov8" title="1">if tc.isFooterPosition(center.Y) </span><span class="cov8" title="1">{
                block.Type = BlockFooter
                return block
        }</span>

        // Check for caption with context awareness
        <span class="cov8" title="1">if tc.captionPattern.MatchString(text) || tc.isCaptionWithContext(text, context) </span><span class="cov8" title="1">{
                block.Type = BlockCaption
                return block
        }</span>

        // Check for list item with context awareness
        <span class="cov8" title="1">if tc.listPattern.MatchString(text) || tc.isListWithContext(text, context) </span><span class="cov8" title="1">{
                block.Type = BlockList
                return block
        }</span>

        // Check for footnote with context awareness (small font at bottom)
        <span class="cov8" title="1">if tc.isFootnote(cluster, center.Y) || tc.isFootnoteWithContext(cluster, center.Y, context) </span><span class="cov0" title="0">{
                block.Type = BlockFootnote
                return block
        }</span>

        // Check for title with context awareness
        <span class="cov8" title="1">if tc.isTitle(cluster) || tc.isTitleWithContext(cluster, context) </span><span class="cov8" title="1">{
                block.Type = BlockTitle
                block.Level = tc.getTitleLevel(cluster.AvgFontSize)
                return block
        }</span>

        // Use context to determine paragraph vs other types
        <span class="cov8" title="1">if tc.isParagraphWithContext(context) </span><span class="cov8" title="1">{
                block.Type = BlockParagraph
                return block
        }</span>

        // Default to paragraph
        <span class="cov8" title="1">block.Type = BlockParagraph
        return block</span>
}

// getContext returns text context from nearby elements
func (tc *TextClassifier) getContext(cluster *TextBlock) []Text <span class="cov8" title="1">{
        if tc.spatialIndex == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get nearby text elements within a reasonable distance
        <span class="cov8" title="1">bounds := cluster.Bounds()
        margin := cluster.AvgFontSize * 3.0 // Consider elements within 3x font size distance
        nearbyBounds := Rect{
                Min: Point{X: bounds.Min.X - margin, Y: bounds.Min.Y - margin},
                Max: Point{X: bounds.Max.X + margin, Y: bounds.Max.Y + margin},
        }

        return tc.spatialIndex.Query(nearbyBounds)</span>
}

// isCaptionWithContext checks if the text is a caption based on nearby context
func (tc *TextClassifier) isCaptionWithContext(text string, context []Text) bool <span class="cov8" title="1">{
        if len(context) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if there's an image or table nearby
        <span class="cov8" title="1">for _, nearbyText := range context </span><span class="cov8" title="1">{
                if tc.isNearImageOrTable(nearbyText) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isListWithContext checks if the text is a list item with contextual clues
func (tc *TextClassifier) isListWithContext(text string, context []Text) bool <span class="cov8" title="1">{
        for _, nearbyText := range context </span><span class="cov8" title="1">{
                if tc.listPattern.MatchString(nearbyText.S) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isFootnoteWithContext checks if the text is a footnote based on context
func (tc *TextClassifier) isFootnoteWithContext(cluster *TextBlock, centerY float64, context []Text) bool <span class="cov8" title="1">{
        // Check if there are footnote references nearby in the main content
        for _, nearbyText := range context </span><span class="cov8" title="1">{
                // Look for footnote reference patterns like [1], , etc.
                if tc.isFootnoteReference(nearbyText.S) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return cluster.AvgFontSize &lt; tc.avgFontSize*0.8 &amp;&amp; centerY &lt; tc.pageHeight*0.3</span>
}

// isTitleWithContext checks if the text is a title based on context
func (tc *TextClassifier) isTitleWithContext(cluster *TextBlock, context []Text) bool <span class="cov8" title="1">{
        // Check font styles: bold or larger size often indicates titles
        hasBold := false
        for _, t := range cluster.Texts </span><span class="cov8" title="1">{
                if t.Bold </span><span class="cov0" title="0">{
                        hasBold = true
                        break</span>
                }
        }

        // Check if significantly larger than surrounding text
        <span class="cov8" title="1">avgContextSize := tc.getAverageFontSize(context)
        if cluster.AvgFontSize &gt; avgContextSize*1.2 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if following text is more likely to be paragraph content
        <span class="cov8" title="1">for _, nearbyText := range context </span><span class="cov8" title="1">{
                center := Point{X: (nearbyText.X + nearbyText.X + nearbyText.W) / 2, Y: nearbyText.Y}

                // If nearby text is below this cluster and likely a paragraph, this might be a title
                if center.Y &lt; cluster.Center().Y &amp;&amp; tc.isLikelyParagraph(nearbyText) </span><span class="cov8" title="1">{
                        if cluster.AvgFontSize &gt; tc.avgFontSize || hasBold </span><span class="cov0" title="0">{ // Larger font or bold indicates possible title
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// isParagraphWithContext uses context to determine if this should be classified as a paragraph
func (tc *TextClassifier) isParagraphWithContext(context []Text) bool <span class="cov8" title="1">{
        // If surrounded by other paragraph content, likely a paragraph
        paragraphCount := 0
        for _, nearbyText := range context </span><span class="cov8" title="1">{
                if tc.isLikelyParagraph(nearbyText) </span><span class="cov8" title="1">{
                        paragraphCount++
                }</span>
        }
        <span class="cov8" title="1">return paragraphCount &gt; len(context)/2</span>
}

// isNearImageOrTable checks if text is near an image or table region
func (tc *TextClassifier) isNearImageOrTable(text Text) bool <span class="cov8" title="1">{
        // This would be enhanced with actual image/table detection
        // For now, using heuristics based on common patterns
        textLower := strings.ToLower(text.S)
        return strings.Contains(textLower, "figure") || strings.Contains(textLower, "table") || strings.Contains(textLower, "fig.")
}</span>

// isFootnoteReference checks if text looks like a footnote reference
func (tc *TextClassifier) isFootnoteReference(text string) bool <span class="cov8" title="1">{
        // Check for patterns like [1], , or superscript numbers
        return regexp.MustCompile(`\[\d+\]|[\x{00B9}\x{00B2}\x{00B3}\x{2070}-\x{2079}\x{2080}-\x{2089}]`).MatchString(text)
}</span>

// isLikelyParagraph checks if text is likely a paragraph based on content
func (tc *TextClassifier) isLikelyParagraph(text Text) bool <span class="cov8" title="1">{
        words := strings.Fields(text.S)
        // A paragraph typically has more than 3 words
        return len(words) &gt;= 3
}</span>

// isHeaderPosition checks if Y coordinate is in header region
func (tc *TextClassifier) isHeaderPosition(y float64) bool <span class="cov8" title="1">{
        if tc.pageHeight == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        // Top 10% of page
        <span class="cov8" title="1">return y &gt; tc.pageHeight*0.9</span>
}

// isFooterPosition checks if Y coordinate is in footer region
func (tc *TextClassifier) isFooterPosition(y float64) bool <span class="cov8" title="1">{
        if tc.pageHeight == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        // Bottom 10% of page
        <span class="cov8" title="1">return y &lt; tc.pageHeight*0.1</span>
}

// isFootnote checks if cluster is a footnote
func (tc *TextClassifier) isFootnote(cluster *TextBlock, centerY float64) bool <span class="cov8" title="1">{
        // Small font size and in lower part of page
        return cluster.AvgFontSize &lt; tc.avgFontSize*0.8 &amp;&amp;
                centerY &lt; tc.pageHeight*0.3
}</span>

// isTitle checks if cluster is likely a title
func (tc *TextClassifier) isTitle(cluster *TextBlock) bool <span class="cov8" title="1">{
        // Check font styles: bold text is often a title
        hasBold := false
        for _, t := range cluster.Texts </span><span class="cov8" title="1">{
                if t.Bold </span><span class="cov0" title="0">{
                        hasBold = true
                        break</span>
                }
        }

        // Significantly larger than average font or bold
        <span class="cov8" title="1">if cluster.AvgFontSize &lt;= tc.avgFontSize*1.2 &amp;&amp; !hasBold </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if text looks like a title (short, capitalized)
        <span class="cov8" title="1">text := strings.TrimSpace(cluster.Texts[0].S)
        if len(text) &gt; 100 </span><span class="cov0" title="0">{
                return false // Too long to be a title
        }</span>

        // Check for title-like patterns
        <span class="cov8" title="1">words := strings.Fields(text)
        if len(words) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Count capitalized words
        <span class="cov8" title="1">capitalizedCount := 0
        for _, word := range words </span><span class="cov8" title="1">{
                if len(word) &gt; 0 &amp;&amp; unicode.IsUpper(rune(word[0])) </span><span class="cov8" title="1">{
                        capitalizedCount++
                }</span>
        }

        // Most words should be capitalized for a title, or it's bold
        <span class="cov8" title="1">return float64(capitalizedCount)/float64(len(words)) &gt; 0.6 || hasBold</span>
}

// getTitleLevel determines the hierarchy level based on font size
func (tc *TextClassifier) getTitleLevel(fontSize float64) int <span class="cov8" title="1">{
        // Divide font size range into levels
        if tc.maxFontSize == tc.minFontSize </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov8" title="1">ratio := (fontSize - tc.avgFontSize) / (tc.maxFontSize - tc.avgFontSize)

        if ratio &gt; 0.8 </span><span class="cov8" title="1">{
                return 1 // h1
        }</span> else<span class="cov0" title="0"> if ratio &gt; 0.6 </span><span class="cov0" title="0">{
                return 2 // h2
        }</span> else<span class="cov0" title="0"> if ratio &gt; 0.4 </span><span class="cov0" title="0">{
                return 3 // h3
        }</span> else<span class="cov0" title="0"> if ratio &gt; 0.2 </span><span class="cov0" title="0">{
                return 4 // h4
        }</span> else<span class="cov0" title="0"> {
                return 5 // h5
        }</span>
}

// ClassifyTextBlocks is a convenience function that creates a classifier and runs classification
func (p Page) ClassifyTextBlocks() ([]ClassifiedBlock, error) <span class="cov0" title="0">{
        content := p.Content()
        if len(content.Text) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Get page dimensions
        <span class="cov0" title="0">mediaBox := p.V.Key("MediaBox")
        var pageWidth, pageHeight float64
        if mediaBox.Kind() == Array &amp;&amp; mediaBox.Len() &gt;= 4 </span><span class="cov0" title="0">{
                pageWidth = mediaBox.Index(2).Float64()
                pageHeight = mediaBox.Index(3).Float64()
        }</span> else<span class="cov0" title="0"> {
                // Default to letter size if no MediaBox
                pageWidth = 612.0  // 8.5 inches * 72 dpi
                pageHeight = 792.0 // 11 inches * 72 dpi
        }</span>

        <span class="cov0" title="0">classifier := NewTextClassifier(content.Text, pageWidth, pageHeight)
        return classifier.ClassifyBlocks(), nil</span>
}

// GetTextByType returns all text blocks of a specific type
func GetTextByType(blocks []ClassifiedBlock, blockType BlockType) []ClassifiedBlock <span class="cov8" title="1">{
        var result []ClassifiedBlock
        for _, block := range blocks </span><span class="cov8" title="1">{
                if block.Type == blockType </span><span class="cov8" title="1">{
                        result = append(result, block)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetTitles returns all title blocks, optionally filtered by level
func GetTitles(blocks []ClassifiedBlock, level int) []ClassifiedBlock <span class="cov8" title="1">{
        var result []ClassifiedBlock
        for _, block := range blocks </span><span class="cov8" title="1">{
                if block.Type == BlockTitle </span><span class="cov8" title="1">{
                        if level == 0 || block.Level == level </span><span class="cov8" title="1">{
                                result = append(result, block)
                        }</span>
                }
        }
        <span class="cov8" title="1">return result</span>
}

// getAverageFontSize calculates average font size of a list of texts
func (tc *TextClassifier) getAverageFontSize(texts []Text) float64 <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return tc.avgFontSize
        }</span>
        <span class="cov8" title="1">var total float64
        for _, t := range texts </span><span class="cov8" title="1">{
                total += t.FontSize
        }</span>
        <span class="cov8" title="1">return total / float64(len(texts))</span>
}

// isNearTitleIndicator checks if nearby text suggests this is a title
func (tc *TextClassifier) isNearTitleIndicator(text Text) bool <span class="cov0" title="0">{
        // Simple heuristic: short text above or below
        return len(text.S) &lt; 50 &amp;&amp; (text.Y &gt; tc.pageHeight*0.8 || text.Y &lt; tc.pageHeight*0.2)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "math"
        "sort"
        "strings"
)

// TextBlock represents a coherent block of text (like a paragraph or column)
type TextBlock struct {
        Texts       []Text
        MinX        float64
        MaxX        float64
        MinY        float64
        MaxY        float64
        AvgFontSize float64
}

// Bounds returns the bounding box of the text block
func (tb *TextBlock) Bounds() Rect <span class="cov8" title="1">{
        return Rect{
                Min: Point{X: tb.MinX, Y: tb.MinY},
                Max: Point{X: tb.MaxX, Y: tb.MaxY},
        }
}</span>

// Center returns the center point of the text block
func (tb *TextBlock) Center() Point <span class="cov8" title="1">{
        return Point{
                X: (tb.MinX + tb.MaxX) / 2,
                Y: (tb.MinY + tb.MaxY) / 2,
        }
}</span>

// Width returns the width of the text block
func (tb *TextBlock) Width() float64 <span class="cov8" title="1">{
        return tb.MaxX - tb.MinX
}</span>

// Height returns the height of the text block
func (tb *TextBlock) Height() float64 <span class="cov8" title="1">{
        return tb.MaxY - tb.MinY
}</span>

// smartTextOrdering implements improved text ordering using clustering
// to handle multi-column layouts and complex reading orders
func smartTextOrdering(texts []Text) []Text <span class="cov0" title="0">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return texts
        }</span>

        // 1. Cluster texts into blocks
        <span class="cov0" title="0">blocks := clusterTextBlocks(texts)

        // 2. Detect reading order (left-to-right columns, etc.)
        orderedBlocks := detectReadingOrder(blocks)

        // 3. Flatten blocks back to texts
        var result []Text
        for _, block := range orderedBlocks </span><span class="cov0" title="0">{
                // Sort within each block
                sortedTexts := sortWithinBlock(block.Texts)
                result = append(result, sortedTexts...)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// clusterTextBlocks groups nearby texts into coherent blocks
// using a simplified distance-based clustering approach
// P1: KD-TreeO(n)O(n log n)
func clusterTextBlocks(texts []Text) []*TextBlock <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 200
        <span class="cov8" title="1">if len(texts) &lt; 200 </span><span class="cov8" title="1">{
                return clusterTextBlocksSimple(texts)
        }</span>

        // KD-Tree
        <span class="cov0" title="0">return ClusterTextBlocksOptimized(texts)</span>
}

// clusterTextBlocksSimple 
func clusterTextBlocksSimple(texts []Text) []*TextBlock <span class="cov8" title="1">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Calculate average font size for distance threshold
        <span class="cov8" title="1">var totalFontSize float64
        for _, t := range texts </span><span class="cov8" title="1">{
                totalFontSize += t.FontSize
        }</span>
        <span class="cov8" title="1">avgFontSize := totalFontSize / float64(len(texts))

        // Distance threshold: texts within this distance are likely in same block
        distThreshold := avgFontSize * 2.0

        // Start with each text as its own cluster
        clusters := make([]*TextBlock, len(texts))
        for i, t := range texts </span><span class="cov8" title="1">{
                clusters[i] = &amp;TextBlock{
                        Texts:       []Text{t},
                        MinX:        t.X,
                        MaxX:        t.X + t.W,
                        MinY:        t.Y,
                        MaxY:        t.Y + t.FontSize,
                        AvgFontSize: t.FontSize,
                }
        }</span>

        // Merge nearby clusters iteratively
        <span class="cov8" title="1">merged := true
        for merged </span><span class="cov8" title="1">{
                merged = false
                for i := 0; i &lt; len(clusters); i++ </span><span class="cov8" title="1">{
                        for j := i + 1; j &lt; len(clusters); j++ </span><span class="cov8" title="1">{
                                if shouldMergeClusters(clusters[i], clusters[j], distThreshold) </span><span class="cov0" title="0">{
                                        clusters[i] = mergeClusters(clusters[i], clusters[j])
                                        clusters = append(clusters[:j], clusters[j+1:]...)
                                        merged = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if merged </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return clusters</span>
}

// shouldMergeClusters determines if two text blocks should be merged
func shouldMergeClusters(b1, b2 *TextBlock, threshold float64) bool <span class="cov8" title="1">{
        // Enhanced logic for asymmetric layouts and text-image mixing

        // Check vertical proximity (same line or nearby lines)
        verticalOverlap := math.Min(b1.MaxY, b2.MaxY) - math.Max(b1.MinY, b2.MinY)
        if verticalOverlap &lt; 0 </span><span class="cov8" title="1">{
                verticalOverlap = 0
        }</span>

        // If there's significant vertical overlap, check horizontal distance
        <span class="cov8" title="1">if verticalOverlap &gt; b1.AvgFontSize*0.3 || verticalOverlap &gt; b2.AvgFontSize*0.3 </span><span class="cov0" title="0">{
                horizontalGap := math.Max(b1.MinX, b2.MinX) - math.Min(b1.MaxX, b2.MaxX)
                if horizontalGap &lt; 0 </span><span class="cov0" title="0">{
                        horizontalGap = 0
                }</span>
                <span class="cov0" title="0">if horizontalGap &lt; threshold </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check if vertically stacked and horizontally aligned (same column)
        <span class="cov8" title="1">horizontalOverlap := math.Min(b1.MaxX, b2.MaxX) - math.Max(b1.MinX, b2.MinX)
        if horizontalOverlap &gt; 0 </span><span class="cov0" title="0">{
                overlapRatio := horizontalOverlap / math.Min(b1.Width(), b2.Width())
                if overlapRatio &gt; 0.6 </span><span class="cov0" title="0">{
                        verticalGap := math.Max(b1.MinY, b2.MinY) - math.Min(b1.MaxY, b2.MaxY)
                        if verticalGap &lt; 0 </span><span class="cov0" title="0">{
                                verticalGap = 0
                        }</span>
                        <span class="cov0" title="0">if verticalGap &lt; threshold*1.5 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        // For asymmetric layouts: check if blocks are in different regions
        <span class="cov8" title="1">if isAsymmetricLayout(b1, b2) </span><span class="cov8" title="1">{
                return false // Don't merge across asymmetric boundaries
        }</span>

        // For text-image mixing: avoid merging text that wraps around images
        <span class="cov8" title="1">if isTextImageMix(b1, b2) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov0" title="0">return false</span>
}

// mergeClusters combines two text blocks into one
func mergeClusters(b1, b2 *TextBlock) *TextBlock <span class="cov0" title="0">{
        merged := &amp;TextBlock{
                Texts:       append(b1.Texts, b2.Texts...),
                MinX:        math.Min(b1.MinX, b2.MinX),
                MaxX:        math.Max(b1.MaxX, b2.MaxX),
                MinY:        math.Min(b1.MinY, b2.MinY),
                MaxY:        math.Max(b1.MaxY, b2.MaxY),
                AvgFontSize: (b1.AvgFontSize*float64(len(b1.Texts)) + b2.AvgFontSize*float64(len(b2.Texts))) / float64(len(b1.Texts)+len(b2.Texts)),
        }
        return merged
}</span>

// detectReadingOrder determines the reading order of text blocks
// (left-to-right, top-to-bottom, multi-column, etc.)
func detectReadingOrder(blocks []*TextBlock) []*TextBlock <span class="cov0" title="0">{
        if len(blocks) == 0 </span><span class="cov0" title="0">{
                return blocks
        }</span>

        // For asymmetric layouts, use the enhanced detection
        <span class="cov0" title="0">return detectReadingOrderForAsymmetricLayout(blocks)</span>
}

// detectColumns identifies column structure in text blocks
func detectColumns(blocks []*TextBlock) [][]*TextBlock <span class="cov0" title="0">{
        if len(blocks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // For asymmetric layouts, use a more sophisticated detection algorithm
        <span class="cov0" title="0">return detectAsymmetricColumns(blocks)</span>
}

// detectAsymmetricColumns identifies complex asymmetric column structures
func detectAsymmetricColumns(blocks []*TextBlock) [][]*TextBlock <span class="cov8" title="1">{
        if len(blocks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Calculate page dimensions to understand the layout context
        <span class="cov8" title="1">pageBounds := calculatePageBounds(blocks)

        // Use a more sophisticated approach to detect asymmetric layouts
        // This includes overlapping, nested, and irregular columns

        // Group blocks by Y-ranges (horizontal bands) to understand the layout structure
        bands := groupBlocksByYRange(blocks, pageBounds)

        // Process each band separately to detect columns within that band
        var allColumns [][]*TextBlock
        for _, band := range bands </span><span class="cov8" title="1">{
                bandColumns := detectColumnsInBand(band.Blocks, pageBounds)
                allColumns = append(allColumns, bandColumns...)
        }</span>

        <span class="cov8" title="1">return allColumns</span>
}

// YBand represents a horizontal band of text on a page
type YBand struct {
        MinY, MaxY float64
        Blocks     []*TextBlock
}

// groupBlocksByYRange groups text blocks into horizontal bands
func groupBlocksByYRange(blocks []*TextBlock, pageBounds Rect) []YBand <span class="cov8" title="1">{
        if len(blocks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Sort blocks by Y position
        <span class="cov8" title="1">sortedBlocks := make([]*TextBlock, len(blocks))
        copy(sortedBlocks, blocks)
        sort.Slice(sortedBlocks, func(i, j int) bool </span><span class="cov8" title="1">{
                return sortedBlocks[i].Center().Y &gt; sortedBlocks[j].Center().Y // Top to bottom
        }</span>)

        <span class="cov8" title="1">var bands []YBand
        if len(sortedBlocks) == 0 </span><span class="cov0" title="0">{
                return bands
        }</span>

        // Start with the first block
        <span class="cov8" title="1">currentBand := YBand{
                MinY:   sortedBlocks[0].MinY,
                MaxY:   sortedBlocks[0].MaxY,
                Blocks: []*TextBlock{sortedBlocks[0]},
        }

        const yTolerance = 10.0 // Tolerance for considering blocks in same band

        for _, block := range sortedBlocks[1:] </span><span class="cov8" title="1">{
                // Check if this block overlaps vertically with the current band
                overlap := math.Min(currentBand.MaxY, block.MaxY) - math.Max(currentBand.MinY, block.MinY)

                if overlap &gt;= -yTolerance </span><span class="cov8" title="1">{ // Allow slight gaps
                        // Extend the band to include this block
                        currentBand.MinY = math.Min(currentBand.MinY, block.MinY)
                        currentBand.MaxY = math.Max(currentBand.MaxY, block.MaxY)
                        currentBand.Blocks = append(currentBand.Blocks, block)
                }</span> else<span class="cov8" title="1"> {
                        // Start a new band
                        bands = append(bands, currentBand)
                        currentBand = YBand{
                                MinY:   block.MinY,
                                MaxY:   block.MaxY,
                                Blocks: []*TextBlock{block},
                        }
                }</span>
        }

        // Add the last band
        <span class="cov8" title="1">if len(currentBand.Blocks) &gt; 0 </span><span class="cov8" title="1">{
                bands = append(bands, currentBand)
        }</span>

        <span class="cov8" title="1">return bands</span>
}

// calculatePageBounds calculates the overall bounds of all text blocks
func calculatePageBounds(blocks []*TextBlock) Rect <span class="cov8" title="1">{
        if len(blocks) == 0 </span><span class="cov0" title="0">{
                return Rect{}
        }</span>

        <span class="cov8" title="1">minX, minY := blocks[0].MinX, blocks[0].MinY
        maxX, maxY := blocks[0].MaxX, blocks[0].MaxY

        for _, block := range blocks[1:] </span><span class="cov8" title="1">{
                minX = math.Min(minX, block.MinX)
                minY = math.Min(minY, block.MinY)
                maxX = math.Max(maxX, block.MaxX)
                maxY = math.Max(maxY, block.MaxY)
        }</span>

        <span class="cov8" title="1">return Rect{
                Min: Point{X: minX, Y: minY},
                Max: Point{X: maxX, Y: maxY},
        }</span>
}

// detectColumnsInBand detects columns within a horizontal band
func detectColumnsInBand(blocks []*TextBlock, pageBounds Rect) [][]*TextBlock <span class="cov8" title="1">{
        if len(blocks) == 0 </span><span class="cov0" title="0">{
                return [][]*TextBlock{}
        }</span>

        // For each band, detect potential columns based on X positions and gaps
        // Sort blocks by X position
        <span class="cov8" title="1">sorted := make([]*TextBlock, len(blocks))
        copy(sorted, blocks)
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                return sorted[i].MinX &lt; sorted[j].MinX
        }</span>)

        <span class="cov8" title="1">var columns [][]*TextBlock

        // Use a more sophisticated algorithm that considers:
        // 1. Gaps between text blocks
        // 2. Overlapping regions
        // 3. Asymmetric layouts

        // Calculate gap threshold based on page width
        pageWidth := pageBounds.Max.X - pageBounds.Min.X
        gapThreshold := pageWidth * 0.05 // 5% of page width as minimum gap for separate columns

        // Group blocks based on proximity and gaps
        currentColumn := []*TextBlock{sorted[0]}

        for _, block := range sorted[1:] </span><span class="cov8" title="1">{
                // Calculate gap to previous block in current column
                lastBlock := currentColumn[len(currentColumn)-1]
                gap := block.MinX - lastBlock.MaxX

                // Check if there's a significant gap or if blocks overlap significantly
                if gap &gt; gapThreshold </span><span class="cov8" title="1">{
                        // Significant gap - start new column
                        columns = append(columns, currentColumn)
                        currentColumn = []*TextBlock{block}
                }</span> else<span class="cov8" title="1"> if hasSignificantVerticalOverlap(lastBlock, block) </span><span class="cov8" title="1">{
                        // Blocks overlap vertically - likely same column
                        currentColumn = append(currentColumn, block)
                }</span> else<span class="cov0" title="0"> {
                        // Check if block belongs to an existing column based on alignment
                        placed := false
                        for i, col := range columns </span><span class="cov0" title="0">{
                                if canAddToColumn(col, block, gapThreshold) </span><span class="cov0" title="0">{
                                        columns[i] = append(col, block)
                                        placed = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !placed </span><span class="cov0" title="0">{
                                // Add to current column
                                currentColumn = append(currentColumn, block)
                        }</span>
                }
        }

        // Add the last column
        <span class="cov8" title="1">if len(currentColumn) &gt; 0 </span><span class="cov8" title="1">{
                columns = append(columns, currentColumn)
        }</span>

        <span class="cov8" title="1">return columns</span>
}

// hasSignificantVerticalOverlap checks if two blocks have significant vertical overlap
func hasSignificantVerticalOverlap(b1, b2 *TextBlock) bool <span class="cov8" title="1">{
        verticalOverlap := math.Min(b1.MaxY, b2.MaxY) - math.Max(b1.MinY, b2.MinY)
        if verticalOverlap &lt;= 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Consider significant if overlap covers at least 20% of the smaller block's height.
        <span class="cov8" title="1">height1 := b1.MaxY - b1.MinY
        height2 := b2.MaxY - b2.MinY
        minHeight := math.Min(height1, height2)
        if minHeight &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return verticalOverlap &gt;= minHeight*0.2</span>
}

// canAddToColumn checks if a block can be added to an existing column
func canAddToColumn(column []*TextBlock, newBlock *TextBlock, gapThreshold float64) bool <span class="cov8" title="1">{
        if len(column) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if the new block aligns with the column
        <span class="cov8" title="1">avgLeft := 0.0
        avgRight := 0.0
        for _, block := range column </span><span class="cov8" title="1">{
                avgLeft += block.MinX
                avgRight += block.MaxX
        }</span>
        <span class="cov8" title="1">avgLeft /= float64(len(column))
        avgRight /= float64(len(column))

        leftDiff := math.Abs(newBlock.MinX - avgLeft)
        rightDiff := math.Abs(newBlock.MaxX - avgRight)

        // Block can join the column if it aligns reasonably well
        return leftDiff &lt; gapThreshold &amp;&amp; rightDiff &lt; gapThreshold</span>
}

// detectReadingOrderForAsymmetricLayout determines the reading order for asymmetric layouts
func detectReadingOrderForAsymmetricLayout(blocks []*TextBlock) []*TextBlock <span class="cov8" title="1">{
        if len(blocks) == 0 </span><span class="cov0" title="0">{
                return blocks
        }</span>

        // Group into horizontal bands first
        <span class="cov8" title="1">bands := groupBlocksByYRange(blocks, calculatePageBounds(blocks))

        // Process each band: sort blocks within the band, then order bands
        var result []*TextBlock

        // Sort bands from top to bottom (Y coordinates are typically larger at the top in PDFs)
        sort.Slice(bands, func(i, j int) bool </span><span class="cov8" title="1">{
                return bands[i].MaxY &gt; bands[j].MaxY // Higher Y values are at the top
        }</span>)

        <span class="cov8" title="1">for _, band := range bands </span><span class="cov8" title="1">{
                // Sort blocks within each band based on reading order
                sortedBandBlocks := sortBlocksInBand(band.Blocks)
                result = append(result, sortedBandBlocks...)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// sortBlocksInBand sorts blocks within a horizontal band
func sortBlocksInBand(blocks []*TextBlock) []*TextBlock <span class="cov8" title="1">{
        if len(blocks) &lt;= 1 </span><span class="cov8" title="1">{
                return blocks
        }</span>

        // For asymmetric layouts, use a flow-based approach
        // Consider text flow, not just column positions

        // First, identify the main flow direction in this band
        // This could be left-to-right columns, but also more complex flows

        // Simple approach: sort by X position (left to right)
        <span class="cov8" title="1">sorted := make([]*TextBlock, len(blocks))
        copy(sorted, blocks)
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                return sorted[i].MinX &lt; sorted[j].MinX
        }</span>)

        <span class="cov8" title="1">return sorted</span>
}

// sortWithinBlock sorts texts within a single block in reading order
func sortWithinBlock(texts []Text) []Text <span class="cov0" title="0">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return texts
        }</span>

        // Group into lines
        <span class="cov0" title="0">type line struct {
                y     float64
                texts []Text
        }

        const lineTolerance = 3.0
        var lines []line

        sorted := make([]Text, len(texts))
        copy(sorted, texts)

        // Sort by Y first (top to bottom)
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov0" title="0">{
                if math.Abs(sorted[i].Y-sorted[j].Y) &gt; lineTolerance </span><span class="cov0" title="0">{
                        return sorted[i].Y &gt; sorted[j].Y
                }</span>
                <span class="cov0" title="0">return sorted[i].X &lt; sorted[j].X</span>
        })

        // Group into lines
        <span class="cov0" title="0">for _, t := range sorted </span><span class="cov0" title="0">{
                placed := false
                for i := range lines </span><span class="cov0" title="0">{
                        if math.Abs(t.Y-lines[i].y) &lt;= lineTolerance </span><span class="cov0" title="0">{
                                lines[i].texts = append(lines[i].texts, t)
                                placed = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !placed </span><span class="cov0" title="0">{
                        lines = append(lines, line{y: t.Y, texts: []Text{t}})
                }</span>
        }

        // Sort each line left-to-right
        <span class="cov0" title="0">var result []Text
        for _, l := range lines </span><span class="cov0" title="0">{
                sort.Slice(l.texts, func(i, j int) bool </span><span class="cov0" title="0">{
                        return l.texts[i].X &lt; l.texts[j].X
                }</span>)
                <span class="cov0" title="0">result = append(result, l.texts...)</span>
        }

        <span class="cov0" title="0">return result</span>
}

// SmartTextRunsToPlain converts text runs to plain text using improved ordering
func SmartTextRunsToPlain(texts []Text) string <span class="cov0" title="0">{
        if len(texts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Use smart ordering algorithm
        <span class="cov0" title="0">ordered := smartTextOrdering(texts)

        // Group into lines for formatting
        const lineTolerance = 3.0
        var lines [][]Text
        var currentLine []Text
        var currentY float64

        for i, t := range ordered </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        currentLine = []Text{t}
                        currentY = t.Y
                        continue</span>
                }

                <span class="cov0" title="0">if math.Abs(t.Y-currentY) &lt;= lineTolerance </span><span class="cov0" title="0">{
                        currentLine = append(currentLine, t)
                }</span> else<span class="cov0" title="0"> {
                        if len(currentLine) &gt; 0 </span><span class="cov0" title="0">{
                                lines = append(lines, currentLine)
                        }</span>
                        <span class="cov0" title="0">currentLine = []Text{t}
                        currentY = t.Y</span>
                }
        }
        <span class="cov0" title="0">if len(currentLine) &gt; 0 </span><span class="cov0" title="0">{
                lines = append(lines, currentLine)
        }</span>

        // Build output with proper spacing
        <span class="cov0" title="0">var builder strings.Builder
        for i, line := range lines </span><span class="cov0" title="0">{
                appendLine(&amp;builder, line)
                if i &lt; len(lines)-1 </span><span class="cov0" title="0">{
                        builder.WriteByte('\n')
                }</span>
        }

        <span class="cov0" title="0">return strings.TrimRight(builder.String(), "\n")</span>
}

// isAsymmetricLayout checks if two blocks are in different asymmetric layout regions
func isAsymmetricLayout(b1, b2 *TextBlock) bool <span class="cov8" title="1">{
        // Simple heuristic: if blocks are far apart horizontally and vertically,
        // they might be in different layout regions
        horizontalDistance := math.Abs(b1.Center().X - b2.Center().X)
        verticalDistance := math.Abs(b1.Center().Y - b2.Center().Y)

        // If horizontal distance is much larger than vertical, likely different columns
        if horizontalDistance &gt; verticalDistance*2 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// isTextImageMix checks if text blocks are separated by potential image regions
func isTextImageMix(b1, b2 *TextBlock) bool <span class="cov8" title="1">{
        // Heuristic: if there's a large gap between blocks, might be image
        gapX := math.Abs(b1.Center().X - b2.Center().X)
        gapY := math.Abs(b1.Center().Y - b2.Center().Y)

        // If gap is larger than average block size, might be image
        avgSize := (b1.Width() + b1.Height() + b2.Width() + b2.Height()) / 4
        if gapX &gt; avgSize*2 || gapY &gt; avgSize*2 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// detectFootnotes identifies potential footnote blocks
func detectFootnotes(blocks []*TextBlock, pageHeight float64) []*TextBlock <span class="cov8" title="1">{
        var footnotes []*TextBlock

        for _, block := range blocks </span><span class="cov8" title="1">{
                // Footnotes are typically at the bottom of the page, small font
                if block.Center().Y &gt; pageHeight*0.8 &amp;&amp; block.AvgFontSize &lt; 10 </span><span class="cov8" title="1">{
                        footnotes = append(footnotes, block)
                }</span>
        }

        <span class="cov8" title="1">return footnotes</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright 2024 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pdf

import (
        "unsafe"
)

// ZeroCopyString 
//  Go 

// BytesToString  []byte  string
//  []byte
func BytesToString(b []byte) string <span class="cov8" title="1">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return *(*string)(unsafe.Pointer(&amp;b))</span>
}

// StringToBytes  string  []byte
//  []byte 
func StringToBytes(s string) []byte <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        //  unsafe 
        <span class="cov8" title="1">return unsafe.Slice(unsafe.StringData(s), len(s))</span>
}

// SubstringZeroCopy 
//  Go 
func SubstringZeroCopy(s string, start, end int) string <span class="cov8" title="1">{
        if start &lt; 0 || end &gt; len(s) || start &gt; end </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return s[start:end]</span>
}

// StringBuffer 
type StringBuffer struct {
        buf []byte
}

// NewStringBuffer 
func NewStringBuffer(capacity int) *StringBuffer <span class="cov8" title="1">{
        return &amp;StringBuffer{
                buf: make([]byte, 0, capacity),
        }
}</span>

// WriteString 
func (sb *StringBuffer) WriteString(s string) <span class="cov8" title="1">{
        sb.buf = append(sb.buf, s...)
}</span>

// WriteByte 
func (sb *StringBuffer) WriteByte(b byte) error <span class="cov8" title="1">{
        sb.buf = append(sb.buf, b)
        return nil
}</span>

// WriteBytes 
func (sb *StringBuffer) WriteBytes(b []byte) <span class="cov0" title="0">{
        sb.buf = append(sb.buf, b...)
}</span>

// String 
//  StringBuffer
func (sb *StringBuffer) String() string <span class="cov0" title="0">{
        return BytesToString(sb.buf)
}</span>

// StringCopy 
func (sb *StringBuffer) StringCopy() string <span class="cov8" title="1">{
        return string(sb.buf)
}</span>

// Len 
func (sb *StringBuffer) Len() int <span class="cov8" title="1">{
        return len(sb.buf)
}</span>

// Cap 
func (sb *StringBuffer) Cap() int <span class="cov0" title="0">{
        return cap(sb.buf)
}</span>

// Reset 
func (sb *StringBuffer) Reset() <span class="cov8" title="1">{
        sb.buf = sb.buf[:0]
}</span>

// Bytes 
func (sb *StringBuffer) Bytes() []byte <span class="cov0" title="0">{
        return sb.buf
}</span>

// StringPool 
type StringPool struct {
        pool map[string]string
}

// NewStringPool 
func NewStringPool() *StringPool <span class="cov8" title="1">{
        return &amp;StringPool{
                pool: make(map[string]string),
        }
}</span>

// Intern 
// 
func (sp *StringPool) Intern(s string) string <span class="cov8" title="1">{
        if cached, ok := sp.pool[s]; ok </span><span class="cov8" title="1">{
                return cached
        }</span>
        // 
        <span class="cov8" title="1">sp.pool[s] = s
        return s</span>
}

// Clear 
func (sp *StringPool) Clear() <span class="cov8" title="1">{
        sp.pool = make(map[string]string)
}</span>

// Size 
func (sp *StringPool) Size() int <span class="cov8" title="1">{
        return len(sp.pool)
}</span>

// InplaceStringBuilder 
// 
type InplaceStringBuilder struct {
        parts  []string
        length int
}

// NewInplaceStringBuilder 
func NewInplaceStringBuilder(capacity int) *InplaceStringBuilder <span class="cov8" title="1">{
        return &amp;InplaceStringBuilder{
                parts: make([]string, 0, capacity),
        }
}</span>

// Append 
func (isb *InplaceStringBuilder) Append(s string) <span class="cov8" title="1">{
        isb.parts = append(isb.parts, s)
        isb.length += len(s)
}</span>

// Build 
func (isb *InplaceStringBuilder) Build() string <span class="cov8" title="1">{
        if len(isb.parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(isb.parts) == 1 </span><span class="cov0" title="0">{
                return isb.parts[0]
        }</span>

        // 
        <span class="cov8" title="1">buf := make([]byte, 0, isb.length)
        for _, part := range isb.parts </span><span class="cov8" title="1">{
                buf = append(buf, part...)
        }</span>
        <span class="cov8" title="1">return BytesToString(buf)</span>
}

// Reset 
func (isb *InplaceStringBuilder) Reset() <span class="cov0" title="0">{
        isb.parts = isb.parts[:0]
        isb.length = 0
}</span>

// Len 
func (isb *InplaceStringBuilder) Len() int <span class="cov8" title="1">{
        return isb.length
}</span>

// StringInterning 
var globalStringPool = NewStringPool()

// InternString 
func InternString(s string) string <span class="cov0" title="0">{
        return globalStringPool.Intern(s)
}</span>

// ClearGlobalStringPool 
func ClearGlobalStringPool() <span class="cov0" title="0">{
        globalStringPool.Clear()
}</span>

// FastStringConcatZC 
func FastStringConcatZC(parts ...string) string <span class="cov8" title="1">{
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(parts) == 1 </span><span class="cov8" title="1">{
                return parts[0]
        }</span>

        // 
        <span class="cov8" title="1">totalLen := 0
        for _, part := range parts </span><span class="cov8" title="1">{
                totalLen += len(part)
        }</span>

        // 
        <span class="cov8" title="1">buf := make([]byte, 0, totalLen)
        for _, part := range parts </span><span class="cov8" title="1">{
                buf = append(buf, part...)
        }</span>

        <span class="cov8" title="1">return BytesToString(buf)</span>
}

// StringSliceToByteSlice  []string 
//  [][]byte 
func StringSliceToByteSlice(strings []string) [][]byte <span class="cov0" title="0">{
        result := make([][]byte, len(strings))
        for i, s := range strings </span><span class="cov0" title="0">{
                result[i] = StringToBytes(s)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// CompareStringsZeroCopy 
//  -1 (s1 &lt; s2), 0 (s1 == s2), 1 (s1 &gt; s2)
func CompareStringsZeroCopy(s1, s2 string) int <span class="cov0" title="0">{
        // Go 
        if s1 &lt; s2 </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if s1 &gt; s2 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// HasPrefixZeroCopy 
func HasPrefixZeroCopy(s, prefix string) bool <span class="cov8" title="1">{
        if len(prefix) &gt; len(s) </span><span class="cov0" title="0">{
                return false
        }</span>
        // 
        <span class="cov8" title="1">return s[:len(prefix)] == prefix</span>
}

// HasSuffixZeroCopy 
func HasSuffixZeroCopy(s, suffix string) bool <span class="cov8" title="1">{
        if len(suffix) &gt; len(s) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return s[len(s)-len(suffix):] == suffix</span>
}

// TrimSpaceZeroCopy 
func TrimSpaceZeroCopy(s string) string <span class="cov8" title="1">{
        start := 0
        end := len(s)

        // 
        for start &lt; end </span><span class="cov8" title="1">{
                c := s[start]
                if c != ' ' &amp;&amp; c != '\t' &amp;&amp; c != '\n' &amp;&amp; c != '\r' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">start++</span>
        }

        // 
        <span class="cov8" title="1">for end &gt; start </span><span class="cov8" title="1">{
                c := s[end-1]
                if c != ' ' &amp;&amp; c != '\t' &amp;&amp; c != '\n' &amp;&amp; c != '\r' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">end--</span>
        }

        <span class="cov8" title="1">return s[start:end]</span>
}

// SplitZeroCopy 
// 
func SplitZeroCopy(s string, sep byte) []string <span class="cov8" title="1">{
        n := 0
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                if s[i] == sep </span><span class="cov8" title="1">{
                        n++
                }</span>
        }

        <span class="cov8" title="1">result := make([]string, 0, n+1)
        start := 0
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                if s[i] == sep </span><span class="cov8" title="1">{
                        result = append(result, s[start:i])
                        start = i + 1
                }</span>
        }
        <span class="cov8" title="1">result = append(result, s[start:])

        return result</span>
}

// JoinZeroCopy 
func JoinZeroCopy(parts []string, sep string) string <span class="cov8" title="1">{
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(parts) == 1 </span><span class="cov8" title="1">{
                return parts[0]
        }</span>

        // 
        <span class="cov8" title="1">totalLen := 0
        for _, part := range parts </span><span class="cov8" title="1">{
                totalLen += len(part)
        }</span>
        <span class="cov8" title="1">totalLen += (len(parts) - 1) * len(sep)

        // 
        buf := make([]byte, 0, totalLen)
        buf = append(buf, parts[0]...)
        for i := 1; i &lt; len(parts); i++ </span><span class="cov8" title="1">{
                buf = append(buf, sep...)
                buf = append(buf, parts[i]...)
        }</span>

        <span class="cov8" title="1">return BytesToString(buf)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
